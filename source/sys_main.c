/** @file sys_main.c 
*   @brief Application main file
*   @date 11-Dec-2018
*   @version 04.07.01
*
*   This file contains an empty main function,
*   which can be used for the application.
*/

/* 
* Copyright (C) 2009-2018 Texas Instruments Incorporated - www.ti.com 
* 
* 
*  Redistribution and use in source and binary forms, with or without 
*  modification, are permitted provided that the following conditions 
*  are met:
*
*    Redistributions of source code must retain the above copyright 
*    notice, this list of conditions and the following disclaimer.
*
*    Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the 
*    documentation and/or other materials provided with the   
*    distribution.
*
*    Neither the name of Texas Instruments Incorporated nor the names of
*    its contributors may be used to endorse or promote products derived
*    from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/


/* USER CODE BEGIN (0) */
/*
 *
 * B_CIB 001.c 20JAN14 A program to control an EPS controller for electric steering.

                This program is written for TMS570 Bulgarian Board microcontroller to run on the RTS CIB Board. It is
                designed to accept RS-485 commands from the host Labview app.
                All commands are board ID dependent.

                Depending on the products configuration the CIB must be equipped with auxiliary boards.

* Assigned Bulgarian Board micro features:
*
*   NHET[0]     T1 - SENT1-OUT or PWM
    NHET[1]     T2 - SENT2-OUT or PWM
    NHET[2]     SCL - SENT1-IN or I2C
    NHET[3]     SDA - SENT2-IN or I2C
    NHET[4]     DIGITOUT1 or SENT3-OUT
    NHET[5]     DIGITOUT2 or SENT4-OUT
    NHET[6]     DIGITOUT3 or SENT3-IN
    NHET[7]     DIGITOUT4 or SENT4-IN
    NHET[8]     DIGITIN1 or SENT5-OUT
    NHET[9]     DIGITIN2 or SENT6-OUT
    NHET[10]    DIGITIN3 or SENT5-IN
    NHET[11]    DIGITIN4 or SENT6-IN
    NHET[12]    Board ID HEX SW-1
    NHET[13]    Board ID HEX SW-2
    NHET[14]    Board ID HEX SW-3
    NHET[15]    Board ID HEX SW-4
    NHET[16]    S-WireEEPROM
    NHET[18]    Module DIGITALID1
    NHET[20]    Module TCPIPID2
    NHET[21]    Module SENSEID3
    NHET[22]    Module SENSEID4
    NHET[23]    Module FRAYID5
    NHET[24]    FRAYERR1
    NHET[28]    FRAYERR2
    NHET[30]    SW-IGN3


    AD1IN[0]    N/A MSB - Sin
    AD1IN[1]    N/A MSB - Cos
    AD1IN[2]    N/A MSB - InvSin
    AD1IN[3]    N/A MSB - InvCos
    AD1IN[4]    N/A TC -  Sin
    AD1IN[5]    N/A TC -  Cos
    AD1IN[6]    N/A T1
    AD1IN[7]    N/A T2
    ADSIN[8]    Prod 3.3v
    ADSIN[9]    Prod 5v
    ADSIN[10]   Ignition
    ADSIN[11]   2.5v Ref
        ADSIN[12]   Reserved for Current Measurement - Large
        ADSIN[13]   Reserved for Current Measurement - Small

    GIOA[0] LAN CP1
    GIOA[1] LAN CP2
    GIOA[2] LAN CP3
    GIOA[3] User SW-1
    GIOA[4] User LED1 / Trig / RXD LED and Compatabilty Board I/O
    GIOA[5] User LED2 / Trig / TXD LED and Compatabilty Board I/O
    GIOA[6] User LED3 / Trig / RUN LED and Compatabilty Board I/O
    GIOA[7] User LED4 / Trig / RUN LED and Compatabilty Board I/O

    LIN1RX      Debug interface on Bulgarian Board
    LIN1TX      Debug interface on Bulgarian Board
    LIN2RX  RS485 or LAN
    LIN2TX  RS485 or LAN

    MIBSPI1CLK          CLK for D/A converter
    #MIBSPI1CS[0]       ChipSelect for D/A converter
    #MIBSPI1CS[1]
    #MIBSPI1ENA
    MIBSPI1SIMO         SlaveIn/MasterOut for D/A converter
    MIBSPI1SOMI

    MIBSPI3CLK
    #MIBSPI3CS[0]
    #MIBSPI3ENA
    MIBSPI3SIMO
    MIBSPI3SOMI

    MIBSPI5CLK
    #MIBSPI5CS[0]
    #MIBSPI5CS[1]       Itrigger/Relay (compatibility board)
    #MIBSPI5ENA         LAN Reset
    MIBSPI5SIMO[0]
    MIBSPI5SOMI[0]      RS485TX-ENA
    (SPIREG5 SOMI[1] and SIMO[3] are hard wired to LEDs on Bulgarian board)

    FRAYRX1
    FRAYTX1
    FRAYTXEN1
    FRAYRX2
    FRAYTX2
    FRAYTXEN2

    CAN1-L
    CAN1-H
    CAN2-L
    CAN2-H
*
*

    Developing MIBSPI1 for Digital Pots.
            Leonard M. Cronk 29JAN14, 11MAR14

    Developing RS485 enable port using spiREG5 SOMI[0]
            Leonard M. Cronk 25MAR14

    Developed GIOA code for User LEDs
            Leonard M. Cronk 10APR14

    Developed ADC code for 12 a/d channels, Digital Pot Board is occupying the sensor board slot
        For Now! Twelve a/d channels using DAC1 are included in "Group1" and set to scan once and cause interrupt when complete.
        adcNotification(adcREG1,adcGROUP1) ISR will move results to user array for later processing.

            Leonard M. Cronk 16APR14

    Added print A/D results to SCI port 1, USB debug connection.  Use terminal addon and seperate
        to view conversion results.
            Leonard M. Cronk 02MAY14

    Corrected Digital Pot Channel assignments.  Installed Code Composer v6.0
            Leonard M. Cronk 27MAY14
    Implimented FIR filter to A/D channels with 12ch of results in adc1_Group_filtered[]
        FIR (finite impulse response (FIR) digital filter), or Moving Average Filter.
            Leonard M. Cronk 28MAY14
    During pre-Main() code, added vref range check for 2.5volt reading, set vref flag=TRUE.  If flag, AtoD ISR will convert counts to mVolts else
        set to -1 for all channels, except CH11 the 2.5v vref.  Set this one to the mV so user can see the value which
        caused the error.
            Leonard M. Cronk 30MAY14

    Porting Phil's SCI2 code for RS485 communications.
        Based on original CIB code and addapted for TMS570 with HalCoGen implentation.  Transmits use sciSEND().  Build "constant_str[]" for normal replies
        or "return_message[]" for dump replies. Call either the function "transmit_constant_str_485() or transmit_return_message()" and forget.
             Leonard M. Cronk 26JUN14

    Switching to "Analog I/O Sensor board" from "Digital Pot Sensor board", Pot board too sensitive to center tap loading.
        Coded using spiREG1 and tested. Results good. For test purpose Output results on sciREG1, Termnal1 console.
            Leonard M. Cronk 01AUG14

    Completed RS485 porting.  Added "RS-485_Comm.c" removing function def from "sys_main.c".  Combined past RS485 calls in to one, and you now pass
        a pointer to the null terminated string you want transmitted.  void transmit_str_485(char * return_message)...
            Leonard M. Cronk 21AUG14

    Added sciREG1 as serial comm to Bulgarian usb port for debugging.  Interupt TX driven 9600, 1stop, no parity.
            Leonard M. Cronk 23AUG14

    Porting over Ford S550-UP375 rev7 03_01_05.  Final HalCoGen configuration is "B_CIB Porting 002.hcg".
            Leonard M. Cronk 25AUG14

    Port complete, editing CAN messages for valid U375 variable addresses. Final HalCoGen configuration is "B_CIB Porting 002.hcg".
        Coding for "atod_print_all times#" is contained in RTI - Notification: if((system_msec_clock % 201 == 0)) //if reqested, write AtoD values to RS485
            Leonard M. Cronk 09SEP14.

    Verification - Issue found, dump_err hangs with Ign_on.  Found that sprintf() call within CAN notification (ISR), will corrupt stack.  Upon exit and
        final return to MAIN, POP of Program Counter (PC), will point to outer space.  This will cause an Exception Fault and HalCoGen EF routine
        does a forever loop. Variety of thing tried, bigger stack, different string library ect..  Implimented "work around", "void parse_can1_data(void);".
        Store data in the CAN ISR and processes it back in MAIN.
            Leonard M. Cronk 15SEP14

    Bench testing using 3 Half boards (routed version of Bulgarian CIB), in rack and running 3 Ford U375 parts. Code ran, dumping once per minute.  No DTCs
        or other issues noted with the CIB, TMS570 or code.  Testing ran 3 weeks continous.
            Leonard M. Cronk 02OCT14

B_CIB TCP 001 Project
    Code moved to B_CIB TCP 001 for LAN integration.  Add quick debug in main to intercept and echo to sciREG1 of serial messages, LAN messages
         received.  Ripped up - sciNotification.  Will now assume any serial message received is ment for this CIB, because IP addressing now
         performs this function, instead of addressing with Mark-Space on RS485 serial byte.
             Leonard M. Cronk 25JAN15

        Adding USER SWITCH1 - SW1, functionality.  Bulgarian CIB (both versions) uses SW1, RS485 version (for soft RESET of TMS570)
        for TCPIP version (for soft RESET of TMS570 and SNAP to rack).  SNAP feature valid for 10 seconds.
            Leonard M. Cronk 17FEB15

        SW1, SNAP and RESET functions complete.  Both versions of code supports - RESET.  It takes place if SW1 is held down (more than 3 seconds)
        then released.  Both versions of code will perform the action of a SNAP, (10 second spin of LEDs[4,5,6,7]) and reversion to previous code) as
        if the SNAP was missed.  But only the TCPIP version can be SNAPPED.
             Leonard M. Cronk 19FEB15

         Added "scilinREG_is_CIB_or_Monitor_or_WEB" var.  State is set depending on current task.  On reset, J2 jumper block is read and CIB communications
         is determine,, RS485 or LAN.  During transmission and reception, CIB needs to ensure I/O and registers are configured correctly.
         "scilinREG_is_CIB_or_Monitor_or_WEB", will allow branching to correct code for each comm method.
              Leonard M. Cronk 23FEB15

        Added unit32 board_configuration_bin;   // hex switch located at NHET[18,20,21,22,23]. Engagement of daughter boards or LAN jumper configuration
        will change voltage levels on NHETs.  During init, CIB is inventoried.  Lantronix, if present is quired about MAC and IP address.
            Leonard M. Cronk 24FEB15

        Exspanded "I N I T I A L I Z E" code to set CIB communications personality (RS485 or TCP). Based on J2 switch will initialize SCI2 for either RS485
        or TCP.  If TCP code will reset Lantronix, and send message to place device into MONITOR mode.  Added command "0", needed to interpet Lantronix transmit
        to CIB on SCI2. Messaging will collect device IP address and MAC address, then reset device returning it to 19200 baud and WEB mode, passing messages
        from LAN to CIB just as RS485 would.  Added "snap" command, transmits IP and MAC address and Board ID bases on rotary switch back to RTS,executes
        remaining steps to complete SNAP to RTS, LEDs 1,2,3,4 will flash for 3 sec.
            Leonard M. Cronk 13MAR15

        Add concept of "A" level WEB commands, commands accepted only from SNAPPED host IP.  IE.. p_on, 0amp, clear_dtcs ect, and will execute CIB and product
        statuses to everyone who asks correctly EI.. dumpver, atod_print_all, dumperr ect...
            Leonard M. Cronk 25MAR15

B_CIB TCP 002 Project
    Code moved to B_CIB TCP 002 for Digital Touque Sensor creation using NHET. (tms570LS20 only has NHET, Not N2HET)
            Leonard M. Cronk 04APR15

        Added NHET for creating One channel of SENT, output only.. Using the HET Tool and HalCoGen(set up HR Prescaller and Loop Time).  Must Point to HET stuff
        in HalCoGen -- HET tab HET Driver Setting and select the output files of the HET Tool.  Of course reGenerate your code.
            Leonard M. Cronk 27APR15

B_CIB TCP 003 Project
        Completed HET code for 2ch SENT, SENT1 output - HET[0] and SENT2 output - HET[1].  HET code will cause IRQ on product trigger, SENT1 - input on HET[2]
        and SENT2 - input on HET[3], signal routing done on Digital I/O Board SENT.  IRQ is seviced in HET Notification where each request will load HET memory with
        new data based on torque calculations done in MAIN - sent_data_calculation() and stored in Global array sent_data_array[9].  Where sent_data_array[9] =
        BUSY,Sent1 data0,data1,data2,CRC and Sent1 data0,data1,data2,CRC.
            Leonard M. Cronk 18MAY15
        Improved HET code effectiveness, HET_Pulses_using_running counter_03.HET, reducing cal burden in HET code, shifting it to Main.
        Now can run up to 6 SENT channel.  Concept same as before.
            sent_update_flag holds ACTIVE/IDLE flag to HET Notification, to or not to update HET RAM.
            sent_edge_event_time[x][14] contains the times based on SENT clock tick for each edge in SENT message packet,, for x channels
            sent_data_array[8] contains formatted data for -- Sent0 data0,data1,data2,CRC and Sent1 data0,data1,data2,CRC
                Leonard M. Cronk 29MAY15
        dumperr_vign corrected for B_CIB design, volt drop(in mV)*6(divider ratio) = converted to mV(Ex: 9.0V = 9000) was *4.
        Added Cal Lab: calibration commands "cal_step1,2,3,4,5,6,7" outputting 0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0volt.
                Leonard M. Cronk 15JUN15
        Added ad_ground_offset_in_tick, test for weather B_Board is powered though 96way connector, JTAG or 5v wall plug,
            if it the 96way, add 20 ticks to all A/D measurements due to interconnect loss.  Improved readback at both ends... 0.5v was 0.45v 10% error;
            now 0.502v at 0.4% error,, at 5.000v was 5.050v 1% now 5.010v at 0.2% error.  Was going to rebuild CAN harness to add extra ground wire
            to improve interconnect, but software look like a good solution.  Not this issue should go away when we move away from B_Board to a CPU Module
            because interconnect loses should not be present.
                Leonard M. Cronk 17JUN15

//// R E M E M B E R    R E M O V E   H E T trigger in Notification -if((system_msec_clock % 10 == 0)) // Testing out hetRam access, using a direct pointer to ASM line
////        Toggles NHET[28]    FRAYERR1 (setup as open drain),  so you can add wire from header to snag SENT1 or SENT2 pins and create a timed pull down trigger.

Ford FOAA rev01 xx_xx_xx Project
    Code moved to B_CIB TCP 003 for New Ford FOAA program using digital torque.
        Leonard M. Cronk 19JUN15
    Tested "Digital I/O Board - SENT 2CH" daughter board, works as planned.
    Stand Alone code must init HET pins used for interrupt activity, Use HaCoGen and init HET[2,3] to internal pullup, else hardware will not reconize
    falling edge of trigger and generate an interupt.  Also, continued with code cleanup and comments.
        Leonard M. Cronk 02JUL15
    Cleaned up dumperr.  Added CIB's 3volt product read, CIB's value_sent1 and value_sent2, Product can_sent1, can_sent2 and can_sent_status.
    Increased can_indexes for additional reads.  Added CAN constants for new reads.  Deleted can_mot_id_str and can_Fee_Cntr_cnt.
    Deleted unused variables.  Added product read can_HwTrq_HwNm2_str, for torque read for digital sensor.  Updated parse_can1_data() adding new vars.
        Leonard M. Cronk 29JUL15 - 03AUG15
    Updated CAN constants for FOAA variable names and addresses, updating Sent vars to floats, in defines, parsing and ssprintf().
        Leonard M. Cronk 19AUG15

GM T1XX rev xx_xxx_xx Project
    Code moved from Ford FOAA rev01 xx_xx_xx and using HET code HET_T1XX_SENT6ch_1uS_tick_02.het to generate 6 digital SENT sensor signals.
    Mergining GM C1XX code as base for general code flow a CIB program, and Ford FOAA as basis for running on B_CIB.
        Leonard M. Cronk 10SEP15
    Added CheckSum, Rolling Counter and Validity Byte to CAN Speed Message, in rtiNotification, now required.
        Leonard M. Cronk 09SEP15
    Now sent_edge_event_time[x][15]
        Leonard M. Cronk 21SEP15
    Changes in HET code to more match SENT sensor output. Additional sent_edge_event_time added to run up loop Max count, ensuring next SENT squirt follows
    Trigger at same time.  This additional edge event will push a ISR which now will be processed during idles between Triggers,  Updating SENT edge times
    for next Trigger.
        Leonard M. Cronk 30SEP15
    Continue C1XX merge, changing Ingition strategy to combine ing_on_flag and Engine_on_Signal into ign1_status.  ign1_status (Off, On, Warm_Init) states.
    Off    = no ign(volts) and flag to dump_err(0's), Engine_on_Signal(CAN) = off
    Normal = yes ign(volts) and flag to dump_err(data), Engine_on_Signal(CAN) = on
    Warm   = no ign(volts) and flag to dump_err(data), Engine_on_Signal(AN) = on
        Leonard M. Cronk 15OCT15
    Updated SENT, still 6ch but 2 channels mux additional address nibble from 0 to 1 on alternate triggers.  Added SENT constant tables for all required combination of
    torque and handwheel values.  Added sent_data_calculation_from_table() allowing passing of desired table which calculates and stuffs new SENT edge times for
    consumption by ISR to load HET processor at idle time.  Commented out Manufacturing Service for TOC and Tester Present messages, not need if SENT sensor
    simulation is present.
        Leonard M. Cronk 31OCT15
    Added additional delay in Torque SENT transmission after product trigger from 20us to 170uS. Wierd, product trigger is so long, works..
    Product change to Rensys and AE4.0 causes CAN changes,,, to Little Eindian, in address and in data recieved Ex:
        ccp_SystemState_byt[]        = {0xF4,0x02,0x00,0x00,0x53,0x66,0xBE,0xFE};   // 1      W A S    ---  FE BE 66 53
    change to XCP EA4 Several services affected  ex:    -  xcp_write_get_DTC_rqst1[] = {0x03,0x22,0xFD,0x60,0x00,0x00,0x00,0x00};   W A S    ---03 22 FD 13
        Leonard M. Cronk 03NOV15
    Changed all "can" and "cal" variables from hex strings to floating point.. changed dumperr strings to host to use floating point values, not hex strings.
        Leonard M. Cronk 06NOV15
    Setting DCTs, changing Torque start of set sync after falling edge of trigger, from 205uS to 165uS, to more match the actual sensor.
        Leonard M. Cronk 09NOV15
    Corrected dumperr field 38, added comma to ign off states..
        Leonard M. Cronk 16NOV15
GM T1XX rev01 02_08_02 Project
    Product code stabilized.  Continued changes to EA4... DTC clear,   updating CAN variables, adding, deleting, making cnts to floats.. ect.  General cleanup
    manufacturing_TOC = NO;     // flag indicates we are using manufacturing TOC with Tester Present CAN messages    or    SENT torque simulation
    Do not place product into "warm init" at beginning of "cal", commented out, works now.
    During "cal" command when obtaining  ---    cal_MotCurrQax_xxxx_xxx_fp, cal_HwTqArbn_HwTq_xxxx_xxx_fp ,  Loop 10 times and average for reported value.
    Fixed two "cal" dump string variable types, was still decimal, now all are float as should be.  Fixed cal_HwTq3Meas_HwTq3_fp to store correct value.
    Changed time out for acquiring CAN parametrics from 1500mS to 300mS, problem with Labview app timing out if product is not communicating,, holding up CIB Response
       to RTS and file logs 0's (CIB not responding) which is not the case, the products CAN is not responding to request for data.
    Remarked HET24 pulses for delay loops (encased in ISRs) for debugging, so not to hold off a serial byte on SCI from being serviced.
      New scheme to update HET SENT Ram with new user edge times......  one for Torque and one for Handwheel
    Deleted int sent_update_flag, will use different methods for torque and handwheel updates.
    Added sent_torque_update_flag  --  ACTIVE/REQUEST/IDLE From MAIN ACTIVE while calculating edge time, set to REQUEST to signal IRQ data is ready
       for load HET RAM, RAM only loaded when done during idle time, IRQ set to IDLE when complete.  Now will only load HET RAM when user changed, not every trigger,
       minimize time spent servicing IRQ.  If the SENT update is off by a package, no big deal.
    Added sent_handwheel_update_flag  -- A bit trickier, since we alternate HET RAM loads within HET ISR, we have 3.5mS to update, time between end of address#1 and
        beginning of address#0 to update data, so MAIN will pre processes data and wait until flag goes IDLE (set in HET ISR when its done transmitting last of both sensor's data,
        at end of address#1 completion.  We loop in main waiting for IDLE or time out.  Time out (up to 10mS) ensures we dont infinate loop.
    Added short het_instruction_data[8][17];        // sent_edge_event_time[][] pre processes to match het data register format, so quick write in ISR
    Added fix for RTS code wanting a reply from p_on or p_off or RTS code will not operate normally,  ""MUST have one B_CIB in rack with address of #1"" and "" NO BUFFER Board""
        if((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1')) // if p_on to buffer using 'E" and my address = 1
        {    strcpy(return_message,"p_on command\r");  transmit_str_485(return_message);
        Leonard M. Cronk 19NOV15 - 14DEC15
GM T1XX rev03 02_08_02 Project
    Board personality configuration vars added upfront to change:
       Torque sensors from SENT to Torque Over CAN using manufacturing_TOC switch
       Processor Type from TMS570 to Rensis (Big Endian to Little Endian)
       Analog Input configuration from FULL to BAIRBOARD channel count reduction
    Implimented SWITCHs to handle configuration changes in code, various locations.
    Added CAN2 for compatibility to programs like 9BXX which requires active communications with CAN2.
    Not perfect for "One Switch, many program" code, but much is so.  Segments like "cal" and "parse" and some definitions need to updated by user.
        Leonard M. Cronk 15DEC15 - 11JAN16
    Added Phil Horny's code to eliminate RTS code from logging all 8's in the PC log file, caused by Leonard adding a dummy additonal character to the transmit string so RS485
    transmitter enable pin state change at end of TX buf stuff interrupt timing would allow last "Valid byte" to be transmitted.  We needed a interupt generated when
    the transmit buffer is empty, not stuffed.  There is none.  Phil sets a flag when the last byte is placed in the buffer and sets a flag "tx_to_rx_delay_flag" ,
    so in 1mS RTI ISR we test if((tx_to_rx_delay_flag == 1) && ((scilinREG->FLR & TX_EMPTY) == 0x800)), if so disable the RS458 enable on transmitter chip, done. Simple..
        Fixed up SENT init code to allow update of edge time arrays to complete calculations during init sequence.
         Leonard M. Cronk 27FEB16
GM T1XX rev01 04_03_00 Project
    DEV release, updated variables.
    Added 6 new cal items:
        float cal_MotTq_low_pos_fp;     //  30  Motor Torque Measurement
        float cal_MotTq_med_pos_fp;     //  31  Motor Torque Measurement
        float cal_MotTq_high_pos_fp;    //  32  Motor Torque Measurement

        float cal_MotTq_low_neg_fp;     //  33  Motor Torque Measurement
        float cal_MotTq_med_neg_fp;     //  34  Motor Torque Measurement
        float cal_MotTq_high_neg_fp;    //  35  Motor Torque Measurement
         Leonard M. Cronk 01MAR16
    Change CAN IDs' for XCP messages
        #define XCP_REQUEST_ID        canMESSAGE_BOX8    // 0x712   11bit identifier-- Trans XCP Request from EPS for data  was0x242
        #define XCP_RESPONSE_ID       canMESSAGE_BOX9    // 0x710   11bit identifier-- Rec XCP Response to EPS for data was0x642
        #define CCP_SPEED_ID          canMESSAGE_BOX5    // 0x348   11bit identifier-- Trans Speed and Validity Status to EPS was0x3E9
    Changed XCP DTC positive Response check
        was : if((can1_rx_data[0] == 0x01) && (can1_rx_data[1] == 0x50))  // positive Response from enter Nexteer mode
        now: if((can1_rx_data[1] == 0x50) && (can1_rx_data[2] == 0x7E))  // positive Response from enter Nexteer mode
         Leonard M. Cronk 03MAR16
GM C1XX rev01 05_03_00 Project - 04MAR16
    Porting C1xx to B_CIB using above T1xx B_CIB code as template.  Odd as it is, the C1xx CIB code ""C1XX TOC 05_03_00 Rev5.C was ported (functionality wise)
        to create the T1xx B_CIB code,, circle goes round.
    This version of code will simulate the Handwheel sensor, both Handwheel Angle and Torque.  Handwheel Angle signal is i2C (signals created on Digital I/O 6ch SENT-i2C Board).
        Handwheel Torque signal SENT (B_CIB Sent3 and Sent4).  We use the "manufacturing_TOC = NO" flag in code to run/not run Torque over CAN (TOC).
        Handwheel Angle signal is i2C generated by TIVA processor and transmission on (B_CIB - Sent 1 and Sent2) lines.
    I will leave T1xx 6ch SENT variables and init code intact, but set not to develope edges on unused HET channels,
        making it easier to add additional channels for later code.
    I believe the C1xx uses a Texas Instrument TMS570 processor, so it will be a BIG Endian device.
        Leonard M. Cronk  -  06APR16
    Updated product vars. Transitioned product related variables names to include Product Name ie. can_C1XX... can_T1XX...can_9BXX..(much easier to track.
        Completed transition of uniquely handling of Product Types using switch statements.
         Leonard M. Cronk - 14MAY16
GM C1XX rev02 05_03_00 Project - 20MAR16
    Found that HalCoGen ver 04.05.02 will not run on cold start, but will in debug. Reverting back to HalCoGen 04.03.00 until I can find problem.
         Leonard M. Cronk - 20MAY16
GM C1XX rev03 05_03_00 Project - 06JUL16
    Labview Functional App will not process "ESTEER-CALlimits--C1XX rev02 16MAY16" correctly. Must have "Battery then "Temperature" in that order
        and first and second element for Response to "cal" command.  I gave up fighting with the poor soul, and am changing
        "GM C1XX rev03  validation software design & ref tables 04 06JUL16" and .c code so request for both " dump_err" and "cal", building
        of strings for both trig and cal so Battery and then Temperature is aquired and printed in that order.
         Leonard M. Cronk 06JUL16
        Changed "hcurr" sequence to match ETS.  POSITIVE sequence now stays - all poitive and NEGATIVE sequence now stays all negative.
         Leonard M. Cronk 12JUL16
        Changed dumperr strings to contain 53 parameters (from 46) to match Labview funtional app.
         Leonard M. Cronk 21JUL19
GM C1XX rev04 05_03_00 Project - 28JUL16
        Added B_CIB code to write to HET PROGRAM and CONTROL registers to:
             Change program normal flow, branching around code to look for SENT triggers form product.  On a "p_on" command B_CIB code sets --
              HET_msec_countdown_cnt;       // count down timer for delay of start for HET SENT signal generation,, after i2C has completed initilization
              to 135 or (135mS) and decrementation takes place in RTI ISR next the system_msec_clock. Upon reaching 0, ISR loads new values into HET PROGRAM and
              CONTROL registers which allows the HET to process the SENT triggers normally.
             Delaying of SENT communications allows i2C to complete the sensor initialization and begin its normal 2mS periodic request of HandWheel Angle, where
              the normal request for SENT torque data, is requested in the dead space between the i2C 2mSec request.
             When porting C1xx code and adding "Phil's Fix" (RS485 enable - RTS all 8's), forgot to edit sci.c, causing strlen(return_message) + 1, bad. Fixed and OK now.
              Leonard M. Cronk 28JUL16
             Changed product bin so that  "offset for setting the N step count for NTC 0x066 or 0x067 fault" is 1 not 4, so we can miss 40 or so SENT triggers with out setting DTC.
             TIVA - Digital I/O SENT 6CH-i2C code now produces 10 tooth angle of 183deg, and 11 tooth angle of 134deg, to eliminate i2C DTC 0x6C 0x06 and DTC 0x6D  0x10,
               having to do with Verner something.
                Leonard M. Cronk 29JUL16
             Updated torque values at "p_on" to reflect 10/7/15 C1XX version of code... to 0.5nm.
              Leonard M. Cronk 01AUG16
             Updated "p_on" command so Delay of SENT after "p_on" is only performed if current State is not "p_on".  This allows lab to ask for polarity changes in motor
              by using multiple "p_on"s with out interseding "p_off" commands.  Prior, multipe "p_on"s would insert the SENT Trigger Delay Sequence, into already running
              sensor simulation and the controller would set DTC 66 and 67.
               Leonard M. Cronk 05AUG16

FCA ADAS rev01 xx_xx_xx - 22SEP16
    Porting LWR CIB code to B_CIB FCA ADAS, using above GM C1XX rev04 05_03_00 B_CIB code as template.  Code has potential to run T1XX, C1XX, 9BXX(placeholders, not
        all coding is complete) both TOC and Digital; and FCA ADAS(two controller product).
        Program must ensure " >>> 5 variables or defines must be set <<<" during code initialization so proper code execution is achieved:
            Target Product Type, Processor Type, TOC or Digital, CAN data request count, CIB configuration.

         Set for number CAN variable request   T1XX = 28   C1XX = 18    B9XX = 36    FCA = 9  (FCA is 9 request for CAN1 and 9 request for CAN2)
1)          #define FCA_ADAS_CAN_DATA_REQUESTS 9 // Used for can1_request_index != can_index_value (previously just a #). Created for easier updating of code

         set target EPS product to test
2)          int target_product = TARGET_FCA_ADAS;
         board personality configuration vars
3)          int manufacturing_TOC = NO;     // flag indicates we are using manufacturing TOC with Tester Present CAN messages    or    SENT torque simulation
4)          int processor_type = TMS570;    // flag indicates if Product is using BIG Endian(TMS570 processor) or LITTLE Endian(RENSIS processor) used to evaluate (parse) CAN data
5)          int CIB_analog_config = BAIRBOARD;  // flag indicates analog configuration, BAIRBOARD or FULL.  BAIRBOARD has reduced channel count, process a little differently.

        Note: even though an ADAS product(essentially two controllers, controlled by one B_CIB) is tested, many B_CIB features are implemented
            serially (get vars CAN1 then CAN2) so timer and DCT flags are not duplicated, though some varibles and flags are individualistic
            to discriminate between CAN1 and CAN2 and noted in title. (Ex: DTC_XCP_rply_indx, can2_request_index, can1_dump_err_data, can2_dump_err_data
            parse_can1_data(), ect..)
             Leonard M. Cronk 28SEP16

        Created - hcurr_change_direction_at_nm(float target);   // function to swap T1/T2 direction at assigned torque (0.0, 0.1, 0.5, 1.0, 2.0, 4.0, 6.0) are valid values
        Added - speed table to assist building CAN speed, rolling counter and CRC bytes...  Plan to develop code to perform on any speed desired - later.
        Added CAN variables for functionals and dumps using canx_FCA_xxxxx or calx_FCA_xxxxx, renamed C1XX, T1XX, 9BXX items to conform to new nomenclature.
        To allow multiple product #define message box defs to remain in program concurrently, used same nomenclature mentioned above.
            Leonard M. Cronk 28OC16
        Changed sent_torque_update_flag to sent_torque_ChA_update_flag and sent_torque_ChB_update_flag for ADAS torque sensor control allowing independent triggers.
            Leonard M. Cronk 03NOV16, 09NOV16
        Changed to -> if((can1_rx_data[1] == 0x50) && (can1_rx_data[2] == 0x7E))  // positive Response from enter Nexteer mode for FCA
        Added switch for code which delays Response to SENT trigger so HandWheel i2C can initiate. Primarily because FCA DEV software has no
        "k_HWTrqDiag_Cnt_str" to set for missing 135mS of SENT triggers. Other i2C sensor programs will also use this feature.
            Leonard M. Cronk 11NOV16

FCA ADAS rev01 01_04_00 - 14NOV16
        Updated CAN variable addresses.  Also note, product software does not have handwheel sensor for angle turned on yet.
            Leonard M. Cronk 14NOV16

FCA ADAS rev01 01_04_00 - 15NOV16
        Updated CAN variable addresses. Changed SENT tick time to 1200nSec from 500nSec.  Handwheel sensors for angle still not turned on yet.
            Leonard M. Cronk 15NOV16

Ford CD391-V2 ADAS rev01 xx_xx_xx - 20NOV16
        Adding Ford CD391 to base program FCA ADAS.  Using Ford FOAA as template for this Ford Program, except no MSB this is a power pack.
        Code has potential to run T1XX, C1XX, 9BXX(placeholders, not all coding is complete) both TOC and Digital; FCA ADAS and
        Ford CD391 ADAS (two controller products).

        Set for number CAN variable request   T1XX = 28   C1XX = 18    B9XX = 36    FCA = 9  (FCA is 9 request for CAN1 and 9 request for CAN2)
                    CD391 = 9  (CD391 is 9 request for CAN1 and 9 request for CAN2)
1)          #define CD391_ADAS_CAN_DATA_REQUESTS 9 // Used for can1_request_index != can_index_value (previously just a #). Created for easier updating of code

         set target EPS product to test
2)          int target_product = TARGET_CD391_ADAS;
         board personality configuration vars
3)          int manufacturing_TOC = NO;     // flag indicates we are using manufacturing TOC with Tester Present CAN messages    or    SENT torque simulation
4)          int processor_type = TMS570;    // flag indicates if Product is using BIG Endian(TMS570 processor) or LITTLE Endian(RENSIS processor) used to evaluate (parse) CAN data
5)          int CIB_analog_config = BAIRBOARD;  // flag indicates analog configuration, BAIRBOARD or FULL.  BAIRBOARD has reduced channel count, process a little differently.

        Completed adding TARGET_CD391_ADAS code
            Leonard M. Cronk 27NOV16

Ford CD391-V2 ADAS rev01 03_02_02 - 29NOV16
        SENT tick time is 500uS not 1200uS.  Updated new variable addresses. Added 3.0nm torque command and updated related code - MAIN program loop, eval_command_string(void),
        hcurr_change_direction_at_nm(float target), added #define pos_3p00nm 9, added #define neg_3p00nm 10. Added const short sent_data_array_pos_3p00n[8][5] and
        const short sent_data_array_neg_3p00nm[8][5].
            Leonard M. Cronk 30NOV16
        Added variable Rte_ElePwr_SupplyCurrent_Amp_f32 = canX_FORD_Batt_Current_fp for functionals.  Measure at low, med and high currents.
            Leonard M. Cronk 04DEC16

Ford CD391-V2 ADAS rev01 03_02_02 - 18JAN17
        Updated dump strings 14, 15, 34, 35 to contain new variables.
        This required defining new CAN messages, interrupts, data parsing for ECUA & ECUB
        Phil Horny

Ford CD391-V2 ADAS rev03 03_02_02 - 25JAN17
        Updated dump string vars 13, 14, 15, 16, 17, 33, 34, 35, 36, 37, 38 to contain new variables, mainly for 0x2B fault debugging.
        This required defining new CAN messages, interrupts, data parsing for ECUA & ECUB
        Current "SENT delay at p_on" is set for 10ms.
            - Previously 180ms to delay SENT until after I2C has kicked off
            - 180ms might be causing an issue on test.
            - I2C faults currently un-avoidable, so will induce those faults rather than torque faults.
        Phil Horny

MicroCore1 rev01 - 06JAN17
        Porting "Ford CD391-V2 ADAS rev01 03_02_02" to TMS570LS3137PGE MicroCore1 design.
            Leonard M. Cronk 06JAN17

* Assigned MicroCore1 features:
*
*   NHET1[0]    A HW - SENT1-OUT or PWM
    NHET1[1]    B HW - SENT2-OUT or PWM
    NHET1[2]    A HW - SENT1-IN  or I2C
    NHET1[3]    B HW - SENT2-IN  or I2C
    NHET1[4]    A T1 - SENT3-OUT or DIGITOUT1
    NHET1[5]    A T2 - SENT4-OUT or DIGITOUT2
    NHET1[6]
    NHET1[7]    A T1 - SENT3-IN or DIGITOUT3
    NHET1[8]    A T2 - SENT4-IN or DIGITOUT4
    NHET1[9]    B T1 - SENT5-OUT or DIGITIN1
    NHET1[10]   B T2 - SENT6-OUT or DIGITIN2
    NHET1[11]   B T1 - SENT5-IN or DIGITIN3
    NHET1[12]   B T2 - SENT6-IN or DIGITIN4
    NHET1[13]
    NHET1[14]   User LED1 / Ign1 /Trig / (was RXD LED) and Compatabilty Board I/O
    NHET1[15]   User LED2 / Ign2 / Trig / (was TXD LED) and Compatabilty Board I/O
    NHET1[16]   RS485TX-ENA
    NHET1[17]
    NHET1[18]   User LED3 / Trig / RUN LED and Compatabilty Board I/O
    NHET1[19]   User LED4 / Trig / RUN LED and Compatabilty Board I/O
    NHET1[20]   Itrigger/Relay (compatabilty board)
    NHET1[21]
    NHET1[22]   LAN CP2
    NHET1[23]   LAN CP3
    NHET1[24]   General Digital I/O / Machine Interlock
    NHET1[25]
    NHET1[26]   General Digital I/O / B-Box Backlight
    NHET1[27]
    NHET1[28]   FRAYERR1
    NHET1[28]
    NHET1[30]   FRAYERR2
    NHET1[31]   SW-IGN3


    AD1IN[0]    ADC1 Group1 MSB - Sin/TouchX
    AD1IN[1]    ADC1 Group1 MSB - Cos/TouchY
    AD1IN[2]    ADC1 Group1 MSB - InvSin
    AD1IN[3]    ADC1 Group1 MSB - InvCos
    AD1IN[4]    ADC1 Group1 TC -  Sin
    AD1IN[5]    ADC1 Group1 TC -  Cos
    AD1IN[6]    ADC1 Group1 T1
    AD1IN[7]    ADC1 Group1 T2
    AD1IN[8]    ADC1 Group1 Prod 3.3v
    AD1IN[9]    ADC1 Group1 Prod 5v
    AD1IN[10]   ADC1 Group1 Ignition
    AD1IN[11]   ADC1 Group1 2.5v Ref
    AD1IN[12]   ADC1 Group1 Reserved for Current Measurement - Large
    AD1IN[13]   ADC1 Group1 Reserved for Current Measurement - Small
    AD1IN[14]   ADC1 Group1 Speed In

    AD2IN[0]    ADC2 Group1 Module TCPIPID2
    AD2IN[1]    ADC2 Group1 Module SENSEID3
    AD2IN[2]    ADC2 Group1 Module SENSEID4
    AD2IN[3]    ADC2 Group1 Module FRAYID5
    AD2IN[4]    ADC2 Group1 Board ID HEX SW-1
    AD2IN[5]    ADC2 Group1 Board ID HEX SW-2
    AD2IN[6]    ADC2 Group1 Board ID HEX SW-3
    AD2IN[7]    ADC2 Group1 Board ID HEX SW-4
    AD2IN[15]   ADC2 Group1 Module DIGITALID1


    GIOA[0]
    GIOA[1]
    GIOA[2]     User SW-1 (YELLOW B_CIB)
    GIOA[3]
    GIOA[4]
    GIOA[5]     LAN CP1 - req int
    GIOA[6]     INT-A net or General Purpose I/O
    GIOA[7]     INT-B net or General Purpose I/O

    ECLK        USER_BUTTON1 (MicroCore)

    sciREG->RD      Debug interface on Bulgarian Board (COM1 9600baud)
    sciREG->TD      Debug interface on Bulgarian Board (COM1 9600baud)
    scilinREG->RD   RS485 or LAN (COM2 19200baud)
    scilinREG->TD   RS485 or LAN (COM2 19200baud)

    MIBSPI1CLK      CLK for D/A converter / LCD
    #MIBSPI1CS[0]   ChipSelect for D/A converter
    #MIBSPI1CS[1]   ChipSelect for LCD
    #MIBSPI1ENA
    MIBSPI1SIMO     SlaveIn/MasterOut for D/A converter / LCD
    MIBSPI1SOMI

    MIBSPI3CLK      CLK for CAN FD / SD CARD
    #MIBSPI3CS[0]   ChipSelect for SD CARD
    #MIBSPI3CS[1]   ChipSelect for CAN FD
    #MIBSPI3ENA
    MIBSPI3SIMO     SlaveIn/MasterOut for CAN FD / SD CARD
    MIBSPI3SOMI     SlaveOut/MasterIn for CAN FD / SD CARD

    MIBSPI5CLK      GIO, Input, Touch LEFT [3]
    #MIBSPI5CS[0]   GIO, S-WireEEPROM
    #MIBSPI5CS[1]
    #MIBSPI5ENA     GIO, Output, Touch TOP [0]
    MIBSPI5SIMO[0]  GIO, Output, Open Drain, Touch  BOTTOM [2]
    MIBSPI5SOMI[0]  GIO, Input, Touch RIGHT [1]


    FRAYRX1
    FRAYTX1
    FRAYTXEN1
    FRAYRX2
    FRAYTX2
    FRAYTXEN2

    CAN1-L
    CAN1-H
    CAN2-L
    CAN2-H
    CAN3-L
    CAN3-H

    I2C_SCL
    I2C_SDA

*
*
*   Porting of HalCoGen and TMS570LS31 code complete,, now for a compile
        Leonard M. Cronk 12JAN17
    Many issues with HalCoGen creation of code (LS20 to LS31), naming conventions and data structure differences
    >   SCI - sciREG1=sciREG
    >   SCI - scilinREG=scilinREG
    >   SCI - sciTransfer.lenght=.txlenght and .rxlenght
    ECT...
        Leonard M. Cronk 12JAN17 - 24JAN17

GM G2KCA ADAS rev01 xx_xx_xx - 25JAN17
    Using MicroCore1 rev01 as base code for GM G2KCA ADAS rev01 xx_xx_xx.  G2KCA Track3 is an T1XX RENSIS
    dual processor product.  G2KCA Track 3 is also a EA4 device.
        Leonard M. Cronk 26JAN17
    Reorganized message box #defines to more match GM ADAS CAN buss1 and buss2 configurations.  #defines notes ECU,Buss,Message.
    Added commands "p1_on" and "p2_on" for ADAS products to turn on each ignition independently.
        NHET1[14]   User LED1 will now be used to turn on Ign1 on Compatibility Board after NHET1[31]   SW-IGN3 is turned on first
        NHET1[15]   User LED2 will now be used to turn on Ign2 on Compatibility Board after NHET1[31]   SW-IGN3 is turned on first
        The standard "p_on" command will turn on all three HETs.
        RXD and TXD action on leds will no longer take place.

    Changed G2KCA variable names to indicate which ECU data is obtained ECU1 or ECU2, vs. CAN1 or CAN2, because most both ECU's data is obtained
    from communications on CAN1 buss.
        Leonard M. Cronk 10FEB17

    Increased dtc[15][5] to dtc[21][5]  for additional CAN reads from get DTCs.  From 14 to 20 DTCs
    Changed get_DTCs1() and get_DTCs2()  case TARGET_G2KCA_ADAS  to encompass 20 DTCs for EA4 products.
    Changed canMessageNotification() or both CAN IDs of TARGET_G2KCA_ADAS DTC action to input additional writes from product for 20 DTCs.
        Leonard M. Cronk 15FEB17

GM G2KCA Track 3 rev01 02_01_00 - 02MAR17
    Swapped p1_on and p2_on control to match the test harnesses.  Added switch for product type(G2KCA) in "p1_on" and "p2_on" in command switch.
    Added re-send of get_DTCs1() & get_DTCs2() in cal of G2KCA switch -- if dtc[0][0] == 0xFF (no response from ECU)
        P. Horny 02MAR17

    In main() prior to while(1), Call canEnableErrorNotification(canREG1) and canEnableErrorNotification(canREG2) to auto recover for CAN faults.
    canErrorNotification() in notification.c will set busX_warn_state and busX_off_state = 1, to be read and then cleared in dumperr.
        Leonard M. Cronk 12MAR17

GM G2KCA Track 3 rev02 02_01_00 - 19MAY17 - 05JUN17
    Added latest G2KCA TOC implementation with EA4 CAN Service 0xFD40 Manual Motor Torque Command provided by Phil Horny.
        Changed XCP DCT code to separate ECU1 and ECU2 calls and processing in both main() and notification().
            int ECU1_XCP_reply_index; // used for XCP response for ECU1
            int ECU1_clear_DTCs_flag; // flag used in can interrupt routine to indicate clear or get DTC's on ECU1
            int ECU1_dtc_loop_cnt;
            int ECU1_dtc_inner_loop_cnt;

            int ECU2_XCP_reply_index; // used for XCP response for ECU2
            int ECU2_clear_DTCs_flag; // flag used in can interrupt routine to indicate clear or get DTC's on ECU1
            int ECU2_dtc_loop_cnt;
            int ECU2_dtc_inner_loop_cnt;
        and
            unsigned char dtc1[21][5]; // ECU1 array for storing 14 to 20 DTC's with 5 bytes dtc#(2 bytes),param,status,ignition counter
            unsigned char dtc2[21][5]; // ECU2 array for storing 14 to 20 DTC's with 5 bytes dtc#(2 bytes),param,status,ignition counter
        Leonard M. Cronk 05JUN17

GM G2KCA ADAS Track3 rev03 02_01_00
    Adding EA3 - PSA code, defined as TARGET_PSA_CMP. It will have both TOC (CAN Service 0xFD40) and SENT torque control.
    PSA Unique motor torque polarity switching every second during normal operation will be handled in RTI notification code.
        Within the hcurr p_on load profile section, a case for PSA_CMP will have an empty shell for hcurr code, but will also
        check for a special "stop_T1T2switching".  If flag == FALSE, then set the new torque direction, leave the "torque_vlaue_case_index"
        alone and set the "hcurr_write_interval_data flag" so upon returning to main, new torque will be updated.
     Leonard M. Cronk 07JUN17

GM G2KCA ADAS Track3 rev04 02_01_00
    Added PSA target updates.  Changed SENT HET code to reflect TMS570LS31  -- .h and .c files.
        Mainly working on TOC control.
    Leonard M. Cronk 20JUN17

PSA CMP rev02 03_00_02
    Created new project. Added PSA variable for 03_00_02 product code. Updated HalCoGen to match latest MicroCore configuration.
    Leonard M. Cronk 31JUL17

PSA CMP rev01 04_02_00
    Created new project. Added PSA variable for 04_02_00 product code.
    Leonard M. Cronk 02AUG17
    Found missing variables and updated addresses for 04_02_00.
        This version is TOC.
    Leonard M. Cronk 16AUG17
    Added "strcat(return_message,temp_return_message);" to trig for PSA,, missing a couple of elements.
        Couple of thing corrected after porting I missed in the Functional code.
    Leonard M. Cronk 24AUG17
    Changed trig() timeout for PSA_CMP_CAN_DATA_REQUESTS from 300mS to 500mS. Changed get_DTCs1() timeout for ECU1_XCP_reply_index
        from 500mS to 700mS.  Note, also extended timeout in Functionals.
    Leonard M. Cronk 08SEP17

GM SGMW CN200 MCIP EA4M rev01
    Created new project based on latest base code "PSA CMP rev01 04_02_00"
        Added "#define TARGET_SGMW_CN200 10" and all associated switches for typical base program.

    int target_product = TARGET_SGMW_CN200;

    // board personality configuration vars
        int manufacturing_TOC = YES;    // flag indicates we are using manufacturing TOC with Tester Present CAN messages    or    SENT torque simulation
        int processor_type = TMS570;    // flag indicates if Product is using BIG Endian(TMS570 processor) or LITTLE Endian(RENSIS processor) used to evaluate (parse) CAN data
        int CIB_analog_config = BAIRBOARD;  // flag indicates analog configuration, BAIRBOARD or FULL.  BAIRBOARD has reduced channel count, process a little differently.
    Leonard M. Cronk 11SEP17 - 17SEP17

    Phil indicated that CN200 MCIP EA4 will be TOC.
        Adding program structure to accommodate TOC using manufacturing service $FD40.
    Leonard M. Cronk 17SEP17

    Added int temp_analog_config_status;  to store current "CIB_analog_config" status "FULL or BAIRBOARD" and then during "cal_stepX" force all analog channels to be process
        regardless of the users "CIB_analog_config".  The users "CIB_analog_config" is restored after "cal_stepX" is completed.
        If B_CIB is not equipped with a fully populated Analog Sensor Board it will fail it calibration.
    Leonard M. Cronk 20SEP17

    Added tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on.
        To functions get_DTCs1() and get_DTCs2().
    Leonard M. Cronk 22SEP17

GM SGMW CN200 MCIP EA4M rev02
    Changed vehicle speed CAN IDs
            #define CN200_ECU1_CAN1_CCP_SPEED_ID        canMESSAGE_BOX5  // 0x3E9   11bit identifier-- Trans Speed to EPS

    Changed XCP CAN IDs 0x750 and 0x758:
            #define CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID  canMESSAGE_BOX10 // 0x750   11bit identifier-- Trans XCP Request from EPS for data
            #define CN200_ECU1_CAN1_XCP_EA4_RESPONSE_ID canMESSAGE_BOX11 // 0x758   11bit identifier-- Rec XCP Response to EPS for data

    Added CAN periodic 0x17D - Average Vehicle speed message, 100ms, data = 0x00 00 00 00 00 00 00 00:
            #define CN200_ECU1_CAN1_CCP_EA4_AvgVehSpd_ID        canMESSAGE_BOX14 // 0x17D   11bit identifier-- Trans Average Vehicle Speed message to EPS
            Sending this message at same time as Power Mode message ($1F1) - 100ms
    Changed variables can1_P1_Volt, can1_P2_Volt, and Spare1 variables. See spreadsheet for details.
    Phil Horny

    Corrected parse_can1 ccp_CN200_MtrCurrQax_str_1,2,3 and ccp_CN200_HwTrq_HwNm_str_1,2,3 data[] locations.
    Also noticed that Base Code -TARGET_CD391_ADAS had similar issue with data[] locations, corrected.
    Also corrected Base Code -// C A N  1  --  F O R D   A D A S   Products and // C A N  2  --  F O R D   A D A S   Products,
        #define FORD_CCP_SPEED_ID         canMESSAGE_BOX5    // 0x415 to // 0x12A address.
    Leonard M. Cronk 06OCT17

    Added function:    void set_torque_TOC_or_SENT_or_Analog();    // added function for code consolidation and Analog feature
    The check to change torque in Main Loop remains, and will still use ucurr and hcurr flags in main (thou ucurr use will be diminished),
    but hcurr flag set in ISR use is still valid because we don't want to have the inherent wait for timers hold up the execution of ISR.
    New function will be called from Main Loop as well as from commands such as "0p50nm" or "2p00nm" and "cal".
    Function will determine if Target is TOC or SENT/Analog based on if "int manufacturing_TOC = NO;" or YES.
    Leonard M. Cronk 11OCT17

Ford T3-T6 rev01 xx_xx_xx
    Created new project based on latest MircoCore base code "GM SGMW CN200 MCIP EA4M rev02".
    Updated HalCoGen to match "Ford CD391-V2 ADAS rev 03_02_02" CAN messages and latest MicroCore configuration.
    Product is EA4, 1 CAN, 2 ECUs, 5ch SENT - 1 HW position and 4 Torque channels (T1XX style).

    Added TARGET_PSA_CMP to notification() if (HET_msec_countdown_cnt == 0) so reenable normal SENT signals after delay. (missing)
    Leonard M. Cronk 13OCT17 - 19OCt17

    Issues regarding SENT trigger logic low voltage,,
    New software, "ECU1 PortDriveStrengthChange and RenesasPortHotFix output"
    Update variable addresses.
    Leonard m. Cronk 30OCT17

    Input GM G2KCA ADAS Track3 rev01 and rev 02 updates and T1XX vars and ID 0x182 message:
         Added counters and checksums to Speed messages. Operation performed in RTI notification at 37mSec intervals.
        Base speed for both wheels and both ECUs is 0kph.
            int G2KCA_ADAS_crcVal_16;                   // G2KCA speed message calculation
            uint8 G2KCA_ADAS_Write_Vehicle_speed[8] = {0};      // G2KCA speed message calculation/
            unsigned char G2KCA_ADAS_CRC_counter;       // G2KCA speed message calculation
        Updated addresses for variables.
        Updated GM T1XX vars to rev01 07_02_02 10APR17 PV release. Added if(100ms) CAN2 CE Buss ID 0x182 message, was there for 9BXX only, at 53mS.
        Leonard M. Cronk 02AUG17

        ECU1 and ECU2 CAN ID's changed for PV G2KCA SW (3.0X.XX+)
        p1_on = hetbit 15 and p2_on = hetbits 14
        Phillip Horny 07AUG17
    Leonard M. Cronk 01NOV17

    Resolved SENT trigger issues.  Change Digital Isolator chips from NVE to Silicon Labs and changed Digital I/O SENT 6CH - ADAS Board's
        SENT buss pull ups from 2.2K to 5.1K ohms to allow a better logic low voltage from Product trigger at CIB.
    Updated variable addresses. (ecu1trigger.elf)
    Leonard M. Cronk 15NOV17

    Updated variable list for ECU2
    Leonard M. Cronk 16NOV17

    Fixed cut and paste error in cal - ECU1 system state dump string
    Leonard M. Cronk 17NOV17

    Added Targets: TARGET_GM_B_T1XX 12 and TARGET_RENAULT_NISSAN 13
        uses analog for HW signals and SENT for position signal.
    Leonard M. Cronk 16FEB18

  **  rev02 is Phils updates for running test, rev03 starting to combine small changes, and Dons base code for Renault.

 Ford T3-T6 rev02 xx_xx_xx
 Ford T3-T6 rev03 xx_xx_xx
 Ford T3-T6 rev04 xx_xx_xx
    Incorporating Phils rev02 and Dons Renault changes.
    Incorporating Phils latest CN200EA4 changes.
    Incorporating Phils BMW FAR WE for first FlexRay application.
    Leonard M. Cronk 09MAR18 - 16MAR18

    Updated T3-T6 address for ECU2 Rte_EcuTMeas_EcuTFild_Val
    Added 6 new torque steps and case statements in sent_...
    case:   15 = +1.5nm
            16 = -1.5nm
            17 = +2.5nm
            18 = -2.5nm
            19 = +3.5nm
            20 = -3.5nm
    Added 3 new commands:
        1p50nm
        2p50nm
        3p50nm
    Phil forgot to add all new torque values through out all code...So

    New philosophy, use torque define constants instead of numbers in assignments and switches.
    Filled out TOC CAN message constants to match all available torque commands for both types of Manufacturing Services
    Added to, and ReBined Ford High, Med and Low Current/Torque captures in main loop
    Reorganized eval_command() switch to match new command set
    Changed all torque_value_case_indexes #'s to new "define" values: in notification and main
    Added analog torque values in if(manufacturing_TOC == YES) else so NO (use SENT ), which also sets analog T1 T2
 
    Updated base code to resemble Phils SGMW CN200 MCIP EA4M rev04 24JAN18
     Update Variable addresses for EA4M_00.01.11.elf update to product software.
     Changed cal command for CN200 to output 0.5NM, 1NM, 2NM. These current values matched what we want for current output limits.
       This prevents us from having to reflash the CN200 parts and update base assist table.
    Keeping periodics alive for X seconds after p_off command.  P. Horny
    Leonard M. Cronk 16MAR18

    Fixed issue in trig() when "No CAN" or "ign=off" where dump string fields should be set to "1's" or "0's".  Field labels
    became out of sync.  Primarily with dual micro products.

    Fixed issue in RENSIS FORD products where code stores low-mid-high MtrCurrQax and HwTrq_HwNm vars when commanded for a following dumperr.
      Problem was that parse() would always swap and move all 3 whether valid terms existed.  Added 3 flags, "FORD_hcurr_xxx_value_is_set"
      to signal parser to parse only if set to TRUE.  If flag is FALSE, init value of -100 is not overwritten in MtrCurrQax and HwTrq_HwNm vars.
    Leonard M. Cronk 22MAR18

  Renault rev01 01_00_02
    Created new project based on latest MircoCore base code "Ford T3-T6 rev04 xx_xx_xx".
        Updated HalCoGen to match "Renault Nissan EA4M rev02" CAN messages and latest MicroCore configuration.
        Product is EA4, 1 CAN, 1ch SENT (1000nS tick time)- 1 HW position (3 nibble, no address info), and 2 analog channels.
        For now, HW SENT will have to be wired to SENT5 (T1 of a ADAS product) and receive Torque package (3nibble) to simulate HW angles to remove NTC
        related to bad HW sent data if wired to normal HW Sent1.  HW angle will depend on applied torque value. Max torque range is at +/-6nm so data
        of 0xCCC and 0x333 which translates to 288deg and 72deg with 0nm 0x7FF = 180deg.
    Leonard M. Cronk 04APR18

  Ford T3 rev01 Phase2H
    Created new project based on latest MircoCore base code "Renault rev01 01_00_02".
        Since "Ford T3-T6 rev04 xx_xx_xx" code was ready to go. Built new HalCoGen "Ford T3 rev01 Phase2H" project and changed dumpver string.
        This release, because of timing will use TARGET_FORD_T3_T6. Next release of base will completely break out TARGET_FORD_T3_T6 into separate targets.
    Leonard M. Cronk 04APR18

  Ford T6 rev01 xx_xx_xx
    Created new project based on latest MircoCore base code "Ford T3 rev01 Phase2H".
        Built new HalCoGen "Ford T6 rev01 xx_xx_xx" project and changed dumpver string.
        This release, because of timing will use TARGET_FORD_T3_T6. Next release of base will completely break out TARGET_FORD_T3_T6 into separate targets.

        Updated variable address..  using the T3-T6 nomenclature.  Guess what, today they are the
            same(T6_Folded_ECU1_FaultsDisabled_Merged.elf and T6_Folded_ECU2_FaultsDisabled_Merged.elf).
    Leonard M. Cronk 04APR18

  BMW FAAR WE rev01 01_00_07
    Created new project based on latest MircoCore base code "Ford T6 rev01 xx_xx_xx".
        Built new HalCoGen "Ford T6 rev01 xx_xx_xx" project and changed dumpver string.
        Added #define TARGET_BMW_F_WE 16 and #define TARGET_BMW_UKL 17.

        Ported Phils, Dons and Keegans "BMW_FAAR_WE_ls31_FR_DAQ_mode_rev01_prod_01_00_07" code into base.
            BMW UKL rev01 xx_xx_xx
                Created void ShiftFRAY(void)
                p_on, p_on_warm, p_off updated with TARGET_BMW_UKL. Code ported from LS20.
                    - not verified
                clear_dtcs updated with BMW_UKL
                    - not verified
                cal started to update with BMW_UKL
                    - Added case, copied from LS20. Update ShiftCAN to ShiftFRAY. Update parse_can_data to parse_can1_data (no cases added)
                    - Moving all strcpy(xxx) to fp variables. Need to update parse_can1_data with this. Need to update CAL Limits file.
                    - Changed DTC_XCP_rply_indx to ECU1_XCP_rply_indx
                    - Changed Engine_on_signal to ign1_status.
                    - Ignition hetport changed from 30 to 31
                There might have been one more change required to get this thang to work...someday hope this jogs my memory.
            BMW_UKL_ls31_FR_DAQ_mode_dev_rev01
                Adding XCP DAQ mode for flexray.

                For programmable DAQ mode from labview input, need these inputs:
                # of DAQ messages / lists
                Message Type
                    - need to use this for building DAQ table, so will use some sort of for/if loop combo
                Message Address

                build a struct with variable name, address, big endian/little endian, and variable type
                use variable type to build DAQ mode, parsing data, and sprintf data.

                ENDED Development with some addition of FAAR WE stuff. Will continue development using FAAR_WE_ls31_FR_DAQ_mode_dev_rev01_prod_01_00_07.
            FAAR_WE_ls31_FR_DAQ_mode_rev01_prod_01_00_07
                8Feb17
                Adding case statements for FAAR_WE
                Adding some fray message definitions, copied from BMW UKL
                Goal: Set up all "periodics" and a system state variable read.
            Phils, Dons and Keegans code remarks.

        MAY THE 4th THINGS TO VERIFY:   MTS_Stand_BMW_FAAR_WE_ls31_FR_DAQ_mode_rev05_prod_02_01_00
            1) All comms with Jeremy work as expected
                Startup...dumpver, set_config
                enable_data_stream and properly formatted data happening at all intervals (p_on state, p_off state)
                disable_data_stream and properly formatted data happening at all intervals (p_on state, p_off state)
                Jeremy to build buttons and logging engine with this in mind
            2) Flexray DAQ vs CAN retransmit vs TCPIP return string data
                A) Also confirm CAN retransmit uses correct CAN IDs based on hex switch setting
            3) MTS inputs to CIB being stored properly
                A) Vehicle speed input being converted to flexray properly
                B) System state input being used in main to command p_off or p_on properly
                C) Start store of DAQ data input being read properly and stuffed into mts_data string properly
                D) Angle command input being stored and stuffed into mts_data string properly
                E) Torque command input being converted to motor torque manufact service properly, then kicking off motor torque service on each receipt.
                        (Is the service fast enough to keep up with MTS tx? Find out max rate for MFG services)
                    Add flags to have in mts_data in case torque service command failed.
                    Store torque command input into mts_data string properly
                F) Verify each CIB is using correctly addressed input
                G) Do the DAQ retransmit on CAN rates NEED to equal the MTS torque command input rates? Talk to Sawatzki and Keegan.


    Changed RS-485_Comm.c to enhance WEB mode to transmit Size, Header, Data - packet (new requirement).  Also changes in Notification.c, in WEB mode to continue with the
        Data portion of the packet after Size and Header transmission is completed, by using the new "WEB_header_TX_complete" flag.  This also transmission of large
        data packs without strcat to return_message string. Header is created using what is left in words[0] appending a "\r", if a header is push via program and
        not received as a command, strcpy or set words[0] to the header title by hand in MicroCore code, then call transmit_str_485(char * return_message) as before.
    Changed     case WEB:  scilinREG->BRS = 10U;   //460800 baud for scilinREG or port2
    Fixed error in set_torque_TOC_or_SENT_or_Analog(), analog stuf to DtoA_array in switch(torque_value_case_index).
        memcpy(&DtoA_array[6], "\x00\x06\x00\x7F\x00\xFF", 6);  now writes to array correctly.
    Fixed bad data in case pos_1p50nm: case neg_1p50nm: cause NTC torque correlation fault.
    Added to and cleaned up const char commands[][20] and "help".
    Updated several code sections based on Phil's rev 07 code.
    Leonard M. Cronk 09APR18 - 30MAY18

  BMW FAAR WE rev01 02_01_00
    Created new project based on latest MircoCore base code "BMW FAAR WE rev01 01_00_07".
    Flushed out additional .c and .h based on Phil's rev 07 code.
    Created new HalCoGen project combining Ford T3 and Phil's BMW_UKL_ls31_port_rev01_xx_xx_xx.hcg and generated code.
    Added cases for TOC in set_torque_TOC_or_SENT_or_Analog() for EA3 TARGET_BMW_UKL and EA4 TARGET_BMW_FAAR_WE.
    Updated both UKL and FAAR WE variable names, count and addresses.
    Built both ULK and FAAR WE trig() and cal routines.
    Added Soft Start feature for BMW.  Any standard torque request greater then T1/T2 of 2.7v/2.3v will Soft Start at 2.7v/2.3v (1mN) for 500ms
         then proceed to requested torque.  Change found addition BMW switch in set_torque_TOC_or_SENT_or_Analog() function.  Soft Start
         feature will not change directions of rotor.  Feature is applied to both positive and negative requests.
    Leonard M. Cronk 31MAY18 - 15JUN18

  BMW FAAR WE rev01 03_01_00
    Created new CCS and HalCoGen projects. Running first compiles. Success.
    Needed to update Flexray Start Node Processor with latest code to create correct FlexRay addresses.
    Updated Parse() for FAAR_WE (not to swap Eindianess).
    Updated cal Low, Med, High values to 0.5nm, 1.50nm and 2.0nm.
    Changed Soft Start to 2.6v/2.4v (0.5mN) for 500ms, Soft Starts will occur at +/- 1.0nm.
    Leonard M. Cronk 16JUN18 - 20JUN18

  BYD SA2FL rev01 06_21_18
    Created SA2FL software based off SA2FL code (branch from SA2FL).  Was variable name changes and CAN variable address changes only.
    Realize now software name was wrong (based on date and not code version).
    G.Wood 21JUL18

BYD SA2FL rev01 01_02_06
    Fixed issue with parsing out can data.  Fixed issue with the functional data output not being created in the correct order.
    G.Wood 15NOV18

BYD SA2FL rev04 01_02_06
    Disabled CCP_Engine_Run (in notification.c) from transmitting for SA2FL (for both p_on and p_off states).
    G.Wood 27NOV18

BYD SA2FL rev05 01_02_06
    Adding Rte_EcuTMeas_EcuTFild_Val to variable list per request from Phil.
    Fixed wrong index where can data is copied to variables.  Appears to have no effect on data either way.
    G.Wood 06DEC18

BYD SA2FL rev01 02_01_05
    Updated variable addresses.  Added repeating zero speed message and vehicle not ready message to off state in notifications.c.
    G.Wood 17JAN19

BYD SA2FL rev03 02_01_05
    Updated TOC code to multi-message (based off CN200).  Changed to TOC.
    G.Wood 09APR19

BYD SA2FL rev01 03_03_03
    Updated variables for 03_03_03 part software.
    G.Wood 28JUN19

BYD SA2FL rev1 12_17_2020
    Changed GAC_A26 Code into BYD, Just did a quick Replace all for entire Project File
    Deleted many un-needed files.
    L.Mitchell 17DEC20
*/
/* USER CODE END */

/* Include Files */

#include "sys_common.h"

/* USER CODE BEGIN (1) */
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <limits.h>

#include "hal_stdtypes.h"
#include "math.h"
#include "adc.h"
#include "can.h"
#include "gio.h"
#include "spi.h"
#include "rti.h"
#include "het.h"
#include "sci.h"
#include "reg_system.h"
#include "mibspi.h"

#include "RS-485_Comm.h"
#include "B_CIB.h"
#include <flexray.h>

#include "DAQ_mode.h"

//#include "variable_input.h"
#include "NTC_get.h"

/***************************************************************************/
/*                                                                         */
/* Usefull bit macros. NEED TO CHECK - BIG ENDIAN functionality            */
/*                                                                         */
/***************************************************************************/

#define   checkbit(var,bit)  (var & (0x01 << (bit)))
#define   setbit(var,bit)    (var |= (0x01 << (bit)))
#define   clrbit(var,bit)    (var &= (~(0x01 << (bit))))

/**************************************************************************/
/*                           New 13AUG12 L. Cronk                         */
/* a=target variable, b=bit number to act upon 0-n                        */
/*                                                                        */
/**************************************************************************/
#define BIT_SET(a,b) ((a) |= (1<<(b)))
#define BIT_CLEAR(a,b) ((a) &= ~(1<<(b)))
#define BIT_FLIP(a,b) ((a) ^= (1<<(b)))
#define BIT_CHECK(a,b) ((a) & (1<<(b)))
/* x=target variable, y=mask */
#define BITMASK_SET(x,y) ((x) |= (y))
#define BITMASK_CLEAR(x,y) ((x) &= (~(y)))
#define BITMASK_FLIP(x,y) ((x) ^= (y))
#define BITMASK_CHECK(x,y) ((x) & (y))

#define D_SIZE 9

#define OFF 0
#define ON 1
#define PASS 1
#define FAIL 0
#define TOGGLE 2
#define FLASH 3

#define INIT 0
#define NOT_VALID 0
#define NONE 0
#define RUN 1
#define PAUSE 2
#define STOP 3
#define DERATE 4
#define RUN_ERROR 5
#define NO_CAN 6
#define BACKLIGHT 7
#define SETUP 8

#define IDLE 0
#define REQUEST 1
#define ACTIVE 2

// #define TRUE  1
// #define FALSE  0
#define POSITIVE 1
#define NEGATIVE 0
#define SET 1
#define CLR 0
#define YES 1
#define NO 0
#define POS 1
#define NEG 0
#define NORMAL 1
#define WARM 2
#define CRANK 3
#define HOLD 4


#define TRIGGERED   2   /* state of health interval has expired */
#define COMPLETE 2      /* power mode sequence complete */
#define LOADED 3        /* power mode sequence has some values loaded */

#define HIGH 1
#define LOW 0
#define NONE 0
#define SNAPPING 1
#define SNAPPED1 2
#define SNAPPED2 3
#define RESET 4
#define CIB 0
#define MONITOR 1
#define WEB 2



#define pos_0prcnt 0    /* TOC switch case labels  - 9BXX program*/
#define pos_2prcnt 1
#define neg_2prcnt 2
#define pos_8prcnt 3
#define neg_8prcnt 4
#define pos_16prcnt 5
#define neg_16prcnt 6
#define pos_30prcnt 7
#define neg_30prcnt 8
#define pos_95prcnt 9
#define neg_95prcnt 10

#define pos_0nm     0   /* TOC and Digital sensors switch case labels  - C1xx, T1XX and FCA ADAS programs*/
#define pos_p1nm    1
#define neg_p1nm    2
#define pos_p5nm    3
#define neg_p5nm    4
#define pos_1p00nm  5
#define neg_1p00nm  6
#define pos_1p50nm  7
#define neg_1p50nm  8
#define pos_2p00nm  9
#define neg_2p00nm  10
#define pos_2p50nm  11
#define neg_2p50nm  12
#define pos_3p00nm  13
#define neg_3p00nm  14
#define pos_3p50nm  15
#define neg_3p50nm  16
#define pos_4p00nm  17
#define neg_4p00nm  18
#define pos_6p00nm  19
#define neg_6p00nm  20

#define PRINT_ONE_CHANNEL 1
#define PRINT_ALL_CHANNELS 2

#define ADDR_MODE 0x100 //Necessary for RS485 code

#define TX_EMPTY 0x800  //Flag indicating SCI shift register is empty.

#define ALL 3
#define ME 1
#define BUFFER 0

#define TMS570 0
#define RENSIS 1

#define BAIRBOARD 0
#define FULL 1

#define TARGET_T1XX 1
#define TARGET_9BXX 2
#define TARGET_S550ANALOG 3
#define TARGET_S550DIGITAL 4
#define TARGET_C1XX 5
#define TARGET_FCA_ADAS 6
#define TARGET_CD391_ADAS 7
#define TARGET_G2KCA_ADAS 8
#define TARGET_PSA_CMP 9
#define TARGET_SGMW_CN200 10
#define TARGET_FORD_T3_T6 11
#define TARGET_GM_B_T1XX 12
#define TARGET_RENAULT_NISSAN 13
#define TARGET_K2XX_MTO 14
#define TARGET_T1XX_MTO 15
#define TARGET_BMW_FAAR_WE 16
#define TARGET_BMW_UKL 17
#define TARGET_EHPS 18
#define TARGET_SGMW_CN300 19
#define TARGET_BYD_SA2FL 20
#define TARGET_GWM_A0607 21


/*  --------- CAN_DATA_REQUESTS  :: Set for number CAN variable request + 1   T1XX = 28   C1XX = 18    B9XX = 36    FCA = 9   CD391 = 9  G2KCA = 9
 *                                                                            PSA_CMP = 17      CN200 = 13 -------  */
#define T1XX_CAN_DATA_REQUESTS 28                   /* Used for can1_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define BYD_SA2FL_CAN_DATA_REQUESTS 11                /* Used for can1_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define GWM_A0607_CAN_DATA_REQUESTS 11                /* Used for can1_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define C1XX_CAN_DATA_REQUESTS 18                   /* Used for can1_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define GM_9BXX_CAN_DATA_REQUESTS 36                /* Used for can1_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define FCA_ADAS_CAN_DATA_REQUESTS 9                /* Used for canX_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define CD391_ADAS_CAN_DATA_REQUESTS 15             /* Used for canX_request_index != can_index_value (previously just a #9). Larger for problems monitoring */
#define G2KCA_ADAS_CAN_DATA_REQUESTS 9              /* Used for canX_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define PSA_CMP_CAN_DATA_REQUESTS 17                /* Used for canX_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define SGMW_CN200_CAN_DATA_REQUESTS 13             /* Used for canX_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define FORD_T3_T6_CAN_DATA_REQUESTS 9              /* Used for canX_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define RENAULT_NISSAN_CAN_DATA_REQUESTS 13         /* Used for canX_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS 19    /* Used for canX_request_index != can_index_value (previously just a #). Created for easier updating of code */
#define TARGET_BMW_UKL_FRAY_DATA_REQUESTS 15        /* Used for canX_request_index != can_index_value (previously just a #). Created for easier updating of code */


#define TESTER_PRESENT_SEND_TIME 1500;
#define XCP_TIMEOUT_VALUE 280 //XCP request timeout value
#define CCP_TIMEOUT_VALUE 280 //CCP request timeout value

//extern void transmit_constant_str_485();      // replaced with void   transmit_str_485(char * return_message) defined in RS-485Comm.c
//extern void transmit_return_message_485();    // replaced with void   transmit_str_485(char * return_message) defined in RS-485Comm.c
void eval_command_string(void);
void ShiftCAN1 (void);                          //send connect message on CAN1
void ShiftCAN2 (void);                          //send connect message on CAN1
void ShiftFRAY (void);                          //send connect message on CAN1

void get_DTCs1(void);
void get_DTCs2(void);
void trig( void );
void dump( void );
void parse_can1_data(void);
void parse_can2_data(void);
void sent_data_calculation_from_analog(void);
void sent_data_calculation_from_torque(int *torque_value_case_index);
void sent_data_calculation_from_table(short const table[][5]);
//void sent_data_calculation_from_table(short *const table[][5]);
void hcurr_change_direction_at_nm(float target);    // function to swap T1/T2 direction at assigned torque (0.0, 0.1, 0.5, 1.0, 2.0, 4.0, 6.0) are valid values
void set_torque_TOC_or_SENT_or_Analog();    // added for code consolidation and Analog feature

/* ---------  M a i n   program  variables - Global   ---------  */

// define target EPS product to test
int target_product = TARGET_GWM_A0607;

// board personality configuration vars
int manufacturing_TOC = NO; // flag indicates we are using manufacturing TOC with Tester Present CAN messages    or    SENT torque simulation
int processor_type = RENSIS;    // flag indicates if Product is using BIG Endian(TMS570 processor) or LITTLE Endian(RENSIS processor) used to evaluate (parse) CAN data
int CIB_analog_config = FULL;   // flag indicates analog configuration, BAIRBOARD or FULL.  BAIRBOARD has reduced channel count, process a little differently.

int temp_analog_config_status;      // used only during "cal_stepX" command, forcing analog ISR to run all channels even if "BAIRBOARD" is selected

//struct board_config_stuct //structure to hold CIB configuration, chars for now.(update - As an experiment with header files,, find def in B_CIB.h, maybe all declares will end up there)
//{
//  char DIGITAL[50];   // "NO" or "YES"
//  char TCPIP[80];     // "NO" or "YES,slot #, IP address, MAC address, snapped_to_IP address"
//  char SENSOR[50];    // "NO" or "YES,0-1-2-3"  -- Type 1 or 2 or 3 sensor board design
//  char FLEX[50];      // "NO" or "YES"
//  char BOARD_ID[3];   // "xx"  hex switch value
//  char SOFTWARE_VERSION[50];  // program written for which product and software revision level
//};
struct board_config_stuct CIB_config_data;  // CIB_config_data is a structured variable of type---board_config_stuct


unsigned short test, test1, test2, test3, test4;
int aa,bb,cc,dd,ee;     // debug test vars, del later
int spi_a,spi_b,spi_c,spi_d,spi_e,spi_f,spi_g;    // debug vars, del later
unsigned timer_a, timer_b, timer_c, timer_d, timer_e, timer_f, timer_g, timer_h, timer_i, timer_j, timer_k; // used to benchmark execution of code segments


unsigned int het_test1, het_test2, het_test3;   // debugging het interrupts

float debug_can1_Qax[10];
float debug_can2_Qax[10];

unsigned int HET_msec_countdown_cnt;        // count down timer for delay of start for HET SENT signal generation,, after i2C has completed initilization

unsigned long system_msec_clock;    // rolling time base (msec ticks) used for delays updated in rti.c
unsigned long system_msec_clock_temp;   // rolling time base used for delays, time now
unsigned long LED_msec_clock;       // rolling time base used to generate USER LED action for program status
unsigned long p_off_continue_periodics_timer; // countdown timer to delay CAN periodic messages after p_off, new for SGMW CN200

//unsigned long LED_REC_msec_clock; // rolling time base used for delay, USER LED#3 (not used in MicroCore)
//unsigned long LED_TXD_msec_clock; // rolling time base used for delay, USER LED#4 (not used in MicroCore)


int SW1_high_or_low;                // Initialized to "high" and set to "low" in GIO notification during ISR
int SW1_is_snapping_snapped1_snapped2_reset_none;   // init "none", if-when user pushes"snapping", based on sw1 time low: var -> ("snapped1 then "snapped2")or"reset"
unsigned long  SW1_active_low_time;     // time stamp of when falling edge of SW1 occurred
unsigned long SW1_time_held_low;            // time in mS, SW1 was held low by user, debug
unsigned long SNAP_timeout_clock;       // set in GIO notification, and polled in RTI notification for timeout of SNAP feature valid for 10sec
unsigned long Monitor_delay_timer;      // used to add delays between xport MONITOR commands in SNAP activity
int snapping_LED_scroll;            // simple counter for setting states for LEDs during SNAP activity
int scilinREG_is_CIB_or_Monitor_or_WEB; // sci2 has many functions, first we use Monitor, then switch to CIB
int monitor_rec_index;              // within MONITOR, control communication flow in SEND and RECEIVE dialog
char command_str_mirror[255];       // save original read from Lantronix, command_str[] is deconstucted into WORDS[][] improperly for parsing string
char snap_authorization_str[75];    // temp storage for IP of whom im snapped to
int WEB_header_TX_complete;         // Used in WEB mode, flag to indicate constructed header portion of LAN message is complete, time to transmite actual message
uint32 WEB_data_length;         // Length of return message package for LAN, does not include header portion


int tester_state;           // state of test INIT, RUN, PAUSE, STOP ect. - B-Box Tester var
int bulgaria_led_temp;  // address pointer to SIMO register

// volatile uint32 *address;  Who needs this, Leonard???

uint32 board_id_bin;    // temp for reading het port and determining board id
//char board_id[3];     // bin to hex char string for dumping board id
uint32 board_configuration_bin; // hex switch located at NHET[18,20,21,22,23] to determine boards hardware configuration

/* ---------   S P E C I A L   MAIN  variables  - Global  ---------  */

unsigned int tester_present_timer; // count down variable to send tester present message every 3 seconds
int tester_present_enable_flag; // flag to start and stop the sending of tester present message
                                          // used so we can stop the message in 'warminit mode' so etool can flash parts

int  CIB_reset_flag; // init as =1 after CIB reset, set to zero after first dump err
int trig_flag; // flag to signal dumperr that a trig has been done..reset after dump



int ign1_status;        // combine function of ign_on_flag and Engine_on_Signal Off, Normal and Warm (added dual ign for ADAS)
int ign2_status;        // combine function of ign_on_flag and Engine_on_Signal Off, Normal and Warm (added dual ign for ADAS)

//int ign_on_flag;      // ignition state to product, ok to talk CAN and dump true data, if not, dump zeros
//int Engine_on_Signal; // signal to send ENG ON message
//int speed_flag;           /* If 100= 100mS periodic of CAN speed=100kph, 0= used at start of cal speed= 0Kph */




// used for building CAN speed, rolling counter and CRC bytes ect.. for various products
uint8 Veh_speed_count = 0;
const uint8 Veh_speed_0_table[16][8]        =
       {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x10,0xC7},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x8D},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x40},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x19},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x50,0xD4},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x9E},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x53},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x2C},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x90,0xE1},
        {0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0xAB},
        {0x00,0x00,0x00,0x00,0x00,0x00,0xB0,0x66},
        {0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x3F},
        {0x00,0x00,0x00,0x00,0x00,0x00,0xD0,0xF2},
        {0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xB8},
        {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x75}};

const uint8 Veh_speed_0_table_Ford[16][8]       =
       {{0x00,0x00,0xF0,0xF0,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xF4,0xEF,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xF8,0xEE,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xFC,0xED,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xC0,0xFC,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xC4,0xFB,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xC8,0xFA,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xCC,0xF9,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xD0,0xF8,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xD4,0xF7,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xD8,0xF6,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xDC,0xF5,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xE0,0xF4,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xE4,0xF3,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xE8,0xF2,0x00,0x00,0x00,0x00},
        {0x00,0x00,0xEC,0xF1,0x00,0x00,0x00,0x00}};

const uint8 Veh_speed_0_table_PSA[16][8] =
        {{0x00,0x00,0x00,0x00,0x00,0xCB,0x00,0x00}, /* engine_on & speed 0kph 8 bytes*/   //Added by P. Horny - 3Jul14
         {0x00,0x00,0x00,0x00,0x00,0xDA,0x00,0x00},  /* byte 7 contains checksum value, we just index through the table*/
         {0x00,0x00,0x00,0x00,0x00,0xE9,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0xF8,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0x25,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0x43,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0x52,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0x61,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0x8F,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0x9E,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0xAD,0x00,0x00},
         {0x00,0x00,0x00,0x00,0x00,0xBC,0x00,0x00}};

const uint8 Veh_speed_0_table_BYD_SA2FL[16][8]        =
       {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFE},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xFD},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFC},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xFB},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0xFA},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x06,0xF9},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF8},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xF7},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x09,0xF6},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0xF5},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0xF4},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0xF3},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0D,0xF2},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0xF1},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF0}};

const uint8 Veh_speed_00_table_BYD_SA2FL[16][8]        =
       {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x06,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x09,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0D,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0xF0},
        {0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF0}};
   
int G2KCA_ADAS_crcVal_16;                   // G2KCA speed message calculation
uint8 G2KCA_ADAS_Write_Vehicle_speed[8] = {0};      // G2KCA speed message calculation/
unsigned char G2KCA_ADAS_CRC_counter;       // G2KCA speed message calculation


int ucurr_flag;                 // flag to main to process user initiated TOC commands
int ucurr_direction_POS_NEG;    // ucurr direction swapper
int stop_T1T2switching;         // flag to RTI notification to start/stop switching for low current at 1 sec intervals

int hcurr_direction_POS_NEG;    // hcurr direction swapper, actual direction,   POSITIVE or NEGATIVE
int hcurr_flag;                 // flag to epa4 and main to determine if and when to process load profile
int hcurr_timer;                // time in 1mSec ticks for hcurr load profile timing

int hcurr_write_interval_data;  // flag set in notification RTI timer, its time to update load value
int torque_value_case_index;    // set index to value of case to load torque value, see constants

unsigned int high_torque_timer_flag; // set flag for notification RTI timer  NOT USED
int high_torque_timer_counter; // counter for 10 seconds. counts down in notification RTI timer NOT USED


/* ---------   S C I  variables  - Global  ---------  */

uint8 sbuf_tx_main[1024]; //  used for printing to sciREG, our debug com port
//   E X A M P L E S   of Serial Port    W R I T E S
//sprintf(tx_buff_main, "ad_2_5vref_val = %d\r\n",ad_2_5_vref_val);
//sciSend(sciREG1,strlen(tx_buff_main),tx_buff_main);
//sciSend(sciREG1, 19, (unsigned char *)"\r\nsent by sciSend\r\n"); //send string to SCI port, in debug, xmit thru USB and Console Terminal


uint8 sbuf_tx[1024]; //Necessary for RS485 code
uint8 sbuf_rx[1024]; //Necessary for RS485 code

unsigned short mp;      /* message pointer, keeping track of number of characters read, checking for message overflow, sciNotification*/

int who_is_addressed;       /* 0=buffer, 1 ;;CIB_config_data.BOARD_ID[] is my ID (me),3= all or everybody 'E' or 'F', also GM power moding in p_on, p_off*/
int data_frame; /* flag to indicate if address or data mode */

int tx_to_rx_delay_flag;    /* init flag for delay when transmitting RS458, so last byte is not cut off during transmission by transmitter */

/*  -----------  S C I   W E B  varialbles  -  Global  ---------  */

char NL = 0xA;  /* New Line (Sent with all SCI messages to Web Application) */
char reset_key_reg[8];  // may be used in future for user reset or flashing of CIB over comm port


/*  -----------  H E T   -  S E N T  2ch / 2 signal FOAA variables  -  Global  ---------  */
//int sent_update_flag;             // Main ACTIVE/IDLE with SENT cals, flag to HET Notification to or not to move data to HET RAM
//int value_sent1_cnt;                      // int value of sent1, combining 3 nibbles into 1 value, for dumperr, combination done in sent_data_calculation_from_analog()
//int value_sent2_cnt;                      // int value of sent2, combining 3 nibbles into 1 value, for dumperr, combination done in sent_data_calculation_from_analog()
//unsigned long sent_data_array[8]; // formatted data for -- Sent0 data0,data1,data2,CRC and Sent1 data0,data1,data2,CRC
//unsigned long sent_edge_event_time[2][15];    // contains the times based on SENT clock tick for each edge(14 of them) in SENT message packet,, for 2 channels

/*  -----------  H E T   -  S E N T  6ch / 8 signal T1XX variables  -  Global  ---------  */

int sent_torque_ChA_update_flag;    // ACTIVE/REQUEST/IDLE From MAIN ACTIVE while calulating edge time, set to REQUEST to signal IRQ data is ready for load HET RAM, IRQ set to IDLE when complete
int sent_torque_ChB_update_flag;    // ACTIVE/REQUEST/IDLE From MAIN ACTIVE while calulating edge time, set to REQUEST to signal IRQ data is ready for load HET RAM, IRQ set to IDLE when complete
int sent_ChA_handwheel_update_flag; // ACTIVE/REQUEST/IDLE From MAIN ACTIVE while calulating edge time, set to REQUEST to signal IRQ data is ready for load HET RAM, IRQ set to IDLE when complete
int sent_ChB_handwheel_update_flag; // ACTIVE/REQUEST/IDLE From MAIN ACTIVE while calulating edge time, set to REQUEST to signal IRQ data is ready for load HET RAM, IRQ set to IDLE when complete

int value_sent1_Adr0_ChA0_Pos_cnt;  // int value of sent1_Adr0, combining 3 nibbles into 1 value, for dumperr, combination done in sent_data_calculation_from_torque()
int value_sent2_Adr0_ChB0_Pos_cnt;  // int value of sent2_Adr0, combining 3 nibbles into 1 value, for dumperr, combination done in sent_data_calculation_from_torque()
int value_sent3_Adr1_ChA1_Pos_cnt;  // int value of sent3_Adr1, combining 3 nibbles into 1 value, for dumperr, combination done in sent_data_calculation_from_torque()
int value_sent4_Adr1_ChB1_Pos_cnt;  // int value of sent4_Adr1, combining 3 nibbles into 1 value, for dumperr, combination done in sent_data_calculation_from_torque()
int value_sent5_ChA_T1_cnt;         // int value of sent5, combining 3 nibbles into 1 value, for dumperr, combination done in sent_data_calculation_from_torque()
int value_sent6_ChA_T2_cnt;         // int value of sent6, combining 3 nibbles into 1 value, for dumperr, combination done in sent_data_calculation_from_torque()
int value_sent7_ChB_T1_cnt;         // int value of sent7, combining 3 nibbles into 1 value, for dumperr, combination done in sent_data_calculation_from_torque()
int value_sent8_ChB_T2_cnt;         // int value of sent8, combining 3 nibbles into 1 value, for dumperr, combination done in sent_data_calculation_from_torque()

short sent_data_array[8][5];        // formatted data for -- [0-3]=Sent0(addr0,1) or SENT1(addr0,1) data0,data1,data2,addr,CRC and [4-7]=Sent2-5 data0,data1,data2,CRC
short sent_edge_event_time[8][17];  // contains the times based on SENT clock tick for each edge(17 of them) in SENT message packet,, for 2 channels
                                            //    8 SENT signals on 6 SENT channels.  Will only stuff elements starting at edge 7, prior edge times will never change
short het_instruction_data[8][17];      // NEW - sent_edge_event_time[][] processed to match het data register format, so quick write in ISR

/*  OLD -- Non ADAS method of updating SENT HandWheel message for address#0  then address#1
int sent_toggle_HW_address_counter;         // Rolling counter for alternating address nibble in SENT1/SENT2 and in SENT3/4 from #0 to #1 to #0 to #1 ect on each trigger.
                                            //  Plan to ensure time synchronization is to use one counter to drive both address changes.
                                            //  Bump counter on SENT 3/4 IRQ after SENT4 address 1 data has been updated.  A bump will then cause the odd/even MOD to
                                            //  select the opposite set of data to upload. (address 0 or 1)
*/

int sent_ChA_toggle_HW_address_counter;     // Rolling counter for alternating address nibble in SENT1/SENT2 and in SENT3/4 from #0 to #1 to #0 to #1 ect on each trigger.
int sent_ChB_toggle_HW_address_counter;     //  Plan to ensure time synchronization is to use two counters (one for each ADAS processor to drive address changes).
                                            //  Bump ChA counter on SENT 1/2 IRQ after SENT2 address 1 data has been updated.
                                            //  Bump ChB counter on SENT 3/4 IRQ after SENT4 address 1 data has been updated.
                                            //  A bump will then cause the odd/even MOD to select the opposite set of data to upload. (address 0 or 1)


/*  ---------------- H E T  -  S E N T   constant tables  T1XX   -  Local    ---------------------  */

//  (Initialize to Position sensors to ChA = 180 deg  and ChB = 0 deg, 12bit digital sensor )
    //  (Initialize to Torque sensor NUL  or  T1 and T2 are FFF/2 = 7FF  , 12bit digital sensor )
        //      Position format = data0,data1,data2,addr,CRC
        //      Torque format   = data0,data1,data2,CRC

        //      The below formula is used for SENT Torque values:
        //          T1_counts = (Desired_Torque+10)*204.75
        //          T2_counts = (Desired_Torque-10)*(-204.75)

const short sent_data_array_pos_0nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x7,0xF,0xF,0x7,0x0},      // set Torque T1 ChA to null = 7FF                                = 0x7FF so 7FF7
            {0x7,0xF,0xF,0x7,0x0},      // set Torque T2 ChA to null = 7FF                                = 0x7FF so 7FF7
            {0x7,0xF,0xF,0x7,0x0},      // set Torque T1 ChB to null = 7FF                                = 0x7FF so 7FF7
            {0x7,0xF,0xF,0x7,0x0}};     // set Torque T2 ChB to null = 7FF                                = 0x7FF so 7FF7

const short sent_data_array_pos_p1nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x8,0x1,0x4,0x7,0x0},      // set Torque T1 ChA to null = 814                                = 0x814 so 8147
            {0x7,0xE,0xB,0xB,0x0},      // set Torque T2 ChA to null = 7EB                                = 0x7EB so 7EBB
            {0x8,0x1,0x4,0x7,0x0},      // set Torque T1 ChB to null = 814                                = 0x814 so 8147
            {0x7,0xE,0xB,0xB,0x0}};     // set Torque T2 ChB to null = 7EB                                = 0x7EB so 7EBB

const short sent_data_array_neg_p1nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x7,0xE,0xB,0xB,0x0},      // set Torque T1 ChA to null = 7EB                                = 0x7EB so 7EBB
            {0x8,0x1,0x4,0x7,0x0},      // set Torque T2 ChA to null = 814                                = 0x814 so 8147
            {0x7,0xE,0xB,0xB,0x0},      // set Torque T1 ChB to null = 7EB                                = 0x7EB so 7EBB
            {0x8,0x1,0x4,0x7,0x0}};     // set Torque T2 ChB to null = 814                                = 0x814 so 8147

const short sent_data_array_pos_p5nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x8,0x6,0x6,0xE,0x0},      // set Torque T1 ChA to null = 866                                = 0x866 so 866E
            {0x7,0x9,0x9,0x2,0x0},      // set Torque T2 ChA to null = 799                                = 0x799 so 7992
            {0x8,0x6,0x6,0xE,0x0},      // set Torque T1 ChB to null = 866                                = 0x866 so 866E
            {0x7,0x9,0x9,0x2,0x0}};     // set Torque T2 ChB to null = 799                                = 0x799 so 7992

const short sent_data_array_neg_p5nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x7,0x9,0x9,0x2,0x0},      // set Torque T1 ChA to null = 799                                = 0x799 so 7992
            {0x8,0x6,0x6,0xE,0x0},      // set Torque T2 ChA to null = 866                                = 0x866 so 866E
            {0x7,0x9,0x9,0x2,0x0},      // set Torque T1 ChB to null = 799                                = 0x799 so 7992
            {0x8,0x6,0x6,0xE,0x0}};     // set Torque T2 ChB to null = 866                                = 0x866 so 866E

const short sent_data_array_pos_1p00nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x8,0xC,0xC,0x1,0x0},      // set Torque T1 ChA to null = 8CC                                = 0x8CC so 8CC1
            {0x7,0x3,0x3,0xD,0x0},      // set Torque T2 ChA to null = 733                                = 0x733 so 733D
            {0x8,0xC,0xC,0x1,0x0},      // set Torque T1 ChB to null = 8CC                                = 0x8CC so 8CC1
            {0x7,0x3,0x3,0xD,0x0}};     // set Torque T2 ChB to null = 733                                = 0x733 so 733D

const short sent_data_array_neg_1p00nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x7,0x3,0x3,0xD,0x0},      // set Torque T1 ChA to null = 733                                = 0x733 so 733D
            {0x8,0xC,0xC,0x1,0x0},      // set Torque T2 ChA to null = 8CC                                = 0x8CC so 8CC1
            {0x7,0x3,0x3,0xD,0x0},      // set Torque T1 ChB to null = 733                                = 0x733 so 733D
            {0x8,0xC,0xC,0x1,0x0}};     // set Torque T2 ChB to null = 8CC                                = 0x8CC so 8CC1

const short sent_data_array_pos_1p50nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x9,0x3,0x3,0x0,0x0},      // set Torque T1 ChA to null = 933                                = 0x933 so 9330
            {0x6,0xC,0xC,0xC,0x0},      // set Torque T2 ChA to null = 6CC                                = 0x6CC so 6CCC
            {0x9,0x3,0x3,0x0,0x0},      // set Torque T1 ChB to null = 933                                = 0x933 so 9330
            {0x6,0xC,0xC,0xC,0x0}};     // set Torque T2 ChB to null = 6CC                                = 0x6CC so 6CCC

const short sent_data_array_neg_1p50nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x6,0xC,0xC,0xC,0x0},      // set Torque T2 ChA to null = 6CD                                = 0x6CD so 6CD1
            {0x9,0x3,0x3,0x0,0x0},      // set Torque T1 ChB to null = 931                                = 0x931 so 9317
            {0x6,0xC,0xC,0xC,0x0},      // set Torque T2 ChB to null = 6CD                                = 0x6CD so 6CD1
            {0x9,0x3,0x3,0x0,0x0}};     // set Torque T1 ChA to null = 931                                = 0x931 so 9317

const short sent_data_array_pos_2p00nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x9,0x9,0x9,0xF,0x0},      // set Torque T1 ChA to null = 999                                = 0x999 so 999F
            {0x6,0x6,0x6,0x3,0x0},      // set Torque T2 ChA to null = 666                                = 0x666 so 6663
            {0x9,0x9,0x9,0xF,0x0},      // set Torque T1 ChB to null = 999                                = 0x999 so 999F
            {0x6,0x6,0x6,0x3,0x0}};     // set Torque T2 ChB to null = 666                                = 0x666 so 6663

const short sent_data_array_neg_2p00nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x6,0x6,0x6,0x3,0x0},      // set Torque T1 ChA to null = 666                                = 0x666 so 6663
            {0x9,0x9,0x9,0xF,0x0},      // set Torque T2 ChA to null = 999                                = 0x999 so 999F
            {0x6,0x6,0x6,0x3,0x0},      // set Torque T1 ChB to null = 666                                = 0x666 so 6663
            {0x9,0x9,0x9,0xF,0x0}};     // set Torque T2 ChB to null = 999                                = 0x999 so 999F

const short sent_data_array_pos_2p50nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x9,0xF,0xF,0xA,0x0},      // set Torque T1 ChA to null = 9FF                                = 0x9FF so 9FFA
            {0x6,0x0,0x0,0x6,0x0},      // set Torque T2 ChA to null = 600                                = 0x600 so 6006
            {0x9,0xF,0xF,0xA,0x0},      // set Torque T1 ChB to null = 9FF                                = 0x9FF so 9FFA
            {0x6,0x0,0x0,0x6,0x0}};     // set Torque T2 ChB to null = 600                                = 0x600 so 6006

const short sent_data_array_neg_2p50nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x6,0x0,0x0,0x6,0x0},      // set Torque T2 ChA to null = 600                                = 0x600 so 6006
            {0x9,0xF,0xF,0xA,0x0},      // set Torque T1 ChB to null = 9FF                                = 0x9FF so 9FFA
            {0x6,0x0,0x0,0x6,0x0},      // set Torque T2 ChB to null = 600                                = 0x600 so 6006
            {0x9,0xF,0xF,0xA,0x0}};     // set Torque T1 ChA to null = 9FF                                = 0x9FF so 9FFA

const short sent_data_array_pos_3p00nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0xA,0x6,0x5,0xA,0x0},      // set Torque T1 ChA to null = A65                                = 0xA65 so A65A
            {0x5,0x9,0x9,0xC,0x0},      // set Torque T2 ChA to null = 599                                = 0x599 so 599C
            {0xA,0x6,0x5,0xA,0x0},      // set Torque T1 ChB to null = A65                                = 0xA65 so A65A
            {0x5,0x9,0x9,0xC,0x0}};     // set Torque T2 ChB to null = 599                                = 0x599 so 599C

const short sent_data_array_neg_3p00nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x5,0x9,0x9,0xC,0x0},      // set Torque T1 ChA to null = 599                                = 0x599 so 599C
            {0xA,0x6,0x5,0xA,0x0},      // set Torque T2 ChA to null = A65                                = 0xA65 so A65A
            {0x5,0x9,0x9,0xC,0x0},      // set Torque T1 ChB to null = 599                                = 0x599 so 599C
            {0xA,0x6,0x5,0xA,0x0}};     // set Torque T2 ChB to null = A65                                = 0xA65 so A65A

const short sent_data_array_pos_3p50nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0xA,0xC,0xC,0xF,0x0},      // set Torque T1 ChA to null = ACC                                = 0xACC so ACCF
            {0x5,0x3,0x3,0x3,0x0},      // set Torque T2 ChA to null = 533                                = 0x533 so 5333
            {0xA,0xC,0xC,0xF,0x0},      // set Torque T1 ChB to null = ACC                                = 0xACC so ACCF
            {0x5,0x3,0x3,0x3,0x0}};     // set Torque T2 ChB to null = 533                                = 0x533 so 5333

const short sent_data_array_neg_3p50nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x5,0x3,0x3,0x3,0x0},      // set Torque T2 ChA to null = 533                                = 0x533 so 5333
            {0xA,0xC,0xC,0xF,0x0},      // set Torque T1 ChB to null = ACC                                = 0xACC so ACCF
            {0x5,0x3,0x3,0x3,0x0},      // set Torque T2 ChB to null = 533                                = 0x533 so 5333
            {0xA,0xC,0xC,0xF,0x0}};     // set Torque T1 ChA to null = ACC                                = 0xACC so ACCF

const short sent_data_array_pos_4p00nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0xB,0x3,0x3,0xE,0x0},      // set Torque T1 ChA to null = B33                                = 0xB33 so B33E
            {0x4,0xC,0xC,0x2,0x0},      // set Torque T2 ChA to null = 4CC                                = 0x4CC so 4CC2
            {0xB,0x3,0x3,0xE,0x0},      // set Torque T1 ChB to null = B33                                = 0xB33 so B33E
            {0x4,0xC,0xC,0x2,0x0}};     // set Torque T2 ChB to null = 4CC                                = 0x4CC so 4CC2

const short sent_data_array_neg_4p00nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x4,0xC,0xC,0x2,0x0},      // set Torque T1 ChA to null = 4CC                                = 0x4CC so 4CC2
            {0xB,0x3,0x3,0xE,0x0},      // set Torque T2 ChA to null = B33                                = 0xB33 so B33E
            {0x4,0xC,0xC,0x2,0x0},      // set Torque T1 ChB to null = 4CC                                = 0x4CC so 4CC2
            {0xB,0x3,0x3,0xE,0x0}};     // set Torque T2 ChB to null = B33                                = 0xB33 so B33E

const short sent_data_array_pos_6p00nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0xC,0xC,0xC,0x0,0x0},      // set Torque T1 ChA to null = CCC                               = 0xCCC so CCC0
            {0x3,0x3,0x3,0xC,0x0},      // set Torque T2 ChA to null = 333                                = 0x333 so 333C
            {0xC,0xC,0xC,0x0,0x0},      // set Torque T1 ChB to null = CCC                                = 0xCCC so CCC0
            {0x3,0x3,0x3,0xC,0x0}};     // set Torque T2 ChB to null = 333                                = 0x333 so 333C

const short sent_data_array_neg_6p00nm[8][5] = {
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChA ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x7,0xF,0xF,0x0,0x4},      // set Position ChB ( addr0) to 180 deg =  180/360 * 4096 = 2048 = 0x7FF so 7FF04
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChA ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
        {0x0,0x0,0x0,0x1,0x1},      // set Position ChB ( addr1) to   0 deg =  0/360 * 4096   = 0    = 0x000 so 00011
            {0x3,0x3,0x3,0xC,0x0},      // set Torque T1 ChA to null = 333                                = 0x333 so 333C
            {0xC,0xC,0xC,0x0,0x0},      // set Torque T2 ChA to null = CCC                                = 0xCCC so CCC0
            {0x3,0x3,0x3,0xC,0x0},      // set Torque T1 ChB to null = 333                                = 0x333 so 333C
            {0xC,0xC,0xC,0x0,0x0}};     // set Torque T2 ChB to null = CCC                                = 0xCCC so CCC0




/* ---------  E V A L   C O M M A N D   S T R I N G  variables  - Global  ---------  */

char command_str[255];  /* store rec message  */ //Necessary for RS485
char sepchars[6];       //Necessary for RS485
char words[9][50];      /* row= delimited entity, colm= all chars within entity */ //Necessary for RS485 // was [9][25] L.Cronk 716/15
char *words_ptr;        // Necessary for parsing commands
char return_message[2000];  /* transmit to host after reception buffer */ //changed to 1000 18May18 P. Horny
char temp_return_message[2000];  // Used to build return string during "cal" command, was 190- not enough L.Cronk 11SEP14

char dtc1_return_message[257];  // Added additional memory for 5 byte returns, 17 chars*15dtc's=255 +2 fudge = 257bytes D. Bair 6/25/13
char dtc2_return_message[257];  // Added additional memory for 5 byte returns, 17 chars*15dtc's=255 +2 fudge = 257bytes D. Bair 6/25/13

// new rev07
char buffered_return_message[2000]; //used to buffer DAQ data for < 50 ms packets

int loop_cnt_a;             /* simple loop var, used in main for processing string commands */
long loop_cnt_b;            /* simple loop var, used in main */
int loop_cnt_c;             /* simple loop var, used in externs  */
int loop_cnt_d;             /* simple loop var, used in cal  */


int case_select;        /* case var used in eval_command */
int flag_to_process = 0;

int sscan_cnt;
int sscan_temp1;    /* temp for sscanf read of command string parameters, carry over from Intel code, rewrite if you wish */
int sscan_temp2;
int sscan_temp3;
int sscan_temp4;
int sscan_temp5;
int sscan_temp6;
int sscan_temp7;
int sscan_temp8;

int DtoA_ch0_val;   /* DtoA bit values for manual write */
int DtoA_ch1_val;   /* DtoA bit values for manual write */
int DtoA_ch2_val;   /* DtoA bit values for manual write */
int DtoA_ch3_val;   /* DtoA bit values for manual write */
int DtoA_ch4_val;   /* DtoA bit values for manual write */
int DtoA_ch5_val;   /* DtoA bit values for manual write */
int DtoA_ch6_val;   /* DtoA bit values for manual write */
int DtoA_ch7_val;   /* DtoA bit values for manual write */


/* ----------------  D U M P E R R     V a r s  -----------------------------------------------  */
unsigned int fault1_cnt;    /* tally system state type 1 faults, used in dumperr */
unsigned int fault2_cnt;    /* tally system state type 2 faults, used in dumperr */
unsigned int fault3_cnt;    /* tally system state type 2 faults, used in dumperr */

int dump_cnt;   /* 0 to 9 inc after each request, resetting.  Inserted into dump string. Files then indicate if dump string is lost */

const char N_A_str[4] ={"N/A"};    // used for filling dump_err and fuctional test strings 12NOV12 L. Cronk
int N_A_num = 0;


int dumperr_Tester1_vign;   /* Vign voltage=volt drop(in mV)*6(divider ratio) =converted to mV(Ex: 9.0V = 9000) */
int dumperr_Product1_5volt;
int dumperr_Product1_3volt;

int dumperr_Tester2_vign;   /* Vign voltage=volt drop(in mV)*6(divider ratio) =converted to mV(Ex: 9.0V = 9000) */
int dumperr_Product2_5volt;
int dumperr_Product2_3volt;

int can1_sys_state_warm_init; // is DUT in warm init state for Crank Test .. Obtained using "p_on_warm"..report in dumperr
int can2_sys_state_warm_init; // is DUT in warm init state for Crank Test .. Obtained using "p_on_warm"..report in dumperr

int FORD_hcurr_low_value_is_set;       // set to FALSE, when acquired in main() set to true, set back to FALSE after dumperr.
int FORD_hcurr_med_value_is_set;
int FORD_hcurr_high_value_is_set;


// /* ------------   P R O D U C T   B M W   U K L       (Non_ADAS, 1 FRAY Buss, 1 ECU)  D U M P E R R   V a r s -------------------------------  */
//
// // processor uses processor is TMS570, uses Big Endian , No Conversion REQUIRED
//
// FlexRay vars used for new B_CIB style dumperr, floating point as numbers "12.41" values
//    F R A Y 1

float fray1_BMW_UKL_Batt_Volt_fp;             // fray1_dump_err_data 1         Battery Voltage
float fray1_BMW_UKL_Batt_Curr_fp;             // fray1_dump_err_data 2         Battery Current
float fray1_BMW_UKL_Mot_Curr_fp;              // fray1_dump_err_data 3         Motor Current Measurement
float fray1_BMW_UKL_Mot_Vel_fp;               // fray1_dump_err_data 4         Motor Velocity
float fray1_BMW_UKL_Comm_Torque_fp;           // fray1_dump_err_data 5         Commanded Torque
float fray1_BMW_UKL_Lim_Torque_fp;            // fray1_dump_err_data 6         Ecu Temperature Filtered
float fray1_BMW_UKL_PCB_Temp_fp;              // fray1_dump_err_data 7         Ecu Temperature
float fray1_BMW_UKL_Mot_Temp_fp;              // fray1_dump_err_data 8         Motor Temperature
float fray1_BMW_UKL_Junction_Temp_fp;         // fray1_dump_err_data 9         Junction Temperature
float fray1_BMW_UKL_HW_Angle_fp;              // fray1_dump_err_data 10        Handwheel Angle
float fray1_BMW_UKL_Diff_Torque_fp;           // fray1_dump_err_data 11        HW Tq total
unsigned int fray1_BMW_UKL_sys_state_byt;     // fray1_dump_err_data 12        unsigned int  System State
float fray1_BMW_UKL_T1_Volt_fp;               // fray1_dump_err_data 13        channel a trq volts
float fray1_BMW_UKL_T2_Volt_fp;               // fray1_dump_err_data 14        channel b trq volts

// not used to date, would be captured during h_curr in PTC
//float fray1_BMW_UKL_MtrCurrQax1_fp;            // fray1_dump_err_data 15   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
//float fray1_BMW_UKL_HwTrq_HwNm1_fp;            // fray1_dump_err_data 16   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
//float fray1_BMW_UKL_MtrCurrQax2_fp;            // fray1_dump_err_data 17   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
//float fray1_BMW_UKL_HwTrq_HwNm2_fp;            // fray1_dump_err_data 18   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
//float fray1_BMW_UKL_MtrCurrQax3_fp;            // fray1_dump_err_data 19   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
//float fray1_BMW_UKL_HwTrq_HwNm3_fp;            // fray1_dump_err_data 12   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile


/* ----------------  P R O D U C T   B M W   U K L   (Non_ADAS, 1 FRAY Buss, 1 ECU)  C a l    V a r s  -----------------------------------------------  */
/* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
// cal/function storage for cal prior to string build
//    F R A Y  1

float cal1_BMW_UKL_Batt_Volt_fp;             // fray1_dump_err_data 1         Battery Voltage
float cal1_BMW_UKL_Batt_Curr_fp;             // fray1_dump_err_data 2         Battery Current
float cal1_BMW_UKL_Mot_Curr_fp;              // fray1_dump_err_data 3         Motor Current Measurement
float cal1_BMW_UKL_Mot_Vel_fp;               // fray1_dump_err_data 4         Motor Velocity
float cal1_BMW_UKL_Comm_Torque_fp;           // fray1_dump_err_data 5         Commanded Torque
float cal1_BMW_UKL_Lim_Torque_fp;            // fray1_dump_err_data 6         Ecu Temperature Filtered
float cal1_BMW_UKL_PCB_Temp_fp;              // fray1_dump_err_data 7         Ecu Temperature
float cal1_BMW_UKL_Mot_Temp_fp;              // fray1_dump_err_data 8         Motor Temperature
float cal1_BMW_UKL_Junction_Temp_fp;         // fray1_dump_err_data 9         Junction Temperature
float cal1_BMW_UKL_HW_Angle_fp;              // fray1_dump_err_data 10        Handwheel Angle
float cal1_BMW_UKL_Diff_Torque_fp;           // fray1_dump_err_data 11        HW Tq total
unsigned int cal1_BMW_UKL_sys_state_byt;     // fray1_dump_err_data 12        unsigned int  System State
float cal1_BMW_UKL_T1_Volt_fp;               // fray1_dump_err_data 13        channel a trq volts
float cal1_BMW_UKL_T2_Volt_fp;               // fray1_dump_err_data 14        channel b trq volts


/*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */
//    F R A Y  1
float cal1_BMW_UKL_MtrCurrQax_low_pos_fp;       //  15  Motor Current Measurement
float cal1_BMW_UKL_MtrCurrQax_med_pos_fp;       //  16  Motor Current Measurement
float cal1_BMW_UKL_MtrCurrQax_high_pos_fp;      //  17  Motor Current Measurement
float cal1_BMW_UKL_MtrCurrQax_low_neg_fp;       //  18  Motor Current Measurement
float cal1_BMW_UKL_MtrCurrQax_med_neg_fp;       //  19  Motor Current Measurement
float cal1_BMW_UKL_MtrCurrQax_high_neg_fp;      //  20  Motor Current Measurement
float cal1_BMW_UKL_HwTrq_HwNm_low_pos_fp;       //  21  HW Tq total
float cal1_BMW_UKL_HwTrq_HwNm_med_pos_fp;       //  22  HW Tq total
float cal1_BMW_UKL_HwTrq_HwNm_high_pos_fp;      //  23  HW Tq total
float cal1_BMW_UKL_HwTrq_HwNm_low_neg_fp;       //  24  HW Tq total
float cal1_BMW_UKL_HwTrq_HwNm_med_neg_fp;       //  25  HW Tq total
float cal1_BMW_UKL_HwTrq_HwNm_high_neg_fp;      //  26  HW Tq total



// /* ------------   P R O D U C T   B M W   F A A R  W E       (Non_ADAS, 1 FRAY Buss, 1 ECU)  D U M P E R R   V a r s -------------------------------  */
//
// // processor uses LITLE Eindian (not normal for TMS570) , Conversion REQUIRED
//
// FlexRay vars used for new B_CIB style dumperr, floating point as numbers "12.41" values
//    F R A Y 1

unsigned int fray1_FAAR_WE_SysStMod_byt;        // fray1_dump_err_data 1         System State
float fray1_FAAR_WE_BattVltg_BrdgVltg_fp;       // fray1_dump_err_data 2         Battery Voltage
float fray1_FAAR_WE_BattRtnCurrAmpr_fp;         // fray1_dump_err_data 3         Measured Battery Current
float fray1_FAAR_WE_HwAgArbn_fp;                // fray1_dump_err_data 4         Steering wheel angle
float fray1_FAAR_WE_HwTq4Meas_fp;               // fray1_dump_err_data 5         Torque Sensor T1
float fray1_FAAR_WE_HwTq5Meas_fp;               // fray1_dump_err_data 6         Torque Sensor T2
float fray1_FAAR_WE_HwTqArbn_fp;                // fray1_dump_err_data 7         Final Input Torque
float fray1_FAAR_WE_MotCurrSumA_fp;             // fray1_dump_err_data 8         Phase A Current
float fray1_FAAR_WE_MotCurrSumB_fp;             // fray1_dump_err_data 9         Phase B Current
float fray1_FAAR_WE_MotCurrSumC_fp;             // fray1_dump_err_data 10        Phase C Current
float fray1_FAAR_WE_MotVelCrf_fp;               // fray1_dump_err_data 11        Rotor Speed
float fray1_FAAR_WE_MotTqCmd_fp;                // fray1_dump_err_data 12        Requested Motor Torque
float fray1_FAAR_WE_MotTqEstimd_fp;             // fray1_dump_err_data 13        Estimated Motor Torque
float fray1_FAAR_WE_LoaSca_fp;                  // fray1_dump_err_data 14        Derating Vector
float fray1_FAAR_WE_EcuTMeas_fp;                // fray1_dump_err_data 15        Board Temp
float fray1_FAAR_WE_MotWidgT_fp;                // fray1_dump_err_data 16        Estimated Motor Winding Temp
float fray1_FAAR_WE_MotMagT_fp;                 // fray1_dump_err_data 17        EstimatedMagnet Temp
float fray1_FAAR_WE_MotFetT_fp;                 // fray1_dump_err_data 18        Estimated FET Temp

// not used to date, would be captured during h_curr in PTC
//float flex1_FAAR_WE_MtrCurrQax1_fp;            // fray1_dump_err_data 19   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
//float flex1_FAAR_WE_HwTrq_HwNm1_fp;            // fray1_dump_err_data 20   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
//float flex1_FAAR_WE_MtrCurrQax2_fp;            // fray1_dump_err_data 21   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
//float flex1_FAAR_WE_HwTrq_HwNm2_fp;            // fray1_dump_err_data 22   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
//float flex1_FAAR_WE_MtrCurrQax3_fp;            // fray1_dump_err_data 23   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
//float flex1_FAAR_WE_HwTrq_HwNm3_fp;            // fray1_dump_err_data 24   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile



/* ----------------  P R O D U C T   B M W   F A A R  W E   (Non_ADAS, 1 FRAY Buss, 1 ECU)  C a l    V a r s  -----------------------------------------------  */
/* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
// cal/function storage for cal prior to string build
//    F R A Y  1

unsigned cal1_FAAR_WE_SysStMod_byt;            // fray1_dump_err_data 1         System State
float cal1_FAAR_WE_BattVltg_BrdgVltg_fp;       // fray1_dump_err_data 2         Battery Voltage
float cal1_FAAR_WE_BattRtnCurrAmpr_fp;         // fray1_dump_err_data 3         Measured Battery Current
float cal1_FAAR_WE_HwAgArbn_fp;                // fray1_dump_err_data 4         Steering wheel angle
float cal1_FAAR_WE_HwTq4Meas_fp;               // fray1_dump_err_data 5         Torque Sensor T1
float cal1_FAAR_WE_HwTq5Meas_fp;               // fray1_dump_err_data 6         Torque Sensor T2
float cal1_FAAR_WE_HwTqArbn_fp;                // fray1_dump_err_data 7         Final Input Torque
float cal1_FAAR_WE_MotCurrSumA_fp;             // fray1_dump_err_data 8         Phase A Current
float cal1_FAAR_WE_MotCurrSumB_fp;             // fray1_dump_err_data 9         Phase B Current
float cal1_FAAR_WE_MotCurrSumC_fp;             // fray1_dump_err_data 10        Phase C Current
float cal1_FAAR_WE_MotVelCrf_fp;               // fray1_dump_err_data 11        Rotor Speed
float cal1_FAAR_WE_MotTqCmd_fp;                // fray1_dump_err_data 12        Requested Motor Torque
float cal1_FAAR_WE_MotTqEstimd_fp;             // fray1_dump_err_data 13        Estimated Motor Torque
float cal1_FAAR_WE_LoaSca_fp;                  // fray1_dump_err_data 14        Derating Vector
float cal1_FAAR_WE_EcuTMeas_fp;                // fray1_dump_err_data 15        Board Temp
float cal1_FAAR_WE_MotWidgT_fp;                // fray1_dump_err_data 16        Estimated Motor Winding Temp
float cal1_FAAR_WE_MotMagT_fp;                 // fray1_dump_err_data 17        EstimatedMagnet Temp
float cal1_FAAR_WE_MotFetT_fp;                 // fray1_dump_err_data 18        Estimated FET Temp



/*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */
//    F R A Y  1
float cal1_FAAR_WE_MtrCurrQax_low_pos_fp;       //  19  Motor Current Measurement
float cal1_FAAR_WE_MtrCurrQax_med_pos_fp;       //  20  Motor Current Measurement
float cal1_FAAR_WE_MtrCurrQax_high_pos_fp;      //  21  Motor Current Measurement
float cal1_FAAR_WE_MtrCurrQax_low_neg_fp;       //  22  Motor Current Measurement
float cal1_FAAR_WE_MtrCurrQax_med_neg_fp;       //  23  Motor Current Measurement
float cal1_FAAR_WE_MtrCurrQax_high_neg_fp;      //  24  Motor Current Measurement
float cal1_FAAR_WE_HwTrq_HwNm_low_pos_fp;       //  25  HW Tq total
float cal1_FAAR_WE_HwTrq_HwNm_med_pos_fp;       //  26  HW Tq total
float cal1_FAAR_WE_HwTrq_HwNm_high_pos_fp;      //  27  HW Tq total
float cal1_FAAR_WE_HwTrq_HwNm_low_neg_fp;       //  28  HW Tq total
float cal1_FAAR_WE_HwTrq_HwNm_med_neg_fp;       //  29  HW Tq total
float cal1_FAAR_WE_HwTrq_HwNm_high_neg_fp;      //  30  HW Tq total



// /* ------------ P R O D U C T   R E N A U L T -  N I S S A N       (Non_ADAS, single CAN)  D U M P E R R   V a r s -------------------------------  */
//
// // processor uses LITLE Eindian (not normal for TMS570) , Conversion REQUIRED
//
// CAN vars used for new B_CIB style dumperr, floating point as numbers "12.41" values
//    C A N  1

float           can1_RENAULT_NISSAN_BattVltg_fp;                     // can1_dump_err_data 1       Battery Voltage
float           can1_RENAULT_NISSAN_Temperature_fp;                  // can1_dump_err_data 2       Ecu Temperature Filtered
float           can1_RENAULT_NISSAN_DigT1_HwNm_fp;                      // can1_dump_err_data 3    HwTq 0
float           can1_RENAULT_NISSAN_DigT2_HwNm_fp;                   // can1_dump_err_data 4       HwTq 1
float           can1_RENAULT_NISSAN_MtrCurrQax_fp;                   // can1_dump_err_data 5       Motor Current Measurement
unsigned int    can1_RENAULT_NISSAN_SystemState_byt;                 // can1_dump_err_data 6       System State
float           can1_RENAULT_NISSAN_HwTrq_HwNm_fp;                   // can1_dump_err_data 7       Handwheel Tq total
float           can1_RENAULT_NISSAN_Abs_Hw_Pos_fp;                   // can1_dump_err_data 8       Handwheel Angle
float           can1_RENAULT_NISSAN_MotTrq_Crf_fp;                      // can1_dump_err_data 9    Motor Current Commanded
float           can1_RENAULT_NISSAN_MotTrq_Mrf_fp;                      // can1_dump_err_data 10   Motor Current Measured
float           can1_RENAULT_NISSAN_VehSpd_fp;                       // can1_dump_err_data 11      Speed
float           can1_RENAULT_NISSAN_Spare2_fp;                       // can1_dump_err_data 12      Spair2

float can1_RENAULT_NISSAN_MtrCurrQax1_fp;            // can1_dump_err_data 13    triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_RENAULT_NISSAN_HwTrq_HwNm1_fp;            // can1_dump_err_data 14   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_RENAULT_NISSAN_MtrCurrQax2_fp;            // can1_dump_err_data 15   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_RENAULT_NISSAN_HwTrq_HwNm2_fp;            // can1_dump_err_data 16   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_RENAULT_NISSAN_MtrCurrQax3_fp;            // can1_dump_err_data 17   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_RENAULT_NISSAN_HwTrq_HwNm3_fp;            // can1_dump_err_data 18   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile


/* ----------------  R E N A U L T -  N I S S A N   (Non_ADAS, single CAN)  C a l    V a r s  -----------------------------------------------  */
/* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
// cal/function storage for cal prior to string build
//    C A N  1
float           cal1_RENAULT_NISSAN_BattVltg_fp;                     // can1_dump_err_data 1       Battery Voltage
float           cal1_RENAULT_NISSAN_Temperature_fp;                  // can1_dump_err_data 2       Ecu Temperature Filtered
float           cal1_RENAULT_NISSAN_DigT1_HwNm_fp;                   // can1_dump_err_data 3       HwTq 0
float           cal1_RENAULT_NISSAN_DigT2_HwNm_fp;                   // can1_dump_err_data 4       HwTq 1
float           cal1_RENAULT_NISSAN_MtrCurrQax_fp;                   // can1_dump_err_data 5       Motor Current Measurement
unsigned int    cal1_RENAULT_NISSAN_SystemState_byt;                 // can1_dump_err_data 6       System State
float           cal1_RENAULT_NISSAN_HwTrq_HwNm_fp;                   // can1_dump_err_data 7       Handwheel Tq total
float           cal1_RENAULT_NISSAN_Abs_Hw_Pos_fp;                   // can1_dump_err_data 8       Handwheel Angle
float           cal1_RENAULT_NISSAN_MotTrq_Crf_fp;                   // can1_dump_err_data 9       Motor Current Commanded
float           cal1_RENAULT_NISSAN_MotTrq_Mrf_fp;                   // can1_dump_err_data 10      Motor Current Measured
float           cal1_RENAULT_NISSAN_VehSpd_fp;                       // can1_dump_err_data 11      Speed
float           cal1_RENAULT_NISSAN_Spare2_fp;                       // can1_dump_err_data 12      Spair2


/*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */
//    C A N  1
float cal1_RENAULT_NISSAN_MtrCurrQax_low_pos_fp;       //  13  Motor Current Measurement
float cal1_RENAULT_NISSAN_MtrCurrQax_med_pos_fp;       //  14  Motor Current Measurement
float cal1_RENAULT_NISSAN_MtrCurrQax_high_pos_fp;      //  15  Motor Current Measurement
float cal1_RENAULT_NISSAN_MtrCurrQax_low_neg_fp;       //  16  Motor Current Measurement
float cal1_RENAULT_NISSAN_MtrCurrQax_med_neg_fp;       //  17  Motor Current Measurement
float cal1_RENAULT_NISSAN_MtrCurrQax_high_neg_fp;      //  18  Motor Current Measurement
float cal1_RENAULT_NISSAN_HwTrq_HwNm_low_pos_fp;       //  19  HW Tq total
float cal1_RENAULT_NISSAN_HwTrq_HwNm_med_pos_fp;       //  20  HW Tq total
float cal1_RENAULT_NISSAN_HwTrq_HwNm_high_pos_fp;      //  21  HW Tq total
float cal1_RENAULT_NISSAN_HwTrq_HwNm_low_neg_fp;       //  22  HW Tq total
float cal1_RENAULT_NISSAN_HwTrq_HwNm_med_neg_fp;       //  23  HW Tq total
float cal1_RENAULT_NISSAN_HwTrq_HwNm_high_neg_fp;      //  24  HW Tq total



// /* ------------ P R O D U C T   F O R D   T 3  -  T6     (non ADAS, 1 CAN Buss, 2 ECUs)    D U M P E R R   V a r s -------------------------------  */
//
// // processor uses LITLE Eindian (not normal for TMS570) , Conversion REQUIRED
//
// CAN vars used for new B_CIB style dumperr, floating point as numbers "12.41" values
//    C A N  1   -   E C U 1

float can1_FORD_T3_ECU1_BattVltg_fp;                       // can1_dump_err_data 1     Battery Voltage
float can1_FORD_T3_ECU1_Temperature_fp;                    // can1_dump_err_data 2     Ecu Temperature Filtered
float can1_FORD_T3_ECU1_DigT1_fp;                          // can1_dump_err_data 3     Handwheel channel a trq
float can1_FORD_T3_ECU1_DigT2_fp;                          // can1_dump_err_data 4     Handwheel channel b trq
float can1_FORD_T3_ECU1_MtrCurrQax_fp;                     // can1_dump_err_data 5     Motor Current Measurement
unsigned int can1_FORD_T3_ECU1_SystemState_byt;            // can1_dump_err_data 6     System State
float can1_FORD_T3_ECU1_HwTrq_HwNm_fp;                     // can1_dump_err_data 7     Handwheel Tq total
float can1_FORD_T3_ECU1_Abs_Hw_Pos_fp;                     // can1_dump_err_data 8     Handwheel Angle ABS

float can1_FORD_T3_ECU1_MtrCurrQax1_fp;            // can1_dump_err_data 9    triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_T3_ECU1_HwTrq_HwNm1_fp;            // can1_dump_err_data 10   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_T3_ECU1_MtrCurrQax2_fp;            // can1_dump_err_data 11   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_T3_ECU1_HwTrq_HwNm2_fp;            // can1_dump_err_data 12   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_T3_ECU1_MtrCurrQax3_fp;            // can1_dump_err_data 13   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_T3_ECU1_HwTrq_HwNm3_fp;            // can1_dump_err_data 14   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile

//   C A N 1   -   E C U 2
float can1_FORD_T3_ECU2_BattVltg_fp;                       // can2_dump_err_data 1     Battery Voltage
float can1_FORD_T3_ECU2_Temperature_fp;                    // can2_dump_err_data 2     Ecu Temperature Filtered
float can1_FORD_T3_ECU2_DigT1_fp;                          // can2_dump_err_data 3     Handwheel channel a trq
float can1_FORD_T3_ECU2_DigT2_fp;                          // can2_dump_err_data 4     Handwheel channel b trq
float can1_FORD_T3_ECU2_MtrCurrQax_fp;                     // can2_dump_err_data 5     Motor Current Measurement
unsigned int can1_FORD_T3_ECU2_SystemState_byt;            // can2_dump_err_data 6     System State
float can1_FORD_T3_ECU2_HwTrq_HwNm_fp;                     // can2_dump_err_data 7     Handwheel Tq total
float can1_FORD_T3_ECU2_Abs_Hw_Pos_fp;                     // can2_dump_err_data 8     Handwheel Angle ABS

float can1_FORD_T3_ECU2_MtrCurrQax1_fp;            // can2_dump_err_data 9    triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_T3_ECU2_HwTrq_HwNm1_fp;            // can2_dump_err_data 10   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_T3_ECU2_MtrCurrQax2_fp;            // can2_dump_err_data 11   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_T3_ECU2_HwTrq_HwNm2_fp;            // can2_dump_err_data 12   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_T3_ECU2_MtrCurrQax3_fp;            // can2_dump_err_data 13   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_T3_ECU2_HwTrq_HwNm3_fp;            // can2_dump_err_data 14   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile


/* ----------------  P R O D U C T   F O R D   T 3  -  T6  C a l    V a r s  -----------------------------------------------  */
/* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
// cal/function storage for cal prior to string build

//    C A N  1   -   E C U 1
float cal1_FORD_T3_ECU1_BattVltg_fp;                                   //  1       Battery Voltage
float cal1_FORD_T3_ECU1_Temperature_fp;                                //  2       Ecu Temperature Filtered
float cal1_FORD_T3_ECU1_DigT1_fp;                                      //  3       Handwheel channel a trq
float cal1_FORD_T3_ECU1_DigT2_fp;                                      //  4       Handwheel channel b trq
float cal1_FORD_T3_ECU1_MtrCurrQax_fp;                                 //  5       Motor Current Measurement
unsigned int cal1_FORD_T3_ECU1_SystemState_byt;                        //  6       System State
float cal1_FORD_T3_ECU1_HwTrq_HwNm_fp;                                 //  7       Handwheel Tq total
float cal1_FORD_T3_ECU1_Abs_Hw_Pos_fp;                                 //  8       Handwheel Angle ABS


/*  ---  Cal-Functional storage for motor currents and handwheel torques at 3 levels and positive/negative values   */

float cal1_FORD_T3_ECU1_MtrCurrQax_low_pos_fp;         //  9  Motor Current Measurement
float cal1_FORD_T3_ECU1_MtrCurrQax_med_pos_fp;         //  10  Motor Current Measurement
float cal1_FORD_T3_ECU1_MtrCurrQax_high_pos_fp;        //  11  Motor Current Measurement

float cal1_FORD_T3_ECU1_MtrCurrQax_low_neg_fp;         //  12  Motor Current Measurement
float cal1_FORD_T3_ECU1_MtrCurrQax_med_neg_fp;         //  13  Motor Current Measurement
float cal1_FORD_T3_ECU1_MtrCurrQax_high_neg_fp;        //  14  Motor Current Measurement

float cal1_FORD_T3_ECU1_HwTrq_HwNm_low_pos_fp;         //  15  HW Tq total
float cal1_FORD_T3_ECU1_HwTrq_HwNm_med_pos_fp;         //  16  HW Tq total
float cal1_FORD_T3_ECU1_HwTrq_HwNm_high_pos_fp;        //  17  HW Tq total

float cal1_FORD_T3_ECU1_HwTrq_HwNm_low_neg_fp;         //  18  HW Tq total
float cal1_FORD_T3_ECU1_HwTrq_HwNm_med_neg_fp;         //  19  HW Tq total
float cal1_FORD_T3_ECU1_HwTrq_HwNm_high_neg_fp;        //  20  HW Tq total


//   C A N 1   -   E C U 2
 float cal2_FORD_T3_ECU2_BattVltg_fp;                                  //  1       Battery Voltage
 float cal2_FORD_T3_ECU2_Temperature_fp;                               //  2       Ecu Temperature Filtered
 float cal2_FORD_T3_ECU2_DigT1_fp;                                     //  3       Handwheel channel a trq
 float cal2_FORD_T3_ECU2_DigT2_fp;                                     //  4       Handwheel channel b trq
 float cal2_FORD_T3_ECU2_MtrCurrQax_fp;                                //  5       Motor Current Measurement
 unsigned int cal2_FORD_T3_ECU2_SystemState_byt;                       //  6       System State
 float cal2_FORD_T3_ECU2_HwTrq_HwNm_fp;                                //  7       Handwheel Tq total
 float cal2_FORD_T3_ECU2_Abs_Hw_Pos_fp;                                //  8       Handwheel Angle ABS

 /*  ---  Cal-Functional storage for motor currents and handwheel torques at 3 levels and positive/negative values   */

 float cal2_FORD_T3_ECU2_MtrCurrQax_low_pos_fp;        //  9   Motor Current Measurement
 float cal2_FORD_T3_ECU2_MtrCurrQax_med_pos_fp;        //  10  Motor Current Measurement
 float cal2_FORD_T3_ECU2_MtrCurrQax_high_pos_fp;       //  11  Motor Current Measurement

 float cal2_FORD_T3_ECU2_MtrCurrQax_low_neg_fp;        //  12  Motor Current Measurement
 float cal2_FORD_T3_ECU2_MtrCurrQax_med_neg_fp;        //  13  Motor Current Measurement
 float cal2_FORD_T3_ECU2_MtrCurrQax_high_neg_fp;       //  14  Motor Current Measurement

 float cal2_FORD_T3_ECU2_HwTrq_HwNm_low_pos_fp;    //  15  HW Tq total
 float cal2_FORD_T3_ECU2_HwTrq_HwNm_med_pos_fp;    //  16  HW Tq total
 float cal2_FORD_T3_ECU2_HwTrq_HwNm_high_pos_fp;   //  17  HW Tq total

 float cal2_FORD_T3_ECU2_HwTrq_HwNm_low_neg_fp;    //  18  HW Tq total
 float cal2_FORD_T3_ECU2_HwTrq_HwNm_med_neg_fp;    //  19  HW Tq total
 float cal2_FORD_T3_ECU2_HwTrq_HwNm_high_neg_fp;   //  20  HW Tq total





// /* ------------ P R O D U C T   S G M W  C N 2 0 0       (Non_ADAS, single CAN)  D U M P E R R   V a r s -------------------------------  */
//
// // processor uses LITLE Eindian (not normal for TMS570) , Conversion REQUIRED
//
// CAN vars used for new B_CIB style dumperr, floating point as numbers "12.41" values
//    C A N  1

float           can1_CN200_BattVltg_fp;                     // can1_dump_err_data 1       Battery Voltage
float           can1_CN200_Temperature_fp;                  // can1_dump_err_data 2       Ecu Temperature Filtered
float           can1_CN200_DigT1_HwNm_fp;                   // can1_dump_err_data 3       HwTq 0
float           can1_CN200_DigT2_HwNm_fp;                   // can1_dump_err_data 4       HwTq 1
float           can1_CN200_MtrCurrQax_fp;                   // can1_dump_err_data 5       Motor Current Measurement
unsigned int    can1_CN200_SystemState_byt;                 // can1_dump_err_data 6       System State
float           can1_CN200_HwTrq_HwNm_fp;                   // can1_dump_err_data 7       Handwheel Tq total
float           can1_CN200_Abs_Hw_Pos_fp;                   // can1_dump_err_data 8       Handwheel Angle
float           can1_CN200_MotTrq_Crf_fp;                   // can1_dump_err_data 9       Sensor 5Volt
float           can1_CN200_MotTrq_Mrf_fp;                   // can1_dump_err_data 10      Sensor 3Volt
float           can1_CN200_VehSpd_fp;                       // can1_dump_err_data 11      Spair1
float           can1_CN200_Spare2_fp;                       // can1_dump_err_data 12      Spair2

float can1_CN200_MtrCurrQax1_fp;            // can1_dump_err_data 13    triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_CN200_HwTrq_HwNm1_fp;            // can1_dump_err_data 14   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_CN200_MtrCurrQax2_fp;            // can1_dump_err_data 15   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_CN200_HwTrq_HwNm2_fp;            // can1_dump_err_data 16   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_CN200_MtrCurrQax3_fp;            // can1_dump_err_data 17   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_CN200_HwTrq_HwNm3_fp;            // can1_dump_err_data 18   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile

/* ----------------  S G M W  C N 2 0 0   (Non_ADAS, single CAN)  C a l    V a r s  -----------------------------------------------  */
/* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
// cal/function storage for cal prior to string build
//    C A N  1
float           cal1_CN200_BattVltg_fp;                     // can1_dump_err_data 1       Battery Voltage
float           cal1_CN200_Temperature_fp;                  // can1_dump_err_data 2       Ecu Temperature Filtered
float           cal1_CN200_DigT1_HwNm_fp;                   // can1_dump_err_data 3       HwTq 0
float           cal1_CN200_DigT2_HwNm_fp;                   // can1_dump_err_data 4       HwTq 1
float           cal1_CN200_MtrCurrQax_fp;                   // can1_dump_err_data 5       Motor Current Measurement
unsigned int    cal1_CN200_SystemState_byt;                 // can1_dump_err_data 6       System State
float           cal1_CN200_HwTrq_HwNm_fp;                   // can1_dump_err_data 7       Handwheel Tq total
float           cal1_CN200_Abs_Hw_Pos_fp;                   // can1_dump_err_data 8       Handwheel Angle
float           cal1_CN200_MotTrq_Crf_fp;                   // can1_dump_err_data 9       Sensor 5Volt
float           cal1_CN200_MotTrq_Mrf_fp;                   // can1_dump_err_data 10      Sensor 3Volt
float           cal1_CN200_VehSpd_fp;                       // can1_dump_err_data 11      Spair1
float           cal1_CN200_Spare2_fp;                       // can1_dump_err_data 12      Spair2


/*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */
//    C A N  1
float cal1_CN200_MtrCurrQax_low_pos_fp;       //  13  Motor Current Measurement
float cal1_CN200_MtrCurrQax_med_pos_fp;       //  14  Motor Current Measurement
float cal1_CN200_MtrCurrQax_high_pos_fp;      //  15  Motor Current Measurement
float cal1_CN200_MtrCurrQax_low_neg_fp;       //  16  Motor Current Measurement
float cal1_CN200_MtrCurrQax_med_neg_fp;       //  17  Motor Current Measurement
float cal1_CN200_MtrCurrQax_high_neg_fp;      //  18  Motor Current Measurement
float cal1_CN200_HwTrq_HwNm_low_pos_fp;       //  19  HW Tq total
float cal1_CN200_HwTrq_HwNm_med_pos_fp;       //  20  HW Tq total
float cal1_CN200_HwTrq_HwNm_high_pos_fp;      //  21  HW Tq total
float cal1_CN200_HwTrq_HwNm_low_neg_fp;       //  22  HW Tq total
float cal1_CN200_HwTrq_HwNm_med_neg_fp;       //  23  HW Tq total
float cal1_CN200_HwTrq_HwNm_high_neg_fp;      //  24  HW Tq total



// /* ------------ P R O D U C T   P S A    C M P    D U M P E R R   V a r s -------------------------------  */
//
// // processor uses BIG Eindian (normal for TMS570) , no conversion required
//
// CAN vars used for new B_CIB style dumperr, floating point as numbers "12.41" values

float           can1_PSA_CMP_BattVltg_fp;                  // can1_dump_err_data 1       Battery Voltage
float           can1_PSA_CMP_Temperature_fp;               // can1_dump_err_data 2       Ecu Temperature Filtered
float           can1_PSA_CMP_DigT1_fp;                     // can1_dump_err_data 3       Handwheel channel a trq
float           can1_PSA_CMP_DigT2_fp;                     // can1_dump_err_data 4       Handwheel channel b trq
unsigned int    can1_PSA_CMP_SystemState_byt;              // can1_dump_err_data 5       System State
float           can1_PSA_CMP_MtrCurrQax_fp;                // can1_dump_err_data 6       Motor Current Measurement
float           can1_PSA_CMP_MtrCurrDax_fp;                // can1_dump_err_data 7       Motor Current Measurement
float           can1_PSA_CMP_HwTrq_HwNm_fp;                // can1_dump_err_data 8       Handwheel Tq total
float           can1_PSA_CMP_MtrTrqCmd_HwNm_fp;            // can1_dump_err_data 9       Motor Tq Commanded
float           can1_PSA_CMP_AstMtrTrq_HwNm_fp;            // can1_dump_err_data 10      Motor Tq Assist
float           can1_PSA_CMP_Abs_Hw_Pos_fp;                // can1_dump_err_data 11      Handwheel Abs Position
float           can1_PSA_CMP_Rel_Hw_Pos_fp;                // can1_dump_err_data 12      Handwheel Rel Position
unsigned int    can1_PSA_CMP_Abs_Hw_Pos_Valid_byt;         // can1_dump_err_data 13      Handwheel Position Valid
float           can1_PSA_CMP_MtrPos_fp;                    // can1_dump_err_data 14      Motor Position
float           can1_PSA_CMP_ADC_MtrCurr1_fp;              // can1_dump_err_data 15      Motor current ADC 1
float           can1_PSA_CMP_ADC_MtrCurr2_fp;              // can1_dump_err_data 16      Motor current ADC2


/* ----------------  PSA CMP  C a l    V a r s  -----------------------------------------------  */
/* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
// cal/function storage for cal prior to string build

float           cal1_PSA_CMP_BattVltg_fp;                  // can1_dump_err_data 1       Battery Voltage
float           cal1_PSA_CMP_Temperature_fp;               // can1_dump_err_data 2       Ecu Temperature Filtered
float           cal1_PSA_CMP_DigT1_fp;                     // can1_dump_err_data 3       Handwheel channel a trq
float           cal1_PSA_CMP_DigT2_fp;                     // can1_dump_err_data 4       Handwheel channel b trq
unsigned int    cal1_PSA_CMP_SystemState_byt;              // can1_dump_err_data 5       System State
float           cal1_PSA_CMP_MtrCurrQax_fp;                // can1_dump_err_data 6       Motor Current Measurement
float           cal1_PSA_CMP_MtrCurrDax_fp;                // can1_dump_err_data 7       Motor Current Measurement
float           cal1_PSA_CMP_HwTrq_HwNm_fp;                // can1_dump_err_data 8       Handwheel Tq total
float           cal1_PSA_CMP_MtrTrqCmd_HwNm_fp;            // can1_dump_err_data 9       Motor Tq Commanded
float           cal1_PSA_CMP_AstMtrTrq_HwNm_fp;            // can1_dump_err_data 10      Motor Tq Assist
float           cal1_PSA_CMP_Abs_Hw_Pos_fp;                // can1_dump_err_data 11      Handwheel Abs Position
float           cal1_PSA_CMP_Rel_Hw_Pos_fp;                // can1_dump_err_data 12      Handwheel Rel Position
unsigned int    cal1_PSA_CMP_Abs_Hw_Pos_Valid_byt;         // can1_dump_err_data 13      Handwheel Position Valid
float           cal1_PSA_CMP_MtrPos_fp;                    // can1_dump_err_data 14      Motor Position
float           cal1_PSA_CMP_ADC_MtrCurr1_fp;              // can1_dump_err_data 15      Motor current ADC 1
float           cal1_PSA_CMP_ADC_MtrCurr2_fp;              // can1_dump_err_data 16      Motor current ADC2

/*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */

float cal1_PSA_CMP_MtrCurrQax_low_pos_fp;       //  17  Motor Current Measurement
float cal1_PSA_CMP_MtrCurrQax_med_pos_fp;       //  18  Motor Current Measurement
float cal1_PSA_CMP_MtrCurrQax_high_pos_fp;      //  19  Motor Current Measurement
float cal1_PSA_CMP_MtrCurrQax_low_neg_fp;       //  20  Motor Current Measurement
float cal1_PSA_CMP_MtrCurrQax_med_neg_fp;       //  21  Motor Current Measurement
float cal1_PSA_CMP_MtrCurrQax_high_neg_fp;      //  22  Motor Current Measurement
float cal1_PSA_CMP_HwTrq_HwNm_low_pos_fp;       //  23  HW Tq total
float cal1_PSA_CMP_HwTrq_HwNm_med_pos_fp;       //  24  HW Tq total
float cal1_PSA_CMP_HwTrq_HwNm_high_pos_fp;      //  25  HW Tq total
float cal1_PSA_CMP_HwTrq_HwNm_low_neg_fp;       //  26  HW Tq total
float cal1_PSA_CMP_HwTrq_HwNm_med_neg_fp;       //  27  HW Tq total
float cal1_PSA_CMP_HwTrq_HwNm_high_neg_fp;      //  28  HW Tq total



// /* ------------ P R O D U C T   G 2 K C A    (ADAS)    D U M P E R R   V a r s -------------------------------  */
//
// // processor uses LITLE Eindian (not normal for TMS570) , Conversion REQUIRED
//
// CAN vars used for new B_CIB style dumperr, floating point as numbers "12.41" values
//    C A N  1
float can1_G2KCA_BattVltg_fp;                               // can1_dump_err_data 1         Battery Voltage
float can1_G2KCA_Temperature_fp;                            // can1_dump_err_data 2         Ecu Temperature Filtered
float can1_G2KCA_DigT1_fp;                                  // can1_dump_err_data 3     Handwheel channel a trq
float can1_G2KCA_DigT2_fp;                                  // can1_dump_err_data 4     Handwheel channel b trq
float can1_G2KCA_MtrCurrQax_fp;                             // can1_dump_err_data 5         Motor Current Measurement
unsigned int can1_G2KCA_SystemState_byt;                    // can1_dump_err_data 6         System State
float can1_G2KCA_HwTrq_HwNm_fp;                             // can1_dump_err_data 7     Handwheel Tq total
float can1_G2KCA_Abs_Hw_Pos_fp;                             // can1_dump_err_data 8     Handwheel Angle ABS

float can1_G2KCA_MtrCurrQax1_fp;            // can1_dump_err_data 9    triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_G2KCA_MtrCurrQax2_fp;            // can1_dump_err_data 10   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_G2KCA_MtrCurrQax3_fp;            // can1_dump_err_data 11   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile

float can1_G2KCA_HwTrq_HwNm1_fp;            // can1_dump_err_data 12   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_G2KCA_HwTrq_HwNm2_fp;            // can1_dump_err_data 13   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_G2KCA_HwTrq_HwNm3_fp;            // can1_dump_err_data 14   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile

//   C A N 2
float can2_G2KCA_BattVltg_fp;                               // can2_dump_err_data 1         Battery Voltage
float can2_G2KCA_Temperature_fp;                            // can2_dump_err_data 2         Ecu Temperature Filtered
float can2_G2KCA_DigT1_fp;                                  // can2_dump_err_data 3     Handwheel channel a trq
float can2_G2KCA_DigT2_fp;                                  // can2_dump_err_data 4     Handwheel channel b trq
float can2_G2KCA_MtrCurrQax_fp;                             // can2_dump_err_data 5         Motor Current Measurement
unsigned int can2_G2KCA_SystemState_byt;                    // can2_dump_err_data 6         System State
float can2_G2KCA_HwTrq_HwNm_fp;                             // can2_dump_err_data 7     Handwheel Tq total
float can2_G2KCA_Abs_Hw_Pos_fp;                             // can2_dump_err_data 8     Handwheel Angle ABS

float can2_G2KCA_MtrCurrQax1_fp;            // can2_dump_err_data 9    triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_G2KCA_HwTrq_HwNm1_fp;            // can2_dump_err_data 10   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_G2KCA_MtrCurrQax2_fp;            // can2_dump_err_data 11   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_G2KCA_HwTrq_HwNm2_fp;            // can2_dump_err_data 12   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_G2KCA_MtrCurrQax3_fp;            // can2_dump_err_data 13   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_G2KCA_HwTrq_HwNm3_fp;            // can2_dump_err_data 14   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile


/* ----------------  G2KCA C a l    V a r s  -----------------------------------------------  */
/* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
// cal/function storage for cal prior to string build

//   C A N  1
float cal1_G2KCA_BattVltg_fp;                                   //  1       Battery Voltage
float cal1_G2KCA_Temperature_fp;                                //  2       Ecu Temperature Filtered
float cal1_G2KCA_DigT1_fp;                                      //  3       Handwheel channel a trq
float cal1_G2KCA_DigT2_fp;                                      //  4       Handwheel channel b trq
float cal1_G2KCA_MtrCurrQax_fp;                                 //  5       Motor Current Measurement
unsigned int cal1_G2KCA_SystemState_byt;                        //  6       System State
float cal1_G2KCA_HwTrq_HwNm_fp;                                 //  7       Handwheel Tq total
float cal1_G2KCA_Abs_Hw_Pos_fp;                                 //  8       Handwheel Angle ABS


/*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */

float cal1_G2KCA_MtrCurrQax_low_pos_fp;         //  9  Motor Current Measurement
float cal1_G2KCA_MtrCurrQax_med_pos_fp;         //  10  Motor Current Measurement
float cal1_G2KCA_MtrCurrQax_high_pos_fp;        //  11  Motor Current Measurement

float cal1_G2KCA_MtrCurrQax_low_neg_fp;         //  12  Motor Current Measurement
float cal1_G2KCA_MtrCurrQax_med_neg_fp;         //  13  Motor Current Measurement
float cal1_G2KCA_MtrCurrQax_high_neg_fp;        //  14  Motor Current Measurement

float cal1_G2KCA_HwTrq_HwNm_low_pos_fp;         //  15  HW Tq total
float cal1_G2KCA_HwTrq_HwNm_med_pos_fp;         //  16  HW Tq total
float cal1_G2KCA_HwTrq_HwNm_high_pos_fp;        //  17  HW Tq total

float cal1_G2KCA_HwTrq_HwNm_low_neg_fp;         //  18  HW Tq total
float cal1_G2KCA_HwTrq_HwNm_med_neg_fp;         //  19  HW Tq total
float cal1_G2KCA_HwTrq_HwNm_high_neg_fp;        //  20  HW Tq total

float cal1_G2KCA_Batt_Current_low_pos_fp;       //  21  Battery Current
float cal1_G2KCA_Batt_Current_med_pos_fp;       //  22  Battery Current
float cal1_G2KCA_Batt_Current_high_pos_fp;      //  23  Battery Current

float cal1_G2KCA_Batt_Current_low_neg_fp;       //  24  Battery Current
float cal1_G2KCA_Batt_Current_med_neg_fp;       //  25  Battery Current
float cal1_G2KCA_Batt_Current_high_neg_fp;      //  26  Battery Current


 //   C A N   2
 float cal2_G2KCA_BattVltg_fp;                                  //  1       Battery Voltage
 float cal2_G2KCA_Temperature_fp;                               //  2       Ecu Temperature Filtered
 float cal2_G2KCA_DigT1_fp;                                     //  3       Handwheel channel a trq
 float cal2_G2KCA_DigT2_fp;                                     //  4       Handwheel channel b trq
 float cal2_G2KCA_MtrCurrQax_fp;                                //  5       Motor Current Measurement
 unsigned int cal2_G2KCA_SystemState_byt;                       //  6       System State
 float cal2_G2KCA_HwTrq_HwNm_fp;                                //  7       Handwheel Tq total
 float cal2_G2KCA_Abs_Hw_Pos_fp;                                //  8       Handwheel Angle ABS

 /*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */

 float cal2_G2KCA_MtrCurrQax_low_pos_fp;        //  9   Motor Current Measurement
 float cal2_G2KCA_MtrCurrQax_med_pos_fp;        //  10  Motor Current Measurement
 float cal2_G2KCA_MtrCurrQax_high_pos_fp;       //  11  Motor Current Measurement

 float cal2_G2KCA_MtrCurrQax_low_neg_fp;        //  12  Motor Current Measurement
 float cal2_G2KCA_MtrCurrQax_med_neg_fp;        //  13  Motor Current Measurement
 float cal2_G2KCA_MtrCurrQax_high_neg_fp;       //  14  Motor Current Measurement

 float cal2_G2KCA_HwTrq_HwNm_low_pos_fp;    //  15  HW Tq total
 float cal2_G2KCA_HwTrq_HwNm_med_pos_fp;    //  16  HW Tq total
 float cal2_G2KCA_HwTrq_HwNm_high_pos_fp;   //  17  HW Tq total

 float cal2_G2KCA_HwTrq_HwNm_low_neg_fp;    //  18  HW Tq total
 float cal2_G2KCA_HwTrq_HwNm_med_neg_fp;    //  19  HW Tq total
 float cal2_G2KCA_HwTrq_HwNm_high_neg_fp;   //  20  HW Tq total

 float cal2_G2KCA_Batt_Current_low_pos_fp;          //  21  Battery Current
 float cal2_G2KCA_Batt_Current_med_pos_fp;          //  22  Battery Current
 float cal2_G2KCA_Batt_Current_high_pos_fp;         //  23  Battery Current

 float cal2_G2KCA_Batt_Current_low_neg_fp;          //  24  Battery Current
 float cal2_G2KCA_Batt_Current_med_neg_fp;          //  25  Battery Current
 float cal2_G2KCA_Batt_Current_high_neg_fp;         //  26  Battery Current




// /* ------------ P R O D U C T   F O R D   (FORD CD391 ADAS)    D U M P E R R   V a r s -------------------------------  */
//
// // processor uses BIG Eindian (normal for TMS570) , no conversion required
//
// CAN vars used for new B_CIB style dumperr, floating point as numbers "12.41" values
//    C A N  1
float can1_FORD_BattVltg_fp;                               // can1_dump_err_data 1      Battery Voltage
float can1_FORD_Temperature_fp;                            // can1_dump_err_data 2      Ecu Temperature Filtered
float can1_FORD_DigT1_fp;                                  // can1_dump_err_data 3      Handwheel channel a trq
float can1_FORD_DigT2_fp;                                  // can1_dump_err_data 4      Handwheel channel b trq
float can1_FORD_MtrCurrQax_fp;                             // can1_dump_err_data 5      Motor Current Measurement
unsigned int can1_FORD_SystemState_byt;                    // can1_dump_err_data 6      System State
float can1_FORD_HwTrq_HwNm_fp;                             // can1_dump_err_data 7      Handwheel Tq total
float can1_FORD_Abs_Hw_Pos_fp;                             // can1_dump_err_data 8      Handwheel Angle ABS
float can1_FORD_Batt_Current_fp;                           // can1 dump_err_data 9 aquired with others, used only during cal    Battery current

int can1_FORD_LatchFail_ISR_u16;                           // can1_dump_err_data 10
int can1_FORD_MtrCntl_ISR_u16;                             // can1_dump_err_data 11
int can1_FORD_MinCount_u32;                                // can1_dump_err_data 12
int can1_FORD_MaxCount_u32;                                // can1_dump_err_data 13
int can1_FORD_CatGate_cnt;                                 // can1_dump_err_data 14

float can1_FORD_MtrCurrQax1_fp;         // can1_dump_err_data 15    triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_HwTrq_HwNm1_fp;         // can1_dump_err_data 16   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_MtrCurrQax2_fp;         // can1_dump_err_data 17   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_HwTrq_HwNm2_fp;         // can1_dump_err_data 18   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_MtrCurrQax3_fp;         // can1_dump_err_data 19   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FORD_HwTrq_HwNm3_fp;         // can1_dump_err_data 20   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile


//   C A N 2
float can2_FORD_BattVltg_fp;                               // can2_dump_err_data 1      Battery Voltage
float can2_FORD_Temperature_fp;                            // can2_dump_err_data 2      Ecu Temperature Filtered
float can2_FORD_DigT1_fp;                                  // can2_dump_err_data 3      Handwheel channel a trq
float can2_FORD_DigT2_fp;                                  // can2_dump_err_data 4      Handwheel channel b trq
float can2_FORD_MtrCurrQax_fp;                             // can2_dump_err_data 5      Motor Current Measurement
unsigned int can2_FORD_SystemState_byt;                    // can2_dump_err_data 6      System State
float can2_FORD_HwTrq_HwNm_fp;                             // can2_dump_err_data 7      Handwheel Tq total
float can2_FORD_Abs_Hw_Pos_fp;                             // can2_dump_err_data 8      Handwheel Angle ABS
float can2_FORD_Batt_Current_fp;                           // can2 dump_err_data 9 acquired with others, used only during cal   Battery current

int can2_FORD_LatchFail_ISR_u16;                           // can2_dump_err_data 10
int can2_FORD_MtrCntl_ISR_u16;                             // can2_dump_err_data 11
int can2_FORD_MinCount_u32;                                // can2_dump_err_data 12
int can2_FORD_MaxCount_u32;                                // can2_dump_err_data 13
int can2_FORD_CatGate_cnt;                                 // can2_dump_err_data 14

float can2_FORD_MtrCurrQax1_fp;         // can2_dump_err_data 15    triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_FORD_HwTrq_HwNm1_fp;         // can2_dump_err_data 16   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_FORD_MtrCurrQax2_fp;         // can2_dump_err_data 17   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_FORD_HwTrq_HwNm2_fp;         // can2_dump_err_data 18   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_FORD_MtrCurrQax3_fp;         // can2_dump_err_data 19   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_FORD_HwTrq_HwNm3_fp;         // can2_dump_err_data 20   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile



/* ----------------  FORD C a l    V a r s  -----------------------------------------------  */
/* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
// cal/function storage for cal prior to string build

//   C A N  1
float cal1_FORD_BattVltg_fp;                                //  1       Battery Voltage
float cal1_FORD_Temperature_fp;                             //  2       Ecu Temperature Filtered
float cal1_FORD_DigT1_fp;                                   //  3       Handwheel channel a trq
float cal1_FORD_DigT2_fp;                                   //  4       Handwheel channel b trq
float cal1_FORD_MtrCurrQax_fp;                              //  5       Motor Current Measurement
unsigned int cal1_FORD_SystemState_byt;                     //  6       System State
float cal1_FORD_HwTrq_HwNm_fp;                              //  7       Handwheel Tq total
float cal1_FORD_Abs_Hw_Pos_fp;                              //  8       Handwheel Angle ABS


/*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */

float cal1_FORD_MtrCurrQax_low_pos_fp;      //  9  Motor Current Measurement
float cal1_FORD_MtrCurrQax_med_pos_fp;      //  10  Motor Current Measurement
float cal1_FORD_MtrCurrQax_high_pos_fp;     //  11  Motor Current Measurement

float cal1_FORD_MtrCurrQax_low_neg_fp;      //  12  Motor Current Measurement
float cal1_FORD_MtrCurrQax_med_neg_fp;      //  13  Motor Current Measurement
float cal1_FORD_MtrCurrQax_high_neg_fp;     //  14  Motor Current Measurement

float cal1_FORD_HwTrq_HwNm_low_pos_fp;          //  15  HW Tq total
float cal1_FORD_HwTrq_HwNm_med_pos_fp;          //  16  HW Tq total
float cal1_FORD_HwTrq_HwNm_high_pos_fp;         //  17  HW Tq total

float cal1_FORD_HwTrq_HwNm_low_neg_fp;          //  18  HW Tq total
float cal1_FORD_HwTrq_HwNm_med_neg_fp;          //  19  HW Tq total
float cal1_FORD_HwTrq_HwNm_high_neg_fp;         //  20  HW Tq total

float cal1_FORD_Batt_Current_low_pos_fp;        //  21  Battery Current
float cal1_FORD_Batt_Current_med_pos_fp;        //  22  Battery Current
float cal1_FORD_Batt_Current_high_pos_fp;       //  23  Battery Current

float cal1_FORD_Batt_Current_low_neg_fp;        //  24  Battery Current
float cal1_FORD_Batt_Current_med_neg_fp;        //  25  Battery Current
float cal1_FORD_Batt_Current_high_neg_fp;       //  26  Battery Current


 //   C A N   2
 float cal2_FORD_BattVltg_fp;                                   //  1       Battery Voltage
 float cal2_FORD_Temperature_fp;                                //  2       Ecu Temperature Filtered
 float cal2_FORD_DigT1_fp;                                      //  3       Handwheel channel a trq
 float cal2_FORD_DigT2_fp;                                      //  4       Handwheel channel b trq
 float cal2_FORD_MtrCurrQax_fp;                                 //  5       Motor Current Measurement
 unsigned int cal2_FORD_SystemState_byt;                        //  6       System State
 float cal2_FORD_HwTrq_HwNm_fp;                                 //  7       Handwheel Tq total
 float cal2_FORD_Abs_Hw_Pos_fp;                                 //  8       Handwheel Angle ABS

 /*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */

 float cal2_FORD_MtrCurrQax_low_pos_fp;         //  9   Motor Current Measurement
 float cal2_FORD_MtrCurrQax_med_pos_fp;         //  10  Motor Current Measurement
 float cal2_FORD_MtrCurrQax_high_pos_fp;        //  11  Motor Current Measurement

 float cal2_FORD_MtrCurrQax_low_neg_fp;         //  12  Motor Current Measurement
 float cal2_FORD_MtrCurrQax_med_neg_fp;         //  13  Motor Current Measurement
 float cal2_FORD_MtrCurrQax_high_neg_fp;        //  14  Motor Current Measurement

 float cal2_FORD_HwTrq_HwNm_low_pos_fp;     //  15  HW Tq total
 float cal2_FORD_HwTrq_HwNm_med_pos_fp;     //  16  HW Tq total
 float cal2_FORD_HwTrq_HwNm_high_pos_fp;    //  17  HW Tq total

 float cal2_FORD_HwTrq_HwNm_low_neg_fp;     //  18  HW Tq total
 float cal2_FORD_HwTrq_HwNm_med_neg_fp;     //  19  HW Tq total
 float cal2_FORD_HwTrq_HwNm_high_neg_fp;    //  20  HW Tq total

 float cal2_FORD_Batt_Current_low_pos_fp;       //  21  Battery Current
 float cal2_FORD_Batt_Current_med_pos_fp;       //  22  Battery Current
 float cal2_FORD_Batt_Current_high_pos_fp;      //  23  Battery Current

 float cal2_FORD_Batt_Current_low_neg_fp;       //  24  Battery Current
 float cal2_FORD_Batt_Current_med_neg_fp;       //  25  Battery Current
 float cal2_FORD_Batt_Current_high_neg_fp;      //  26  Battery Current


// /* ------------ P R O D U C T   F C A  (ADAS)    D U M P E R R   V a r s -------------------------------  */
//
// // processor uses BIG Eindian (normal for TMS570) , no conversion required
//
// CAN vars used for new B_CIB style dumperr, floating point as numbers "12.41" values
//    C A N  1
float can1_FCA_BattVltg_fp;                               // can1_dump_err_data 1       Battery Voltage
float can1_FCA_Temperature_fp;                            // can1_dump_err_data 2       Ecu Temperature Filtered
float can1_FCA_DigT1_fp;                                  // can1_dump_err_data 3       Handwheel channel a trq
float can1_FCA_DigT2_fp;                                  // can1_dump_err_data 4       Handwheel channel b trq
float can1_FCA_MtrCurrQax_fp;                             // can1_dump_err_data 5       Motor Current Measurement
unsigned int can1_FCA_SystemState_byt;                    // can1_dump_err_data 6       System State
float can1_FCA_HwTrq_HwNm_fp;                             // can1_dump_err_data 7       Handwheel Tq total
float can1_FCA_Abs_Hw_Pos_fp;                             // can1_dump_err_data 8       Handwheel Angle ABS


float can1_FCA_MtrCurrQax1_fp;          // can1_dump_err_data 9    triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FCA_MtrCurrQax2_fp;          // can1_dump_err_data 10   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FCA_MtrCurrQax3_fp;          // can1_dump_err_data 11   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile

float can1_FCA_HwTrq_HwNm1_fp;          // can1_dump_err_data 12   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FCA_HwTrq_HwNm2_fp;          // can1_dump_err_data 13   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can1_FCA_HwTrq_HwNm3_fp;          // can1_dump_err_data 14   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile

//   C A N 2
float can2_FCA_BattVltg_fp;                               // can2_dump_err_data 1       Battery Voltage
float can2_FCA_Temperature_fp;                            // can2_dump_err_data 2       Ecu Temperature Filtered
float can2_FCA_DigT1_fp;                                  // can2_dump_err_data 3       Handwheel channel a trq
float can2_FCA_DigT2_fp;                                  // can2_dump_err_data 4       Handwheel channel b trq
float can2_FCA_MtrCurrQax_fp;                             // can2_dump_err_data 5       Motor Current Measurement
unsigned int can2_FCA_SystemState_byt;                    // can2_dump_err_data 6       System State
float can2_FCA_HwTrq_HwNm_fp;                             // can2_dump_err_data 7       Handwheel Tq total
float can2_FCA_Abs_Hw_Pos_fp;                             // can2_dump_err_data 8       Handwheel Angle ABS

float can2_FCA_MtrCurrQax1_fp;          // can2_dump_err_data 9    triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_FCA_MtrCurrQax2_fp;          // can2_dump_err_data 10   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_FCA_MtrCurrQax3_fp;          // can2_dump_err_data 11   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile

float can2_FCA_HwTrq_HwNm1_fp;          // can2_dump_err_data 12   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_FCA_HwTrq_HwNm2_fp;          // can2_dump_err_data 13   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can2_FCA_HwTrq_HwNm3_fp;          // can2_dump_err_data 14   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile


/* ----------------  FCA C a l    V a r s  -----------------------------------------------  */
/* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
// cal/function storage for cal prior to string build

//   C A N  1
float cal1_FCA_BattVltg_fp;                                 //  1       Battery Voltage
float cal1_FCA_Temperature_fp;                              //  2       Ecu Temperature Filtered
float cal1_FCA_DigT1_fp;                                    //  3       Handwheel channel a trq
float cal1_FCA_DigT2_fp;                                    //  4       Handwheel channel b trq
float cal1_FCA_MtrCurrQax_fp;                               //  5       Motor Current Measurement
unsigned int cal1_FCA_SystemState_byt;                      //  6       System State
float cal1_FCA_HwTrq_HwNm_fp;                               //  7       Handwheel Tq total
float cal1_FCA_Abs_Hw_Pos_fp;                               //  8       Handwheel Angle ABS

/*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */

float cal1_FCA_MtrCurrQax_low_pos_fp;       //  9  Motor Current Measurement
float cal1_FCA_MtrCurrQax_med_pos_fp;       //  10  Motor Current Measurement
float cal1_FCA_MtrCurrQax_high_pos_fp;      //  11  Motor Current Measurement

float cal1_FCA_MtrCurrQax_low_neg_fp;       //  12  Motor Current Measurement
float cal1_FCA_MtrCurrQax_med_neg_fp;       //  13  Motor Current Measurement
float cal1_FCA_MtrCurrQax_high_neg_fp;      //  14  Motor Current Measurement

float cal1_FCA_HwTrq_HwNm_low_pos_fp;       //  15  HW Tq total
float cal1_FCA_HwTrq_HwNm_med_pos_fp;       //  16  HW Tq total
float cal1_FCA_HwTrq_HwNm_high_pos_fp;      //  17  HW Tq total

float cal1_FCA_HwTrq_HwNm_low_neg_fp;       //  18  HW Tq total
float cal1_FCA_HwTrq_HwNm_med_neg_fp;       //  19  HW Tq total
float cal1_FCA_HwTrq_HwNm_high_neg_fp;      //  20  HW Tq total



 //   C A N   2
 float cal2_FCA_BattVltg_fp;                                //  1       Battery Voltage
 float cal2_FCA_Temperature_fp;                             //  2       Ecu Temperature Filtered
 float cal2_FCA_DigT1_fp;                                   //  3       Handwheel channel a trq
 float cal2_FCA_DigT2_fp;                                   //  4       Handwheel channel b trq
 float cal2_FCA_MtrCurrQax_fp;                              //  5       Motor Current Measurement
  unsigned int cal2_FCA_SystemState_byt;                        //  6       System State
 float cal2_FCA_HwTrq_HwNm_fp;                              //  7       Handwheel Tq total
 float cal2_FCA_Abs_Hw_Pos_fp;                              //  8       Handwheel Angle ABS

 /*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */

 float cal2_FCA_MtrCurrQax_low_pos_fp;      //  9   Motor Current Measurement
 float cal2_FCA_MtrCurrQax_med_pos_fp;      //  10  Motor Current Measurement
 float cal2_FCA_MtrCurrQax_high_pos_fp;     //  11  Motor Current Measurement

 float cal2_FCA_MtrCurrQax_low_neg_fp;      //  12  Motor Current Measurement
 float cal2_FCA_MtrCurrQax_med_neg_fp;      //  13  Motor Current Measurement
 float cal2_FCA_MtrCurrQax_high_neg_fp;     //  14  Motor Current Measurement

 float cal2_FCA_HwTrq_HwNm_low_pos_fp;      //  15  HW Tq total
 float cal2_FCA_HwTrq_HwNm_med_pos_fp;      //  16  HW Tq total
 float cal2_FCA_HwTrq_HwNm_high_pos_fp;     //  17  HW Tq total

 float cal2_FCA_HwTrq_HwNm_low_neg_fp;      //  18  HW Tq total
 float cal2_FCA_HwTrq_HwNm_med_neg_fp;      //  19  HW Tq total
 float cal2_FCA_HwTrq_HwNm_high_neg_fp;     //  20  HW Tq total


// /* ------------ P R O D U C T   C 1 X X   D U M P E R R   V a r s -------------------------------  */
//
// // processor uses BIG Eindian (normal for TMS570) , no conversion required
//
// CAN vars used for new B_CIB style dumperr, floating point as numbers "12.41" values

float can_C1XX_BattVltg_fp;                               // can1_dump_err_data 1       Battery Voltage
float can_C1XX_Temperature_fp;                            // can1_dump_err_data 2       Ecu Temperature Filtered
float can_C1XX_DigT1_fp;                                  // can1_dump_err_data 3       Handwheel channel a trq
float can_C1XX_DigT2_fp;                                  // can1_dump_err_data 4       Handwheel channel b trq
float can_C1XX_MtrCurrQax_fp;                             // can1_dump_err_data 5       Motor Current Measurement
unsigned int can_C1XX_OnStateFltAcc_cnt;                  // can1_dump_err_data 6       OnStateFltAcc
unsigned int can_C1XX_GateDriveFltAcc_cnt;                // can1_dump_err_data 7       GateDriveFltAcc
unsigned int can_C1XX_GateDrvFltSts_cnt;                  // can1_dump_err_data 8       GateDrvFltSts
unsigned int can_C1XX_SystemState_byt;                    // can1_dump_err_data 9       System State
float can_C1XX_HwTrq_HwNm_fp;                             // can1_dump_err_data 10      Handwheel Tq total
float can_C1XX_Abs_Hw_Pos_fp;                             // can1_dump_err_data 11      Handwheel Angle ABS
float can_C1XX_Rel_Hw_Pos_fp;                             // can1_dump_err_data 12      Handwheel Angle REL
unsigned int can_C1XX_ManualTrqCmdEn_cnt;                 // can1_dump_err_data 13      Motor Commanded Torque cnt
float can_C1XX_MtrTrq_Cmd_Nm_fp;                          // can1_dump_err_data 14      Motor Commanded Torque value
unsigned int can_C1XX_MSB_Die1_cnt;                       // can1_dump_err_data 15      Motor Position 1
unsigned int can_C1XX_MSB_Die2_cnt;                       // can1_dump_err_data 16      Motor Position 2
float can_C1XX_MtrTempEst_MagTempEst_DegC_fp;             // can1_dump_err_data 17      Motor Magnet temp



float can_C1XX_MtrCurrQax1_fp;          // can1_dump_err_data 18   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can_C1XX_MtrCurrQax2_fp;          // can1_dump_err_data 20   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can_C1XX_MtrCurrQax3_fp;          // can1_dump_err_data 22   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile

float can_C1XX_HwTrq_HwNm1_fp;          // can1_dump_err_data 19   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can_C1XX_HwTrq_HwNm2_fp;          // can1_dump_err_data 21   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
float can_C1XX_HwTrq_HwNm3_fp;          // can1_dump_err_data 23   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile


/* ----------------  C1XX C a l    V a r s  -----------------------------------------------  */
/* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
// cal/function storage for cal prior to string build

float cal_C1XX_BattVltg_fp;                                 //  1       Battery Voltage
float cal_C1XX_Temperature_fp;                              //  2       Ecu Temperature Filtered
float cal_C1XX_DigT1_fp;                                    //  3       Handwheel channel a trq
float cal_C1XX_DigT2_fp;                                    //  4       Handwheel channel b trq
float cal_C1XX_MtrCurrQax_fp;                               //  5       Motor Current Measurement
unsigned int cal_C1XX_OnStateFltAcc_cnt;                    //  6       OnStateFltAcc
unsigned int cal_C1XX_GateDriveFltAcc_cnt;                  //  7       GateDriveFltAcc
unsigned int cal_C1XX_GateDrvFltSts_cnt;                    //  8       GateDrvFltSts
unsigned int cal_C1XX_SystemState_byt;                      //  9       System State
float cal_C1XX_HwTrq_HwNm_fp;                               //  10      Handwheel Tq total
float cal_C1XX_Abs_Hw_Pos_fp;                               //  11      Handwheel Angle ABS
float cal_C1XX_Rel_Hw_Pos_fp;                               //  12      Handwheel Angle REL
unsigned int cal_C1XX_ManualTrqCmdEn_cnt;                   //  13      Motor Commanded Torque cnt
float cal_C1XX_MtrTrq_Cmd_Nm_fp;                            //  14      Motor Commanded Torque value
unsigned int cal_C1XX_MSB_Die1_cnt;                         //  15      Motor Position 1
unsigned int cal_C1XX_MSB_Die2_cnt;                         //  16      Motor Position 2
float cal_C1XX_MtrTempEst_MagTempEst_DegC_fp;               //  17      Motor Magnet temp



/*  ---  Cal-Functional storage for motor and handwheel currents at 3 levels and positive/negative values   */

float cal_C1XX_MtrCurrQax_low_pos_fp;       //  18  Motor Current Measurement
float cal_C1XX_MtrCurrQax_med_pos_fp;       //  19  Motor Current Measurement
float cal_C1XX_MtrCurrQax_high_pos_fp;      //  20  Motor Current Measurement

float cal_C1XX_MtrCurrQax_low_neg_fp;       //  21  Motor Current Measurement
float cal_C1XX_MtrCurrQax_med_neg_fp;       //  22  Motor Current Measurement
float cal_C1XX_MtrCurrQax_high_neg_fp;      //  23  Motor Current Measurement

float cal_C1XX_HwTrq_HwNm_low_pos_fp;       //  24  HW Tq total
float cal_C1XX_HwTrq_HwNm_med_pos_fp;       //  25  HW Tq total
float cal_C1XX_HwTrq_HwNm_high_pos_fp;      //  26  HW Tq total

float cal_C1XX_HwTrq_HwNm_low_neg_fp;       //  27  HW Tq total
float cal_C1XX_HwTrq_HwNm_med_neg_fp;       //  28  HW Tq total
float cal_C1XX_HwTrq_HwNm_high_neg_fp;      //  29  HW Tq total

 float cal_C1XX_MtrTrq_Cmd_Nm_low_pos_fp;   //  30  Motor Commanded Torque value
 float cal_C1XX_MtrTrq_Cmd_Nm_med_pos_fp;   //  31  Motor Commanded Torque value
 float cal_C1XX_MtrTrq_Cmd_Nm_high_pos_fp;  //  32  Motor Commanded Torque value

 float cal_C1XX_MtrTrq_Cmd_Nm_low_neg_fp;   //  33  Motor Commanded Torque value
 float cal_C1XX_MtrTrq_Cmd_Nm_med_neg_fp;   //  34  Motor Commanded Torque value
 float cal_C1XX_MtrTrq_Cmd_Nm_high_neg_fp;  //  35  Motor Commanded Torque value


// /* ------------ P R O D U C T   T 1 X X   D U M P E R R   V a r s -------------------------------  */
//
// // switch to Rensys processor uses Little Eindian, need to convert CAN data so tester TMS570 (Big Eindian) can process
//
// //unsigned char can_test_string[] = {0x1, 0x39, 0x90, 0x47, 0x41, 0x1, 0x1, 0x1};  // CAN data in Little eindian == 12.47
//
 unsigned char swap[4]; // method 1 var
// // eindian_swap[0] = can_test_string[4];eindian_swap[1] = can_test_string[3];eindian_swap[2] = can_test_string[2];eindian_swap[3] = can_test_string[1];
// // memcpy(&can_MotCurrQax_fp, junk,4);   // method1
//
// // unsigned long b0;     // eindian method 2 var
// // b0 = (can_test_string[4] << 24)+ (can_test_string[3] << 16)  + (can_test_string[2] << 8) + can_test_string[1];
// // memcpy(&can_MotCurrQax_fp, &b0,4);
//
//
// // CAN vars used for new B_CIB style dumperr, floating point as numbers "12.41" values
 unsigned int can_T1XX_SystemState_byt; // can1_dump_err_data 1     unsigned int  System State
 float can_T1XX_MotCurrQax_fp;          // can1_dump_err_data 2                   Motor Current Measurement
 float can_T1XX_HwTq0Meas_HwTq0_fp;     // can1_dump_err_data 3                   HwTq 0
 float can_T1XX_HwTq1Meas_HwTq1_fp;     // can1_dump_err_data 4                   HwTq 1
 float can_T1XX_HwTq2Meas_HwTq2_fp;     // can1_dump_err_data 5                   HwTq 2
 float can_T1XX_HwTq3Meas_HwTq3_fp;     // can1_dump_err_data 6                   HwTq 3
 float can_T1XX_EcuTFild_fp;            // can1_dump_err_data 7                   Ecu Temperature Filtered
 float can_T1XX_HwAgArbn_HwAg_fp;       // can1_dump_err_data 8                   Handwheel Angle
 float can_T1XX_HwAg0_fp;               // can1_dump_err_data 9                   10 tooth
 float can_T1XX_HwAg1_fp;               // can1_dump_err_data 10                  11 tooth
 float can_T1XX_HwTqArbn_HwTq_fp;       // can1_dump_err_data 11                  HW Tq total
 float can_T1XX_MotCurrDax_fp;          // can1_dump_err_data 12                  mtr curr dax
 float can_T1XX_HwTqArbn_HwTqChA_fp;    // can1_dump_err_data 13                  channel a trq
 float can_T1XX_HwTqArbn_HwTqChB_fp;    // can1_dump_err_data 14                  channel b trq
 float can_T1XX_MotAgCmp_fp;            // can1_dump_err_data 15                  Mechanical Motor Angle
 float can_T1XX_BattVltg_fp;            // can1_dump_err_data 16                  Battery Voltage
 float can_T1XX_BattVltgSwd1_fp;        // can1_dump_err_data 17                  Switched Battery Voltage 1
 float can_T1XX_BattVltgSwd2_fp;        // can1_dump_err_data 18                  Switched Battery Voltage 2
 float can_T1XX_BrdgVltg_fp;            // can1_dump_err_data 19                  Bridge Voltage
 float can_T1XX_AssiCmdBas_fp;          // can1_dump_err_data 20                  Assist Command Base
 float can_T1XX_MotTqCmd_fp;            // can1_dump_err_data 21                  Motor Torque Command
 float can_T1XX_AssiMechT_fp;           // can1_dump_err_data 22                  assist mech temp
 float can_T1XX_MotFetT_fp;             // can1_dump_err_data 23                  motor fet temp
 float can_T1XX_MotMagT_fp;             // can1_dump_err_data 24                  motor magnet temp
 float can_T1XX_MotWidgT_fp;            // can1_dump_err_data 25                  motor winding temp
 float can_T1XX_MotREstim_fp;           // can1_dump_err_data 26                  motor curr peak
 float can_T1XX_MotTq_fp;               // can1_dump_err_data 27                  Motor Torque

 float can_T1XX_MotCurrQax1_fp;         // can1_dump_err_data 28  triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
 float can_T1XX_MotCurrQax2_fp;         // can1_dump_err_data 30  triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
 float can_T1XX_MotCurrQax3_fp;         // can1_dump_err_data 32  triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile

 float can_T1XX_HwTqArbn_HwTq1_fp;      // can1_dump_err_data 29  triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
 float can_T1XX_HwTqArbn_HwTq2_fp;      // can1_dump_err_data 31  triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
 float can_T1XX_HwTqArbn_HwTq3_fp;      // can1_dump_err_data 33  triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
//
//
// /* ----------------  T1XX C a l    V a r s  -----------------------------------------------  */
// /* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
// // cal/function storage  for cal prior to string build
//
 float cal_T1XX_BattVltg_fp;              //  1   Batt Volt
 float cal_T1XX_BattVltgSwd1_fp;          //  2   Sensor 5Volt
 float cal_T1XX_BattVltgSwd2_fp;          //  3   Sensor 3Volt
 float cal_T1XX_EcuTFild_fp;              //  4   Prod Temp
 float cal_T1XX_MotWidgT_fp;                //  5   motor winding temp
 float cal_T1XX_HwTqArbn_HwTqChA_fp;      //  6   channel a trq
 float cal_T1XX_HwTqArbn_HwTqChB_fp;      //  7   channel b trq
 float cal_T1XX_HwTqArbn_HwTq_fp;           //  8   HW Tq total
 float cal_T1XX_HwTq0Meas_HwTq0_fp;     //  9   HwTq 0
 float cal_T1XX_HwTq1Meas_HwTq1_fp;       //  10   HwTq 1
 float cal_T1XX_HwTq2Meas_HwTq2_fp;       //  11   HwTq 2
 float cal_T1XX_HwTq3Meas_HwTq3_fp;       //  12   HwTq 3
 float cal_T1XX_HwAgArbn_HwAg_fp;         //  13   Handwheel Angle
 float cal_T1XX_HwAg0_fp;                 //  14   10 tooth
 float cal_T1XX_HwAg1_fp;                 //  15   11 tooth
 float cal_T1XX_MotTq_fp;                   //  16   Motor Torque
 float cal_T1XX_MotCurrQax_fp;            //  17   Motor Current Measurement
//
//
/*  ---  Cal-Functional storage for motor currents, HW torque and Motor Torque at 3 levels and positive/negative values   */
//
 float cal_T1XX_MotCurrQax_low_pos_fp;     //  18  Motor Current Measurement
 float cal_T1XX_MotCurrQax_med_pos_fp;     //  19  Motor Current Measurement
 float cal_T1XX_MotCurrQax_high_pos_fp;    //  20  Motor Current Measurement

 float cal_T1XX_MotCurrQax_low_neg_fp;     //  21  Motor Current Measurement
 float cal_T1XX_MotCurrQax_med_neg_fp;     //  22  Motor Current Measurement
 float cal_T1XX_MotCurrQax_high_neg_fp;    //  23  Motor Current Measurement

 float cal_T1XX_HwTqArbn_HwTq_low_pos_fp;  //  24  HW Tq total
 float cal_T1XX_HwTqArbn_HwTq_med_pos_fp;  //  25  HW Tq total
 float cal_T1XX_HwTqArbn_HwTq_high_pos_fp; //  26  HW Tq total

 float cal_T1XX_HwTqArbn_HwTq_low_neg_fp;  //  27  HW Tq total
 float cal_T1XX_HwTqArbn_HwTq_med_neg_fp;  //  28  HW Tq total
 float cal_T1XX_HwTqArbn_HwTq_high_neg_fp; //  29  HW Tq total

 float cal_T1XX_MotTq_low_pos_fp;     //  30  Motor Torque Measurement
 float cal_T1XX_MotTq_med_pos_fp;     //  31  Motor Torque Measurement
 float cal_T1XX_MotTq_high_pos_fp;    //  32  Motor Torque Measurement

 float cal_T1XX_MotTq_low_neg_fp;     //  33  Motor Torque Measurement
 float cal_T1XX_MotTq_med_neg_fp;     //  34  Motor Torque Measurement
 float cal_T1XX_MotTq_high_neg_fp;    //  35  Motor Torque Measurement
//

 //
 // CAN vars used for new B_CIB style dumperr, floating point as numbers "12.41" values
 //GWM A0607
  unsigned int can_GWM_A0607_SystemState_byt;   // can1_dump_err_data 1     unsigned int  System State
  float can_GWM_A0607_MotCurrQax_fp;           // can1_dump_err_data 2                   Motor Current Measurement
  float can_GWM_A0607_HwTq0Meas_HwTq4_fp;      // can1_dump_err_data 3                   HwTq 4
  float can_GWM_A0607_HwTq1Meas_HwTq5_fp;      // can1_dump_err_data 4                   HwTq 5
  float can_GWM_A0607_MotHwPosn_fp;            // can1_dump_err_data 5                   Motor Handwheel Position
  float can_GWM_A0607_BattVltg_fp;             // can1_dump_err_data 6                   Battery Voltage
  float can_GWM_A0607_MotTq_fp;                // can1_dump_err_data 7                   Motor Torque
  float can_GWM_A0607_HwTrq_fp;                // can1_dump_err_data 8                   Handwheel Torque
  float can_GWM_A0607_MotMagTestim_fp;         // can1_dump_err_data 9                   Motor Mag Temp Estimated
  float can_GWM_A0607_ECUTFilt_fp;             // can1_dump_err_data 10                  ECU Temp Filtered

  float can_GWM_A0607_MotCurrQax1_fp;          // can1_dump_err_data 11   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
  float can_GWM_A0607_MotCurrQax2_fp;          // can1_dump_err_data 12   triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
  float can_GWM_A0607_MotCurrQax3_fp;          // can1_dump_err_data 13  triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile

  float can_GWM_A0607_HwTqArbn_HwTq1_fp;       // can1_dump_err_data 14  triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
  float can_GWM_A0607_HwTqArbn_HwTq2_fp;       // can1_dump_err_data 15  triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
  float can_GWM_A0607_HwTqArbn_HwTq3_fp;       // can1_dump_err_data 16  triggered by RTI - if(hcurr_flag == 1) // do hcurr torque profile
 //
 //
 // /* ----------------  T1XX C a l    V a r s  -----------------------------------------------  */
 // /* Some vars are accumulated over multiple runs before transmitting, "cal_xxx" storage is created here so "can_xxx" vars can be reused in parse_can1_data()  */
 // // cal/function storage  for cal prior to string build
 //GWM A0607
  float cal_GWM_A0607_BattVltg_fp;                     //  1   Batt Volt
  float cal_GWM_A0607_SystemState_byt;                 //  2   System State
  float cal_GWM_A0607_HwTq0Meas_HwTq4_fp;              //  3   HwTq 4
  float cal_GWM_A0607_HwTq1Meas_HwTq5_fp;              //  4   HwTq 5
  float cal_GWM_A0607_MotHwPosn_fp;                    //  5   Motor Handwheel Position
  float cal_GWM_A0607_MotTq_fp;                        //  6   Motor Torque
  float cal_GWM_A0607_MotCurrQax_fp;                   //  7   Motor Current Measurement
  float cal_GWM_A0607_HwTrq_fp;                        //  8   Handwheel Torque
  float cal_GWM_A0607_MotMagTestim_fp;                 //  9   Motor Mag Temp Estimate
  float cal_GWM_A0607_ECUTFilt_fp;                     //  10  ECU Temp Filtered

 //
 //
 /*  ---  Cal-Functional storage for motor currents, HW torque and Motor Torque at 3 levels and positive/negative values   */
 //GWM A0607
  float cal_GWM_A0607_MotCurrQax_low_pos_fp;     //  9  Motor Current Measurement
  float cal_GWM_A0607_MotCurrQax_med_pos_fp;     //  10  Motor Current Measurement
  float cal_GWM_A0607_MotCurrQax_high_pos_fp;    //  11  Motor Current Measurement

  float cal_GWM_A0607_MotCurrQax_low_neg_fp;     //  12  Motor Current Measurement
  float cal_GWM_A0607_MotCurrQax_med_neg_fp;     //  13  Motor Current Measurement
  float cal_GWM_A0607_MotCurrQax_high_neg_fp;    //  14  Motor Current Measurement

  float cal_GWM_A0607_HwTqArbn_HwTq_low_pos_fp;  //  15  HW Tq total
  float cal_GWM_A0607_HwTqArbn_HwTq_med_pos_fp;  //  16  HW Tq total
  float cal_GWM_A0607_HwTqArbn_HwTq_high_pos_fp; //  17  HW Tq total

  float cal_GWM_A0607_HwTqArbn_HwTq_low_neg_fp;  //  18  HW Tq total
  float cal_GWM_A0607_HwTqArbn_HwTq_med_neg_fp;  //  19  HW Tq total
  float cal_GWM_A0607_HwTqArbn_HwTq_high_neg_fp;      //  20  HW Tq total

  float cal_GWM_A0607_MotTq_low_pos_fp;          //  21  Motor Torque Measurement
  float cal_GWM_A0607_MotTq_med_pos_fp;          //  22  Motor Torque Measurement
  float cal_GWM_A0607_MotTq_high_pos_fp;         //  23  Motor Torque Measurement

  float cal_GWM_A0607_MotTq_low_neg_fp;          //  24  Motor Torque Measurement
  float cal_GWM_A0607_MotTq_med_neg_fp;          //  25  Motor Torque Measurement
  float cal_GWM_A0607_MotTq_high_neg_fp;         //  26  Motor Torque Measurement
 //

/*  --------------   H E L P      A V A I L A B L E    ------------------------------   */
//stop_trq_switch\r\n\

char help_menu[] ={"GWM A0607 rev01 02_00_05 27JUL21\r\n\
dumperr   = dump to RTS\r\n\
p_on      = power mode on\r\n\
p_on_warm = power mode warm_init on\r\n\
p_off     = power mode off\r\n\
restartcan= restart CAN\r\n\
0p00nm\r\n\
0p10nm\r\n\
0p50nm\r\n\
1p00nm\r\n\
1p50nm\r\n\
2p00nm\r\n\
2p50nm\r\n\
3p00nm\r\n\
3p50nm\r\n\
4p00nm\r\n\
6p00nm\r\n\
empty_16\r\n\
hcurr\r\n\
clear_dtcs\r\n\
dtoa_8ch #0 #1 #2 #3 #4 #5 #6 #7\r\n\
trig\r\n\
atod_print_all times#\r\n\
vref #\r\n\
dumpver\r\n\
help  = this menu\r\n\
winit = warm init, no current output\r\n\
empty_26\r\n\
relay_on\r\n\
relay_off\r\n\
empty_29\r\n\
0>\r\n\
snap\r\n\
cal_step1 = 0.0V\r\n\
cal_step2 = 0.5V\r\n\
cal_step3 = 1.0V\r\n\
cal_step4 = 2.0V\r\n\
cal_step5 = 3.0V\r\n\
cal_step6 = 4.0V\r\n\
cal_step7 = 5.0V\r\n\
p1_on\r\n\
p2_on\r\n\
ign_on\r\n\
get_sys_state = Flexray Debugging\r\n\
set_header_variables\r\n\
get_header_variables\r\n\
start_daq_mode = #daq/xcp_fast_rate #msperiod\r\n\
stop_daq_mode\r\n\
get_daq_mode\r\n\
set_config = 0,0,10,var_list,#vars,var1,addr1,type1,..,defeat_list,x,y,z\r\n\
get_config\r\n\
enable_data_stream\r\n\
disable_data_stream\r\n\
start_ntc_mode\r\n\
stop_ntc_mode\r\n\
get_product_software\r\n\
empty_55\r\n\
cal\r\n"};


/*  --------------   C O M M A N D S    A V A I L A B L E    ------------------------------   */

const char commands[][57] = {
"dumperr",              /* 0 */
"p_on",                 /* 1 */
"p_on_warm",            /* 2 */
"p_off",                /* 3 */
"restartcan",           /* 4 */
"0p00nm",               /* 5 */
"0p10nm",               /* 6 */
"0p50nm",               /* 7 */
"1p00nm",               /* 8 */
"1p50nm",               /* 9 */
"2p00nm",               /* 10 */
"2p50nm",               /* 11 */
"3p00nm",               /* 12 */
"3p50nm",               /* 13 */
"4p00nm",               /* 14 */
"6p00nm",               /* 15 */
"empty_16",             /* 16 */
"hcurr",                /* 17 */
"clear_dtcs",           /* 18 */
"dtoa_8ch",             /* 19 */
"trig",                 /* 20 */
"atod_print_all",       /* 21 */
"vref",                 /* 22 */
"dumpver",              /* 23 */
"help",                 /* 24 */
"winit",                /* 25 */
"empty_26",             /* 26 */
"relay_on",             /* 27 */
"relay_off",            /* 28 */
"empty_29",             /* 29 */
"0>",                   /* 30 */
"snap",                 /* 31 */
"cal_step1",            /* 32 */
"cal_step2",            /* 33 */
"cal_step3",            /* 34 */
"cal_step4",            /* 35 */
"cal_step5",            /* 36 */
"cal_step6",            /* 37 */
"cal_step7",            /* 38 */
"p1_on",                /* 39 */
"p2_on",                /* 40 */
"ign_on",               /* 41 */
"get_sys_state",        /* 42 */
"set_header_variables", /* 43 */
"get_header_variables", /* 44 */
"start_daq_mode",       /* 45 */
"stop_daq_mode",        /* 46 */
"get_daq_mode",         /* 47 */
"set_config",           /* 48 */
"get_config",           /* 49 */
"enable_data_stream",   /* 50 */
"disable_data_stream",  /* 51 */
"start_ntc_mode",       /* 52 */
"stop_ntc_mode",        /* 53 */
"get_product_software", /* 54 */
"empty_55",             /* 55 */
"cal"};                 /* 56 */

#define NUM_OF_COMMANDS 57      /* number of defined commands: 0 to 56, is 57 total*/
  /* number of defined commands */



/* ---------   C A N  variables  - Global  ---------  */

/*  ------------- Compatibility with Intel CIB Code, using MESSAGE_BOXes  --------------------  */

/******************************************************************************************************************************/

// C A N 2 -- BMW FAAR WE L02 -- M T S   S T A N D system lab test stand
//70 CAN messages required
//Get it down to 64...


//Inputs into CIB to command angle and torque. Convert these into DtoA outputs.

//Feedback signals (1/5/10 Hz) (periodic outputs)

#define L02_MTS_D1_1D1_Motor_Angle_out               canMESSAGE_BOX1     // 0x1D1   11bit identifier--
#define L02_MTS_D1_2D1_Motor_Torque_out              canMESSAGE_BOX2     // 0x2D1   11bit identifier--
#define L02_MTS_D1_3D1_Motor_Current_out             canMESSAGE_BOX3     // 0x3D1   11bit identifier--
#define L02_MTS_D1_4D1_Motor_Temp_out                canMESSAGE_BOX4     // 0x4D1   11bit identifier--
#define L02_MTS_D1_5D1_Controller_Current_out        canMESSAGE_BOX5     // 0x5D1   11bit identifier--

#define L02_MTS_D2_1D2_Motor_Angle_out               canMESSAGE_BOX6     // 0x1D2   11bit identifier--
#define L02_MTS_D2_2D2_Motor_Torque_out              canMESSAGE_BOX7     // 0x2D2   11bit identifier--
#define L02_MTS_D2_3D2_Motor_Current_out             canMESSAGE_BOX8     // 0x3D2   11bit identifier--
#define L02_MTS_D2_4D2_Motor_Temp_out                canMESSAGE_BOX9     // 0x4D2   11bit identifier--
#define L02_MTS_D2_5D2_Controller_Current_out        canMESSAGE_BOX10    // 0x5D2   11bit identifier--

#define L02_MTS_D3_1D3_Motor_Angle_out               canMESSAGE_BOX11    // 0x1D3   11bit identifier--
#define L02_MTS_D3_2D3_Motor_Torque_out              canMESSAGE_BOX12    // 0x2D3   11bit identifier--
#define L02_MTS_D3_3D3_Motor_Current_out             canMESSAGE_BOX13    // 0x3D3   11bit identifier--
#define L02_MTS_D3_4D3_Motor_Temp_out                canMESSAGE_BOX14    // 0x4D3   11bit identifier--
#define L02_MTS_D3_5D3_Controller_Current_out        canMESSAGE_BOX15    // 0x5D3   11bit identifier--

#define L02_MTS_D4_1D4_Motor_Angle_out               canMESSAGE_BOX16    // 0x1D4   11bit identifier--
#define L02_MTS_D4_2D4_Motor_Torque_out              canMESSAGE_BOX17    // 0x2D4   11bit identifier--
#define L02_MTS_D4_3D4_Motor_Current_out             canMESSAGE_BOX18    // 0x3D4   11bit identifier--
#define L02_MTS_D4_4D4_Motor_Temp_out                canMESSAGE_BOX19    // 0x4D4   11bit identifier--
#define L02_MTS_D4_5D4_Controller_Current_out        canMESSAGE_BOX20    // 0x5D4   11bit identifier--

#define L02_MTS_D5_1D5_Motor_Angle_out               canMESSAGE_BOX21    // 0x1D5   11bit identifier--
#define L02_MTS_D5_2D5_Motor_Torque_out              canMESSAGE_BOX22    // 0x2D5   11bit identifier--
#define L02_MTS_D5_3D5_Motor_Current_out             canMESSAGE_BOX23    // 0x3D5   11bit identifier--
#define L02_MTS_D5_4D5_Motor_Temp_out                canMESSAGE_BOX24    // 0x4D5   11bit identifier--
#define L02_MTS_D5_5D5_Controller_Current_out        canMESSAGE_BOX25    // 0x5D5   11bit identifier--

#define L02_MTS_D6_1D6_Motor_Angle_out               canMESSAGE_BOX26    // 0x1D6   11bit identifier--
#define L02_MTS_D6_2D6_Motor_Torque_out              canMESSAGE_BOX27    // 0x2D6   11bit identifier--
#define L02_MTS_D6_3D6_Motor_Current_out             canMESSAGE_BOX28    // 0x3D6   11bit identifier--
#define L02_MTS_D6_4D6_Motor_Temp_out                canMESSAGE_BOX29    // 0x4D6   11bit identifier--
#define L02_MTS_D6_5D6_Controller_Current_out        canMESSAGE_BOX30    // 0x5D6   11bit identifier--



#define MTS_001_Vehicle_Speed_flt_in                 canMESSAGE_BOX31    // 0x001   11bit identifier--
#define L02_MTS_004_System_State_in                  canMESSAGE_BOX32    // 0x004   11bit identifier--byte[0]: 00=OFF, 02=RUN, 03=WINIT
#define L02_MTS_005_Store_DAQ_Data_Mode_in           canMESSAGE_BOX33    // 0x005   11bit identifier--01 = DAQ store 00 = DAQ NOT stored

//Plan to start DAQ mode right after p_on, but not output any data to labview until MTS stand says so.

#define L02_MTS_D1_11D_Angle_Cmd_fp_in               canMESSAGE_BOX34    // 0x11D   11bit identifier--
#define L02_MTS_D1_12D_Torque_Cmd_fp_in              canMESSAGE_BOX35    // 0x12D   11bit identifier--
#define L02_MTS_D2_21D_Angle_Cmd_fp_in               canMESSAGE_BOX36    // 0x21D   11bit identifier--
#define L02_MTS_D2_22D_Torque_Cmd_fp_in              canMESSAGE_BOX37    // 0x22D   11bit identifier--
#define L02_MTS_D3_31D_Angle_Cmd_fp_in               canMESSAGE_BOX38    // 0x31D   11bit identifier--
#define L02_MTS_D3_32D_Torque_Cmd_fp_in              canMESSAGE_BOX39    // 0x32D   11bit identifier--
#define L02_MTS_D4_41D_Angle_Cmd_fp_in               canMESSAGE_BOX40    // 0x41D   11bit identifier--
#define L02_MTS_D4_42D_Torque_Cmd_fp_in              canMESSAGE_BOX41    // 0x42D   11bit identifier--
#define L02_MTS_D5_51D_Angle_Cmd_fp_in               canMESSAGE_BOX42    // 0x51D   11bit identifier--
#define L02_MTS_D5_52D_Torque_Cmd_fp_in              canMESSAGE_BOX43    // 0x52D   11bit identifier--
#define L02_MTS_D6_61D_Angle_Cmd_fp_in               canMESSAGE_BOX44    // 0x61D   11bit identifier--
#define L02_MTS_D6_62D_Torque_Cmd_fp_in              canMESSAGE_BOX45    // 0x62D   11bit identifier--

//Fault State messages (event driven outputs)
#define L02_MTS_D1_711_General_Fault_State_out       canMESSAGE_BOX46    // 0x711   11bit identifier--
#define L02_MTS_D1_712_FET_Temp_Fault_out            canMESSAGE_BOX47    // 0x712   11bit identifier-- Set limits around this
#define L02_MTS_D1_713_Motor_Temp_Fault_out          canMESSAGE_BOX48    // 0x713   11bit identifier-- Set limits around this
#define L02_MTS_D2_721_General_Fault_State_out       canMESSAGE_BOX49    // 0x721   11bit identifier--
#define L02_MTS_D2_722_FET_Temp_Fault_out            canMESSAGE_BOX50    // 0x722   11bit identifier-- Set limits around this
#define L02_MTS_D2_723_Motor_Temp_Fault_out          canMESSAGE_BOX51    // 0x723   11bit identifier-- Set limits around this
#define L02_MTS_D3_731_General_Fault_State_out       canMESSAGE_BOX52    // 0x731   11bit identifier--
#define L02_MTS_D3_732_FET_Temp_Fault_out            canMESSAGE_BOX53    // 0x732   11bit identifier-- Set limits around this
#define L02_MTS_D3_733_Motor_Temp_Fault_out          canMESSAGE_BOX54    // 0x733   11bit identifier-- Set limits around this
#define L02_MTS_D4_741_General_Fault_State_out       canMESSAGE_BOX55    // 0x741   11bit identifier--
#define L02_MTS_D4_742_FET_Temp_Fault_out            canMESSAGE_BOX56    // 0x742   11bit identifier-- Set limits around this
#define L02_MTS_D4_743_Motor_Temp_Fault_out          canMESSAGE_BOX57    // 0x743   11bit identifier-- Set limits around this
#define L02_MTS_D5_751_General_Fault_State_out       canMESSAGE_BOX58    // 0x751   11bit identifier--
#define L02_MTS_D5_752_FET_Temp_Fault_out            canMESSAGE_BOX59    // 0x752   11bit identifier-- Set limits around this
#define L02_MTS_D5_753_Motor_Temp_Fault_out          canMESSAGE_BOX60    // 0x753   11bit identifier-- Set limits around this
#define L02_MTS_D6_761_General_Fault_State_out       canMESSAGE_BOX61    // 0x761   11bit identifier--
#define L02_MTS_D6_762_FET_Temp_Fault_out            canMESSAGE_BOX62    // 0x762   11bit identifier-- Set limits around this
#define L02_MTS_D6_763_Motor_Temp_Fault_out          canMESSAGE_BOX63    // 0x763   11bit identifier-- Set limits around this

#define MTS_7FF_MTS_Fault_in                         canMESSAGE_BOX64    // 0x7FF   11bit identifier-- Set limits around this


/******************************************************************************************************************************/
// C A N  1  --  M T O    K 2 X X and  T 1 X X     Product
#define PROD_MESS1_ID               canMESSAGE_BOX1      // 0x148    11bit identifier-- Rec T1XX Service Steering Light to EPS
#define CCP_RESPONSE_ID             canMESSAGE_BOX2      // 0x706    11bit identifier-- Rec CCP response from EPS
#define CCP_REQUEST_ID              canMESSAGE_BOX3      // 0x708    11bit identifier-- Trans CCP Request to EPS
#define CCP_SPEED_ID                canMESSAGE_BOX4      // 0x3E9    11bit identifier-- Trans Speed and Engine Status to EPS
#define CCP_ENGINE_RUN_ID           canMESSAGE_BOX5      // 0x0C9    11bit identifier-- Trans Engine Info to EPS
#define CCP_POWER_MODE_ID           canMESSAGE_BOX6      // 0x1F1    11bit identifier-- Trans Ignition Status to EPS
#define XCP_RESPONSE_ID             canMESSAGE_BOX7      // 0x642    11bit identifier-- Rec XCP Response from EPS for data
#define XCP_REQUEST_ID              canMESSAGE_BOX8      // 0x242    11bit identifier-- Trans XCP Request to EPS for data
#define DEBUG_TX_ID                 canMESSAGE_BOX9      // 0x7FF    11bit identifier-- Trans General info on buss for debugging
#define CCP_TRANSMISSION_ID         canMESSAGE_BOX10     // 0x1F5    11bit identifier-- Trans PPEI_Trans_General_Status2 to EPS

#define CCP_RIGHT_Pressure_ECHO_ID  canMESSAGE_BOX11     // 0x7F0   11bit identifier--  Trans Pressure Right echo to Test Stand
#define CCP_LEFT_Pressure_ECHO_ID   canMESSAGE_BOX12     // 0x7F1   11bit identifier--  Trans Pressure Left  echo to Test Stand

/******************************************************************************************************************************/
// C A N  1  --  R E N A U L T _ N I S S A N     Product   D. Bair
#define RENAULT_NISSAN_ECU1_CAN1_PROD_MESS1_ID          canMESSAGE_BOX1  // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define RENAULT_NISSAN_ECU1_CAN1_PROD_MESS2_ID          canMESSAGE_BOX2  // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define RENAULT_NISSAN_ECU1_CAN1_CCP_Engine_Run         canMESSAGE_BOX3  // 0x1F6   11bit identifier-- Trans Engine ON to EPS
#define RENAULT_NISSAN_ECU1_CAN1_CCP_Power_Mode_ID      canMESSAGE_BOX4  // 0x1F1   11bit identifier-- Trans Power Mode to EPS
#define RENAULT_NISSAN_ECU1_CAN1_CCP_SPEED_ID           canMESSAGE_BOX5  // 0x29A   11bit identifier-- Trans Speed to EPS
#define RENAULT_NISSAN_ECU1_CAN1_CCP_REQUEST_ID         canMESSAGE_BOX6  // 0x742   11bit identifier-- Trans CCP Request for Data to EPS
#define RENAULT_NISSAN_ECU1_CAN1_CCP_RESPONSE_ID        canMESSAGE_BOX7  // 0x762   11bit identifier-- Rec CCP Response from EPS for Data
#define RENAULT_NISSAN_ECU1_CAN1_XCP_EA3_REQUEST_ID     canMESSAGE_BOX8  // 0x242   11bit identifier-- Trans XCP Request from EPS for data (not used)
#define RENAULT_NISSAN_ECU1_CAN1_XCP_EA3_RESPONSE_ID    canMESSAGE_BOX9  // 0x642   11bit identifier-- Rec XCP Response to EPS for data (not used)
#define RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID     canMESSAGE_BOX10 // 0x750   11bit identifier-- Trans XCP Request from EPS for data
#define RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_RESPONSE_ID    canMESSAGE_BOX11 // 0x758   11bit identifier-- Rec XCP Response to EPS for data
#define RENAULT_NISSAN_TESTER_REC_DEBUG_ID              canMESSAGE_BOX12 // 0x7ff   11bit identifier-- Rec from Anyone
#define RENAULT_NISSAN_TESTER_TRANS_DEBUG_ID            canMESSAGE_BOX13 // 0x7fe   11bit identifier-- Transmit to Anyone
#define RENAULT_NISSAN_ECU1_CCP_EA4_AvgVehSpd_ID        canMESSAGE_BOX14 // 0x17D   11bit identifier-- Trans ABS message to EPS
#define RENAULT_NISSAN_ECU1_CAN1_GenericAppDiagEnble_ID canMESSAGE_BOX15 // 0x350   11bit identifier-- Trans Generic Application Diagnostic Enablr


// C A N  2  --  G M _ B   T 1 X X     Product
#define RENAULT_NISSAN_ECU1_CAN2_PROD_MESS1_ID          canMESSAGE_BOX1  // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define RENAULT_NISSAN_ECU1_CAN2_PROD_MESS2_ID          canMESSAGE_BOX2  // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define RENAULT_NISSAN_TESTER_REC_DEBUG_ID              canMESSAGE_BOX12 // 0x7ff   11bit identifier-- Rec from Anyone
#define RENAULT_NISSAN_TESTER_TRANS_DEBUG_ID            canMESSAGE_BOX13 // 0x7fe   11bit identifier-- Transmit to Anyone

/******************************************************************************************************************************/
// C A N  1  --  G M _ B   T 1 X X     Product
#define GM_B_T1XX_ECU1_CAN1_CCP_NM_Frame_ID                     canMESSAGE_BOX1       //0x145      11 bit identifier -- Trans EPSECU Wakeup to EPS (NM_Frame)
#define GM_B_T1XX_ECU1_CAN1_CCP_sysPwrMode_Prtctd_ID            canMESSAGE_BOX2       //0x380      11 bit identifier -- Trans Power Mode to EPS (sysPwrMode_Prtctd)
#define GM_B_T1XX_ECU1_CAN1_CCP_sysPwrMode_PCSM_ID              canMESSAGE_BOX3       //0x727      11 bit identifier -- Trans Authoritative counter for 0x380 (sysPwrMode_PCSM)
#define GM_B_T1XX_ECU1_CAN1_CCP_prplStat_Prtctd_ID              canMESSAGE_BOX4       //0x384      11 bit identifier -- Trans propulsion state (prplStat_Prtctd)
#define GM_B_T1XX_ECU1_CAN1_CCP_prplStat_PCSM_ID                canMESSAGE_BOX5       //0x740      11 bit identifier -- Trans Authoritative counter for propulsion state (prplStat_PCSM)
#define GM_B_T1XX_ECU1_CAN1_CCP_frntAngVel_Prtctd_ID            canMESSAGE_BOX6       //0x015      11 bit identifier -- *Trans front vehicle speed (frntAngVel_Prtctd)
#define GM_B_T1XX_ECU1_CAN1_CCP_frntAngVel_PCSM_ID              canMESSAGE_BOX7       //0x21C      11 bit identifier -- *Trans Authoritative counter for front vehicle speed (frntAngVel_PCSM)
#define GM_B_T1XX_ECU1_CAN1_CCP_rearAngVel_Prtctd_ID            canMESSAGE_BOX8       //0x017      11 bit identifier -- *Trans Rear Vehicle speed (rearAngVel_Prtctd)
#define GM_B_T1XX_ECU1_CAN1_CCP_rearAngVel_PCSM_ID              canMESSAGE_BOX9       //0x21E      11 bit identifier -- *Trans Authoritative counter for rear vehicle speed (rearAngVel_PCSM)
#define GM_B_T1XX_ECU1_CAN1_CCP_whlDst_Prtctd_ID                canMESSAGE_BOX10      //0x71E      11 bit identifier -- *Trans Wheel Distance (whlDst_Prtctd)
#define GM_B_T1XX_ECU1_CAN1_CCP_whlDst_PCSM_ID                  canMESSAGE_BOX11      //0x711      11 bit identifier -- *Trans Authoritative Counter for WHeel Distance (whlDst_PCSM)
#define GM_B_T1XX_ECU1_CAN1_CCP_vehSpdDrvn_Prtctd_ID            canMESSAGE_BOX12      //0x229      11 bit identifier -- **Trans Unprotected vehicle speed used as backup if others fail -- no authoritative counter.(vehSpdDrvn_Prtctd)
#define GM_B_T1XX_ECU1_CAN1_CCP_REQUEST_ID                      canMESSAGE_BOX13      //0x18EFF131 29 bit identifier -- Trans CCP Request to EPS for data (XCP_TX)
#define GM_B_T1XX_ECU1_CAN1_CCP_RESPONCE_ID                     canMESSAGE_BOX14      //0x18EF31F1 29 bit identifier -- Rec CCP Response from EPS for Data (XCP_RX)
#define GM_B_T1XX_ECU1_CAN1_Active_Counter_REQUEST_ID           canMESSAGE_BOX15      //0x14DA31F1 29 bit identifier -- Trans Request to EPS for Active Counters (GM_TX)
#define GM_B_T1XX_ECU1_CAN1_Active_Counter_RESPONCE_ID          canMESSAGE_BOX16      //0x14DAF131 29 bit identifier -- Rec Active Counters from EPS (GM_RX)
#define GM_B_T1XX_ECU1_CAN1_XCP_EA4_REQUEST_ID                  canMESSAGE_BOX17      //0x712      11 bit identifier -- Trans XCP Request to EPS for data (MFG_TX)
#define GM_B_T1XX_ECU1_CAN1_XCP_EA4_RESPONCE_ID                 canMESSAGE_BOX18      //0x710      11 bit identifier -- Rec XCP Response from EPS for data (MFG_RX)
#define GM_B_T1XX_ECU1_CAN1_CCP_VEH_SPD_ID                      canMESSAGE_BOX19      //0x335      11 bit identifier -- Trans main vehicle speed (VEH_SPD)

// C A N  2  --  G M _ B   T 1 X X     Product

#define TESTER_REC_DEBUG_ID   canMESSAGE_BOX1    // 0x7ff   11bit identifier-- REC from Anyone
#define TESTER_TRANS_DEBUG_ID canMESSAGE_BOX2    // 0x7fe   11bit identifier-- Transmit to Anyone

/******************************************************************************************************************************/

// C A N  1  --  F O R D   T 3  - T 6    Product
#define FORD_T3_ECU1_CAN1_PROD_MESS1_ID         canMESSAGE_BOX1    // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define FORD_T3_ECU1_CAN1_PROD_MESS2_ID         canMESSAGE_BOX2    // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define FORD_T3_ECU1_CAN1_CCP_Engine_Run        canMESSAGE_BOX3    // 0x167   11bit identifier-- Trans Engine ON to EPS
#define FORD_T3_ECU1_CAN1_CCP_Power_Mode_ID     canMESSAGE_BOX4    // 0x3B3   11bit identifier-- Trans Power Mode to EPS(not used)
#define FORD_T3_ECU1_CAN1_CCP_SPEED_ID          canMESSAGE_BOX5    // 0x415   11bit identifier-- Trans Speed to EPS with counter and CRC

#define FORD_T3_ECU1_CAN1_CCP_REQUEST_ID        canMESSAGE_BOX6    // 0x60A   11bit identifier-- Trans CCP Request for Data to EPS
#define FORD_T3_ECU1_CAN1_CCP_RESPONSE_ID       canMESSAGE_BOX7    // 0x60B   11bit identifier-- Rec CCP Response from EPS for Data
#define FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID    canMESSAGE_BOX8    // 8x730   11bit identifier-- Trans XCP Request from EPS for data
#define FORD_T3_ECU1_CAN1_XCP_EA4_RESPONSE_ID   canMESSAGE_BOX9    // 0x738   11bit identifier-- Rec XCP Response to EPS for data

#define FORD_T3_ECU2_CAN1_CCP_REQUEST_ID        canMESSAGE_BOX10   // 0x50A   11bit identifier-- Trans CCP Request for Data to EPS
#define FORD_T3_ECU2_CAN1_CCP_RESPONSE_ID       canMESSAGE_BOX11   // 0x50B   11bit identifier-- Rec CCP Response from EPS for Data
#define FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID    canMESSAGE_BOX12   // 0x630   11bit identifier-- Trans XCP Request from EPS for data
#define FORD_T3_ECU2_CAN1_XCP_EA4_RESPONSE_ID   canMESSAGE_BOX13   // 0x638   11bit identifier-- Rec XCP Response to EPS for data

#define FORD_T3_ECU1_CAN1_TESTER_REC_DEBUG_ID   canMESSAGE_BOX14   // 0x7FF   11bit identifier-- REC from Anyone
#define FORD_T3_ECU1_CAN1_TESTER_TRANS_DEBUG_ID canMESSAGE_BOX15   // 0x7FE   11bit identifier-- Transmit to Anyone

// C A N  2  --  F O R D   T 3  - T 6    Product

#define FORD_T3_ECU1_CAN2_TESTER_REC_DEBUG_ID   canMESSAGE_BOX14   // 0x7FF   11bit identifier-- REC from Anyone , no actual CAN buss, placeholder
#define FORD_T3_ECU1_CAN2_TESTER_TRANS_DEBUG_ID canMESSAGE_BOX15   // 0x7FE   11bit identifier-- Transmit to Anyone , no actual CAN buss, placeholder


/******************************************************************************************************************************/

// C A N  1  --  C N 2 0 0     N O N    A D A S   Product
#define CN200_ECU1_CAN1_PROD_MESS1_ID       canMESSAGE_BOX1  // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define CN200_ECU1_CAN1_PROD_MESS2_ID       canMESSAGE_BOX2  // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define CN200_ECU1_CAN1_CCP_Engine_Run      canMESSAGE_BOX3  // 0x0C9   11bit identifier-- Trans Engine ON to EPS
#define CN200_ECU1_CAN1_CCP_Power_Mode_ID   canMESSAGE_BOX4  // 0x1F1   11bit identifier-- Trans Power Mode to EPS
#define CN200_ECU1_CAN1_CCP_SPEED_ID        canMESSAGE_BOX5  // 0x3E9   11bit identifier-- Trans Speed to EPS

#define CN200_ECU1_CAN1_CCP_REQUEST_ID      canMESSAGE_BOX6  // 0x708   11bit identifier-- Trans CCP Request for Data to EPS
#define CN200_ECU1_CAN1_CCP_RESPONSE_ID     canMESSAGE_BOX7  // 0x706   11bit identifier-- Rec CCP Response from EPS for Data
#define CN200_ECU1_CAN1_XCP_EA3_REQUEST_ID  canMESSAGE_BOX8  // 0x242   11bit identifier-- Trans XCP Request from EPS for data (not used)
#define CN200_ECU1_CAN1_XCP_EA3_RESPONSE_ID canMESSAGE_BOX9  // 0x642   11bit identifier-- Rec XCP Response to EPS for data (not used)
#define CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID  canMESSAGE_BOX10 // 0x750   11bit identifier-- Trans XCP Request from EPS for data
#define CN200_ECU1_CAN1_XCP_EA4_RESPONSE_ID canMESSAGE_BOX11 // 0x758   11bit identifier-- Rec XCP Response to EPS for data

#define CN200_TESTER_REC_DEBUG_ID           canMESSAGE_BOX12 // 0x7ff   11bit identifier-- REC from Anyone
#define CN200_TESTER_TRANS_DEBUG_ID         canMESSAGE_BOX13 // 0x7fe   11bit identifier-- Transmit to Anyone

#define CN200_ECU1_CAN1_CCP_EA4_AvgVehSpd_ID        canMESSAGE_BOX14 // 0x17D   11bit identifier-- Trans ABS message to EPS
#define CN200_ECU1_CAN1_CCP_EA4_34A_ID      canMESSAGE_BOX15 // 0x34A   11bit identifier-- NonDriven Wheel Grnd Velocity HS (Msg ID $34A)
#define CN200_ECU1_CAN1_CCP_EA4_3E5_ID      canMESSAGE_BOX16 // 0x3E5   11bit identifier-- PPEI_Trans_Vehicle_Speed_and_Distance (Msg ID $3E5) DCT Only

#define CN200_ECU1_CAN1_CCP_EA4_348_ID      canMESSAGE_BOX17 // 0x348   11bit identifier-- NonDriven Wheel Grnd Velocity HS (Msg ID $34A)

// C A N 2  --  C N 2 0 0     N O N    A D A S  Product
#define CN200_ECU1_CAN2_PROD_MESS1_ID       canMESSAGE_BOX1  // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define CN200_ECU1_CAN2_PROD_MESS2_ID       canMESSAGE_BOX2  // 0x778   11bit identifier-- Rec ON Star from EPS (not used)

#define CN200_TESTER_REC_DEBUG_ID           canMESSAGE_BOX12 // 0x7ff   11bit identifier-- REC from Anyone
#define CN200_TESTER_TRANS_DEBUG_ID         canMESSAGE_BOX13 // 0x7fe   11bit identifier-- Transmit to Anyone

/******************************************************************************************************************************/


// C A N  1  --  G 2 K C A    A D A S   Products
#define G2KCA_ECU1_CAN1_PROD_MESS1_ID       canMESSAGE_BOX1  // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define G2KCA_ECU1_CAN1_PROD_MESS2_ID       canMESSAGE_BOX2  // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define G2KCA_ECU1_CAN1_CCP_Engine_Run      canMESSAGE_BOX3  // 0x0C9   11bit identifier-- Trans Engine ON to EPS
#define G2KCA_ECU1_CAN1_CCP_Power_Mode_ID   canMESSAGE_BOX4  // 0x1F1   11bit identifier-- Trans Power Mode to EPS
#define G2KCA_ECU1_CAN1_CCP_SPEED_ID        canMESSAGE_BOX5  // 0x3E9   11bit identifier-- Trans Speed to EPS with counter and CRC (not used)
#define G2KCA_ECU1_CAN1_CCP_Driven_ID       canMESSAGE_BOX6  // 0x348   11bit identifier-- Trans Wheel 1 Info to EPS
#define G2KCA_ECU1_CAN1_CCP_NonDriven_ID    canMESSAGE_BOX7  // 0x34A   11bit identifier-- Trans Wheel 2 Info to EPS

#define G2KCA_ECU1_CAN1_CCP_REQUEST_ID      canMESSAGE_BOX8  // 0x708   11bit identifier-- Trans CCP Request for Data to EPS
#define G2KCA_ECU1_CAN1_CCP_RESPONSE_ID     canMESSAGE_BOX9  // 0x706   11bit identifier-- Rec CCP Response from EPS for Data
#define G2KCA_ECU1_CAN1_XCP_EA3_REQUEST_ID  canMESSAGE_BOX10 // 0x242   11bit identifier-- Trans XCP Request from EPS for data (not used)
#define G2KCA_ECU1_CAN1_XCP_EA3_RESPONSE_ID canMESSAGE_BOX11 // 0x642   11bit identifier-- Rec XCP Response to EPS for data (not used)
#define G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID  canMESSAGE_BOX12 // 0x712   11bit identifier-- Trans XCP Request from EPS for data
#define G2KCA_ECU1_CAN1_XCP_EA4_RESPONSE_ID canMESSAGE_BOX13 // 0x710   11bit identifier-- Rec XCP Response to EPS for data

#define G2KCA_ECU2_CAN1_CCP_REQUEST_ID      canMESSAGE_BOX14 // 0x70C   11bit identifier-- Trans CCP Request for Data to EPS
#define G2KCA_ECU2_CAN1_CCP_RESPONSE_ID     canMESSAGE_BOX15 // 0x70A   11bit identifier-- Rec CCP Response from EPS for Data
#define G2KCA_ECU2_CAN1_XCP_EA3_REQUEST_ID  canMESSAGE_BOX16 // 0x242   11bit identifier-- Trans XCP Request from EPS for data  (not used)
#define G2KCA_ECU2_CAN1_XCP_EA3_RESPONSE_ID canMESSAGE_BOX17 // 0x642   11bit identifier-- Rec XCP Response to EPS for data  (not used)
#define G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID  canMESSAGE_BOX18 // 0x713   11bit identifier-- Trans XCP Request from EPS for data
#define G2KCA_ECU2_CAN1_XCP_EA4_RESPONSE_ID canMESSAGE_BOX19 // 0x711   11bit identifier-- Rec XCP Response to EPS for data

#define G2KCA_TESTER_REC_DEBUG_ID           canMESSAGE_BOX20 // 0x7ff   11bit identifier-- REC from Anyone
#define G2KCA_TESTER_TRANS_DEBUG_ID         canMESSAGE_BOX21 // 0x7fe   11bit identifier-- Transmit to Anyone

// C A N 2  --  G 2 K C A   A D A S   Products
#define G2KCA_ECU2_CAN2_PROD_MESS1_ID       canMESSAGE_BOX1  // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define G2KCA_ECU2_CAN2_PROD_MESS2_ID       canMESSAGE_BOX2  // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define G2KCA_ECU2_CAN2_CCP_Engine_Run      canMESSAGE_BOX3  // 0x0C9   11bit identifier-- Trans Engine ON to EPS (not used)
#define G2KCA_ECU2_CAN2_CCP_Power_Mode_ID   canMESSAGE_BOX4  // 0x1F1   11bit identifier-- Trans Power Mode to EPS(not used)
#define G2KCA_ECU2_CAN2_CCP_SPEED_ID        canMESSAGE_BOX5  // 0x3E9   11bit identifier-- Trans Speed to EPS with counter and CRC (not used)
#define G2KCA_ECU2_CAN2_CCP_Driven_ID       canMESSAGE_BOX6  // 0x348   11bit identifier-- Trans Wheel 1 Info to EPS
#define G2KCA_ECU2_CAN2_CCP_NonDriven_ID    canMESSAGE_BOX7  // 0x34A   11bit identifier-- Trans Wheel 2 Info to EPS

#define G2KCA_ECU1_CAN2_CCP_REQUEST_ID      canMESSAGE_BOX8  // 0x708   11bit identifier-- Trans CCP Request for Data to EPS (not used)
#define G2KCA_ECU1_CAN2_CCP_RESPONSE_ID     canMESSAGE_BOX9  // 0x706   11bit identifier-- Rec CCP Response from EPS for Data (not used)
#define G2KCA_ECU1_CAN2_XCP_EA3_REQUEST_ID  canMESSAGE_BOX10 // 0x242   11bit identifier-- Trans XCP Request from EPS for data (not used)
#define G2KCA_ECU1_CAN2_XCP_EA3_RESPONSE_ID canMESSAGE_BOX11 // 0x642   11bit identifier-- Rec XCP Response to EPS for data (not used)
#define G2KCA_ECU1_CAN2_XCP_EA4_REQUEST_ID  canMESSAGE_BOX12 // 0x712   11bit identifier-- Trans XCP Request from EPS for data (not used)
#define G2KCA_ECU1_CAN2_XCP_EA4_RESPONSE_ID canMESSAGE_BOX13 // 0x710   11bit identifier-- Rec XCP Response to EPS for data (not used)

#define G2KCA_ECU2_CAN2_CCP_REQUEST_ID      canMESSAGE_BOX14 // 0x70A   11bit identifier-- Trans CCP Request for Data to EPS (not used)
#define G2KCA_ECU2_CAN2_CCP_RESPONSE_ID     canMESSAGE_BOX15 // 0x70C   11bit identifier-- Rec CCP Response from EPS for Data (not used)
#define G2KCA_ECU2_CAN2_XCP_EA3_REQUEST_ID  canMESSAGE_BOX16 // 0x242   11bit identifier-- Trans XCP Request from EPS for data (not used)
#define G2KCA_ECU2_CAN2_XCP_EA3_RESPONSE_ID canMESSAGE_BOX17 // 0x642   11bit identifier-- Rec XCP Response to EPS for data (not used)
#define G2KCA_ECU2_CAN2_XCP_EA4_REQUEST_ID  canMESSAGE_BOX18 // 0x713   11bit identifier-- Trans XCP Request from EPS for data (not used)
#define G2KCA_ECU2_CAN2_XCP_EA4_RESPONSE_ID canMESSAGE_BOX19 // 0x711   11bit identifier-- Rec XCP Response to EPS for data (not used)

#define G2KCA_TESTER_REC_DEBUG_ID           canMESSAGE_BOX20 // 0x7ff   11bit identifier-- REC from Anyone
#define G2KCA_TESTER_TRANS_DEBUG_ID         canMESSAGE_BOX21 // 0x7fe   11bit identifier-- Transmit to Anyone

/******************************************************************************************************************************/

// C A N  1  --  F O R D   A D A S   Products
#define FORD_PROD_MESS1_ID        canMESSAGE_BOX1    // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define FORD_PROD_MESS2_ID        canMESSAGE_BOX2    // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define FORD_CCP_Engine_Run       canMESSAGE_BOX3    // 0x167   11bit identifier-- Trans Engine ON to EPS
#define FORD_CCP_Power_Mode_ID    canMESSAGE_BOX4    // 0x3B3   11bit identifier-- Trans Power Mode to EPS(not used)
#define FORD_CCP_SPEED_ID         canMESSAGE_BOX5    // 0x12A   11bit identifier-- Trans Speed to EPS with counter and CRC

#define FORD_CCP_RESPONSE_ID      canMESSAGE_BOX6    // 0x60B   11bit identifier-- Rec CCP Response from EPS for Data
#define FORD_CCP_REQUEST_ID       canMESSAGE_BOX7    // 0x60A   11bit identifier-- Trans CCP Request for Data to EPS
#define FORD_XCP_EA3_REQUEST_ID   canMESSAGE_BOX8    // 0x730   11bit identifier-- Trans XCP Request from EPS for data
#define FORD_XCP_EA3_RESPONSE_ID  canMESSAGE_BOX9    // 0x738   11bit identifier-- Rec XCP Response to EPS for data
#define FORD_XCP_EA4_REQUEST_ID   canMESSAGE_BOX10   // 0x712   11bit identifier-- Trans XCP Request from EPS for data (not used)
#define FORD_XCP_EA4_RESPONSE_ID  canMESSAGE_BOX11   // 0x710   11bit identifier-- Rec XCP Response to EPS for data (not used)

#define FORD_TESTER_REC_DEBUG_ID  canMESSAGE_BOX12   // 0x7ff   11bit identifier-- REC from Anyone
#define FORD_TESTER_TRANS_DEBUG_ID canMESSAGE_BOX13  // 0x7fe   11bit identifier-- Transmit to Anyone

// C A N 2  --  F O R D   A D A S   Products
#define FORD_PROD_MESS1_ID        canMESSAGE_BOX1    // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define FORD_PROD_MESS2_ID        canMESSAGE_BOX2    // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define FORD_CCP_Engine_Run_2     canMESSAGE_BOX3    // 0x60C   11bit identifier-- Trans Engine ON to EPS
#define FORD_CCP_Power_Mode_ID    canMESSAGE_BOX4    // 0x1F1   11bit identifier-- Trans Power Mode to EPS(not used)
#define FORD_CCP_SPEED_ID         canMESSAGE_BOX5    // 0x12A   11bit identifier-- Trans Speed to EPS with counter and CRC

#define FORD_CCP_RESPONSE_ID      canMESSAGE_BOX6    // 0x60B   11bit identifier-- Rec CCP Response from EPS for Data
#define FORD_CCP_REQUEST_ID       canMESSAGE_BOX7    // 0x60A   11bit identifier-- Trans CCP Request for Data to EPS
#define FORD_XCP_EA3_REQUEST_ID   canMESSAGE_BOX8    // 0x730   11bit identifier-- Trans XCP Request from EPS for data
#define FORD_XCP_EA3_RESPONSE_ID  canMESSAGE_BOX9    // 0x738   11bit identifier-- Rec XCP Response to EPS for data
#define FORD_XCP_EA4_REQUEST_ID   canMESSAGE_BOX10   // 0x712   11bit identifier-- Trans XCP Request from EPS for data (not used)
#define FORD_XCP_EA4_RESPONSE_ID  canMESSAGE_BOX11   // 0x710   11bit identifier-- Rec XCP Response to EPS for data (not used)

#define FORD_TESTER_REC_DEBUG_ID  canMESSAGE_BOX12   // 0x7ff   11bit identifier-- REC from Anyone
#define FORD_TESTER_TRANS_DEBUG_ID canMESSAGE_BOX13  // 0x7fe   11bit identifier-- Transmit to Anyone


/******************************************************************************************************************************/

// C A N  1  --  F C A   A D A S  Products
#define FCA_PROD_MESS1_ID         canMESSAGE_BOX1    // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define FCA_PROD_MESS2_ID         canMESSAGE_BOX2    // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define FCA_CCP_Engine_Run        canMESSAGE_BOX3    // 0x108   11bit identifier-- Trans Engine ON to EPS
#define FCA_CCP_Power_Mode_ID     canMESSAGE_BOX4    // 0x1F1   11bit identifier-- Trans Power Mode to EPS(not used)
#define FCA_CCP_SPEED_ID          canMESSAGE_BOX5    // 0x11C   11bit identifier-- Trans Speed to EPS with counter and CRC

#define FCA_CCP_RESPONSE_ID       canMESSAGE_BOX6    // 0x59A   11bit identifier-- Rec CCP Response from EPS for Data
#define FCA_CCP_REQUEST_ID        canMESSAGE_BOX7    // 0x6DA   11bit identifier-- Trans CCP Request for Data to EPS
#define FCA_XCP_EA3_REQUEST_ID    canMESSAGE_BOX8    // 0x75A   11bit identifier-- Trans XCP Request from EPS for data
#define FCA_XCP_EA3_RESPONSE_ID   canMESSAGE_BOX9    // 0x4DA   11bit identifier-- Rec XCP Response to EPS for data
#define FCA_XCP_EA4_REQUEST_ID    canMESSAGE_BOX10   // 0x712   11bit identifier-- Trans XCP Request from EPS for data
#define FCA_XCP_EA4_RESPONSE_ID   canMESSAGE_BOX11   // 0x710   11bit identifier-- Rec XCP Response to EPS for data

#define FCA_TESTER_REC_DEBUG_ID   canMESSAGE_BOX12   // 0x7ff   11bit identifier-- REC from Anyone
#define FCA_TESTER_TRANS_DEBUG_ID canMESSAGE_BOX13   // 0x7fe   11bit identifier-- Transmit to Anyone

// C A N 2  --  F C A   Products
#define FCA_PROD_MESS1_ID         canMESSAGE_BOX1    // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define FCA_PROD_MESS2_ID         canMESSAGE_BOX2    // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define FCA_CCP_Engine_Run        canMESSAGE_BOX3    // 0x108   11bit identifier-- Trans Engine ON to EPS
#define FCA_CCP_Power_Mode_ID     canMESSAGE_BOX4    // 0x1F1   11bit identifier-- Trans Power Mode to EPS(not used)
#define FCA_CCP_SPEED_ID          canMESSAGE_BOX5    // 0x11C   11bit identifier-- Trans Speed to EPS with counter and CRC

#define FCA_CCP_RESPONSE_ID       canMESSAGE_BOX6    // 0x59A   11bit identifier-- Rec CCP Response from EPS for Data
#define FCA_CCP_REQUEST_ID        canMESSAGE_BOX7    // 0x6DA   11bit identifier-- Trans CCP Request for Data to EPS
#define FCA_XCP_EA3_REQUEST_ID    canMESSAGE_BOX8    // 0x75A   11bit identifier-- Trans XCP Request from EPS for data
#define FCA_XCP_EA3_RESPONSE_ID   canMESSAGE_BOX9    // 0x4DA   11bit identifier-- Rec XCP Response to EPS for data
#define FCA_XCP_EA4_REQUEST_ID    canMESSAGE_BOX10   // 0x712   11bit identifier-- Trans XCP Request from EPS for data
#define FCA_XCP_EA4_RESPONSE_ID   canMESSAGE_BOX11   // 0x710   11bit identifier-- Rec XCP Response to EPS for data

#define FCA_TESTER_REC_DEBUG_ID   canMESSAGE_BOX12   // 0x7ff   11bit identifier-- REC from Anyone
#define FCA_TESTER_TRANS_DEBUG_ID canMESSAGE_BOX13   // 0x7fe   11bit identifier-- Transmit to Anyone

/******************************************************************************************************************************/

// C A N  1  --  G M   Products
#define PROD_MESS1_ID         canMESSAGE_BOX1    // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define PROD_MESS2_ID         canMESSAGE_BOX2    // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define CCP_Engine_Run        canMESSAGE_BOX3    // 0x0C9   11bit identifier-- Trans Engine ON to EPS
#define CCP_Power_Mode_ID     canMESSAGE_BOX4    // 0x1F1   11bit identifier-- Trans Power Mode to EPS
#define CCP_SPEED_ID          canMESSAGE_BOX5    // 0x348   11bit identifier-- Trans Speed to EPS

#define CCP_RESPONSE_ID       canMESSAGE_BOX6    // 0x706   11bit identifier-- Rec CCP Response from EPS for Data
#define CCP_REQUEST_ID        canMESSAGE_BOX7    // 0x708   11bit identifier-- Trans CCP Request for Data to EPS
#define XCP_EA3_REQUEST_ID    canMESSAGE_BOX8    // 0x242   11bit identifier-- Trans XCP Request from EPS for data
#define XCP_EA3_RESPONSE_ID   canMESSAGE_BOX9    // 0x642   11bit identifier-- Rec XCP Response to EPS for data
#define XCP_EA4_REQUEST_ID    canMESSAGE_BOX10   // 0x712   11bit identifier-- Trans XCP Request from EPS for data
#define XCP_EA4_RESPONSE_ID   canMESSAGE_BOX11   // 0x710   11bit identifier-- Rec XCP Response to EPS for data

#define TESTER_REC_DEBUG_ID   canMESSAGE_BOX12   // 0x7FF   11bit identifier-- REC from Anyone
#define TESTER_TRANS_DEBUG_ID canMESSAGE_BOX13   // 0x7FE   11bit identifier-- Transmit to Anyone

// C A N 2  --  G M  Products none are ADAS yet

#define CCP_CAN2_RESPONSE_ID  canMESSAGE_BOX3    // 0x642   11bit identifier-- Rec XCP Response to EPS for data
#define CCP_CAN2_REQUEST_ID   canMESSAGE_BOX4    // 0x242   11bit identifier-- Trans XCP Request from EPS for data
#define PERIOD_CAN2_ID        canMESSAGE_BOX5    // 0x182   11bit identifier-- Trans periodic to EPS

/******************************************************************************************************************************/

// C A N  1  --  G W M A 0 6 07  Products
#define PROD_MESS1_ID               canMESSAGE_BOX1    // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define PROD_MESS2_ID               canMESSAGE_BOX2    // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define CCP_Engine_Run              canMESSAGE_BOX3    // 0x271   11bit identifier-- Trans Engine ON to EPS // ECM2 (MSG ID $271)(CAN)
#define GWM_A0607_CCP_Vehspd_ID     canMESSAGE_BOX4    // 0x265   11bit identifier-- Trans Speed to EPS  // ABS3 (MSG ID $265)(CAN)
#define GWM_A0607_CCP_Endspd_ID     canMESSAGE_BOX5    // 0x348   11bit identifier-- Trans EngSpd to EPS      // ECM1 (MSG ID $111)(CAN)

#define GWM_A0607_CCP_RESPONSE_ID   canMESSAGE_BOX7    // 0x63D   11bit identifier-- Rec CCP Response from EPS for Data
#define GWM_A0607_CCP_REQUEST_ID    canMESSAGE_BOX6    // 0x63C   11bit identifier-- Trans CCP Request for Data to EPS
//#define XCP_EA3_REQUEST_ID        canMESSAGE_BOX8    // 0x242   11bit identifier-- Trans XCP Request from EPS for data
//#define XCP_EA3_RESPONSE_ID       canMESSAGE_BOX9    // 0x642   11bit identifier-- Rec XCP Response to EPS for data
#define XCP_EA4_REQUEST_ID          canMESSAGE_BOX10   // 0x712   11bit identifier-- Trans XCP Request from EPS for data
#define XCP_EA4_RESPONSE_ID         canMESSAGE_BOX11   // 0x710   11bit identifier-- Rec XCP Response to EPS for data
#define TESTER_REC_DEBUG_ID         canMESSAGE_BOX12   // 0x7FF   11bit identifier-- REC from Anyone
#define TESTER_TRANS_DEBUG_ID       canMESSAGE_BOX13   // 0x7FE   11bit identifier-- Transmit to Anyone

#define GWM_A0607_CCP_Wss_ID                canMESSAGE_BOX14    // 0x231   11bit identifier-- Trans Wss to EPS      // ABS1 (MSG ID $231) (CAN)
#define GWM_A0607_CCP_MaxEngTrqNorm_ID      canMESSAGE_BOX15    // 0x371   11bit identifier-- Trans MaxEngTrqNorm to EPS      // ECM3 (MSG ID $371) (CAN)
#define GWM_A0607_CCP_NetEngTrq_ID          canMESSAGE_BOX16    // 0x082   11bit identifier-- Trans NetEngTrq to EPS      // ECM4 (MSG ID $082) (CAN)
#define GWM_A0607_CCP_DiagFuncReq_ID        canMESSAGE_BOX17    // 0x760   11bit identifier-- Trans DiagFuncReq to EPS      // DIAG_FUN_REQ (MSG ID $760)
#define GWM_A0607_CCP_VehYawRate_ID         canMESSAGE_BOX18    // 0x245   11bit identifier-- Trans VehYawRate to EPS      // ABM2 (Msg ID $245) (CAN/CANFD)
#define GWM_A0607_CCP_SteerWheelAng_ID      canMESSAGE_BOX19    // 0x0A1   11bit identifier-- Trans SteerWheelAng to EPS      // CSA2 (Msg ID $0A1)(CAN/CANFD)

// C A N 2  --  G W M A 0 6 07  Products none are ADAS yet

//#define CCP_CAN2_RESPONSE_ID  canMESSAGE_BOX3    // 0x642   11bit identifier-- Rec XCP Response to EPS for data
//#define CCP_CAN2_REQUEST_ID   canMESSAGE_BOX4    // 0x242   11bit identifier-- Trans XCP Request from EPS for data
//#define PERIOD_CAN2_ID        canMESSAGE_BOX5    // 0x182   11bit identifier-- Trans periodic to EPS

/******************************************************************************************************************************/

// C A N  1  --  P S A    Products
#define PSA_PROD_MESS1_ID         canMESSAGE_BOX1    // 0x148   11bit identifier-- Rec Response from EPS (not used)
#define PSA_PROD_MESS2_ID         canMESSAGE_BOX2    // 0x778   11bit identifier-- Rec ON Star from EPS (not used)
#define PSA_CCP_Engine_Run        canMESSAGE_BOX3    // 0x348   11bit identifier-- Trans Engine ON to EPS
#define PSA_CCP_Power_Mode_ID     canMESSAGE_BOX4    // 0x1F1   11bit identifier-- Trans Power Mode to EPS (not used)
#define PSA_CCP_SPEED_ID          canMESSAGE_BOX5    // 0x38D   11bit identifier-- Trans Speed to EPS

#define PSA_CCP_REQUEST_ID        canMESSAGE_BOX6    // 0x7AE   11bit identifier-- Trans CCP Request for Data to EPS
#define PSA_CCP_RESPONSE_ID       canMESSAGE_BOX7    // 0x7B0   11bit identifier-- Rec CCP Response from EPS for Data
#define PSA_XCP_EA3_REQUEST_ID    canMESSAGE_BOX8    // 0x6B5   11bit identifier-- Trans XCP Request from EPS for data
#define PSA_XCP_EA3_RESPONSE_ID   canMESSAGE_BOX9    // 0x695   11bit identifier-- Rec XCP Response to EPS for data
#define PSA_XCP_EA4_REQUEST_ID    canMESSAGE_BOX10   // 0x712   11bit identifier-- Trans XCP Request from EPS for data (not used)
#define PSA_XCP_EA4_RESPONSE_ID   canMESSAGE_BOX11   // 0x710   11bit identifier-- Rec XCP Response to EPS for data (not used)

#define TESTER_REC_DEBUG_ID       canMESSAGE_BOX12   // 0x7FF   11bit identifier-- REC from Anyone
#define TESTER_TRANS_DEBUG_ID     canMESSAGE_BOX13   // 0x7FE   11bit identifier-- Transmit to Anyone

// C A N 2  --  P S A   Products none are ADAS yet

#define PSA_CCP_CAN2_RESPONSE_ID  canMESSAGE_BOX3    // 0x642   11bit identifier-- Rec XCP Response to EPS for data (not used)
#define PSA_CCP_CAN2_REQUEST_ID   canMESSAGE_BOX4    // 0x242   11bit identifier-- Trans XCP Request from EPS for data (not used)
#define PSA_PERIOD_CAN2_ID        canMESSAGE_BOX5    // 0x182   11bit identifier-- Trans periodic to EPS (not used)

/******************************************************************************************************************************/


int can1_message_type_debug;        // debug, if canMessageNotification switch does not process messageBox store box id
int can2_message_type_debug;        // debug, if canMessageNotification switch does not process messageBox store box id

int hits_on_CAN2_messageBox1;   // debug, inc each time rec is processed

uint8_t can1_rx_data[D_SIZE] = {0};     // storage for CAN rec data[D_SIZE] = {0};
uint8_t can2_rx_data[D_SIZE] = {0};     // storage for CAN rec data[D_SIZE] = {0};

uint8_t can1_tx_data[D_SIZE] = {0};     // storage for CAN trans message, incase you need to build one, like variable speed
uint8_t can2_tx_data[D_SIZE] = {0};     // storage for CAN trans message, incase you need to build one


int bus1_off_state = 0;     // bus off status 1=true 0=false reset to false after dumperr
int bus2_off_state = 0;     // flag to see if bus off triggered an interrupt in the CAN irs

int bus1_warn_state = 0;    // bus warn status 1=true 0=false reset to false after dumperr
int bus2_warn_state = 0;

int can1_stat_temp = 0;
int can2_stat_temp = 0;

int can1_request_index;     // indicates which piece of data was asked for with CCP request data
int can2_request_index;     // indicates which piece of data was asked for with CCP request data


/* Changed mind on single declare, G2KCA with both ECUs on CAN1 buss causes some timing issues with TOC, so break them out */
int ECU1_XCP_reply_index; // used for XCP response for ECU1
int ECU1_clear_DTCs_flag; // flag used in can interrupt routine to indicate clear or get DTC's on ECU1
int ECU1_dtc_loop_cnt;
int ECU1_dtc_inner_loop_cnt;

int ECU2_XCP_reply_index; // used for XCP response for ECU2
int ECU2_clear_DTCs_flag; // flag used in can interrupt routine to indicate clear or get DTC's on ECU1
int ECU2_dtc_loop_cnt;
int ECU2_dtc_inner_loop_cnt;

unsigned int CAN2_recvd_hi_word; //created for CAN2 stuff
unsigned int CAN2_recvd_lo_word; //created for CAN2 stuff

//unsigned char dtc[21][5]; // array for storing 14 to 20 DTC's with 5 bytes dtc#(2 bytes),param,status,ignition counter
unsigned char dtc1[21][5]; // ECU1 array for storing 14 to 20 DTC's with 5 bytes dtc#(2 bytes),param,status,ignition counter
unsigned char dtc2[21][5]; // ECU2 array for storing 14 to 20 DTC's with 5 bytes dtc#(2 bytes),param,status,ignition counter

uint8_t can1_dump_err_data[40][9];      // storage for CAN Response messages, must store Response and process in MAIN, error stack if sprintf called from ISR
                                        // skip [0], start at [1] easier to match
uint8_t can2_dump_err_data[40][9];      // storage for CAN Response messages, must store Response and process in MAIN, error stack if sprintf called from ISR
                                        // skip [0], start at [1] easier to match


/* --------------   T 1 X X   CAN  ------------------------ */
// CAN data for each of the CCP requests, do memcpy to CAN message obj &data
// hex Address * 2 example 0x8951 * 2 = 112A2  so CAN data byte 4 = 0xa2 byte 3 = 0x12 byte 2 = 0x01 byte 1 = 0x00
// Looks like {0x0f,0x01,0x02,0x00,0xa2,0x12,0x01,0x00}
// CAN data for each of the CCP requests, do memcpy to CAN message obj &data

    const unsigned char ccp_request_connect[]           = {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    //--------------------------------------------------------
//  const unsigned char ccp_write_PowerModeON[] =  {0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    const unsigned char ccp_write_PowerModeON[] =  {0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    const unsigned char ccp_write_PowerModeOFF[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    const unsigned char Vehicle_ready[] =  {0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00};
    const unsigned char Vehicle_not_ready[] =  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ccp_write_engine_run[]  = {0x00,0x08,0x10,0x00,0x00,0x00,0x00,0x00};
    const unsigned char ccp_write_engine_off[]  = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; // keeps product in warm Init mode
    const unsigned char ccp_write_crank_active[] = {0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; // This might be required for Crank Pulse testing/Crank Mode

        //------------------------------------------------------------
    const unsigned char ccp_write_periodic_can2[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; // CAN2 periodic message used in 9Bxx

        //------------------------------------------------------------

    const unsigned char ccp_write_0_to_speed[] = {0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00}; /* engine_on & speed 0kph 8 bytes*/
    //const unsigned char ccp_write_1_to_speed[] = {0x00,0x64,0x00,0x00,0x00,0x00,0x00,0x00}; /* engine_on & 1kph marker for all 1's- no comm */
    //const unsigned char ccp_write_2_to_speed[] = {0x00,0xC8,0x00,0x00,0x00,0x00,0x00,0x00}; /* engine_on & 2kph marker for all 0's- dump w/ign OFF */
    //const unsigned char ccp_write_3_to_speed[] = {0x01,0x2C,0x00,0x00,0x00,0x00,0x00,0x00}; /* warm_init & 3kph marker for start of OffStateVoltage */
    //const unsigned char ccp_write_4_to_speed[] = {0x01,0x90,0x00,0x00,0x00,0x00,0x00,0x00}; /* warm_init & 4kph marker for end of OffStateVoltage */

    const unsigned char ccp_write_wheel_speed[] =   {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};  // new for GM ADAS, write to both ECUs, instead of speed from Transmission


    const unsigned char xcp_write_session_Nexteer_mode[]    = {0x02,0x10,0x7E,0x00,0x00,0x00,0x00,0x00}; // open Nexteer session for manufacturing mode id242
                                                      // this must precede request for DTC's. Session times out approx after 5 seconds.
                                                      // id642 should get reply : 01 50 AA AA AA AA AA AA

/* --------------   G W M A 0 6 0 7   CAN  ------------------------ */
// Set Vehspd = 0 //ABS3 (MSG ID $265)(CAN)
    unsigned char ccp_GWM_A0607_write_Vehspd[];       /* engine_on & speed 0kph 8 bytes*/   
    unsigned char GWM_A0607_Vehspd_CRC_counter;
    unsigned char GWM_A0607_Vehspd_CRC_ChKSum;

// set EngState = 0x02 //ECM2 (MSG ID $271)(CAN)
    unsigned char ccp_GWM_A0607_write_EngState[];       /* engine_on 8 bytes*/   
    unsigned char GWM_A0607_EngState_CRC_counter;
    unsigned char GWM_A0607_EngState_CRC_ChKSum;
 //   unsigned char E2E_EngState_data_byte_array[];     /*CRC calculation & 9 bytes --[DtatID_(High byte) + DataID_(Low byte) + 7 Bytes (data_byte1~ data_byte 7)]*/  

// Set EngSpd = 0 // ECM1 (MSG ID $111)(CAN)
    const unsigned char ccp_GWM_A0607_write_EngSpd[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80}; /* EngSpd 8 bytes & EngSpdVldty(bit63) 0x1:Valid*/   

// Set Wss = 0 // ABS1 (MSG ID $231) (CAN)
    unsigned char ccp_GWM_A0607_write_Wss[];       /* Wss 8 bytes*/   
    unsigned char GWM_A0607_Wss_CRC_counter;
    unsigned char GWM_A0607_Wss_CRC_ChKSum;

// Set VehYawRate = 0  // ABM2 (Msg ID $245) (CAN/CANFD)
    unsigned char ccp_GWM_A0607_write_VehYawRate[];       /* VehYawRate 8 bytes*/   
    unsigned char GWM_A0607_VehYawRate_CRC_counter;
    unsigned char GWM_A0607_VehYawRate_CRC_ChKSum;

// Set SteerWheelAng =  // CSA2 (Msg ID $0A1)(CAN/CANFD)
    unsigned char ccp_GWM_A0607_write_SteerWheelAng[];       /* SteerWheelAng 8 bytes*/   
    unsigned char GWM_A0607_SteerWheelAng_CRC_counter;
    unsigned char GWM_A0607_SteerWheelAng_CRC_ChKSum;

// Set MaxEngTrqNorm = 0 // ECM3 (MSG ID $371) (CAN)
    unsigned char ccp_GWM_A0607_write_MaxEngTrqNorm[];       /* MaxEngTrqNorm 8 bytes*/   
    unsigned char GWM_A0607_MaxEngTrqNorm_CRC_counter;
    unsigned char GWM_A0607_MaxEngTrqNorm_CRC_ChKSum;

// Set NetEngTrq = 0 // ECM4 (MSG ID $082) (CAN)
    const unsigned char ccp_GWM_A0607_write_NetEngTrq[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; /* NetEngTrq 8 bytes & NetEngTrq = 0 */   



// ======  Manufacturing services ================

    const unsigned char xcp_EA4_write_get_DTC_rqst1[]   = {0x03,0x22,0xFD,0x60,0x00,0x00,0x00,0x00};        // EA4 format
    const unsigned char xcp_EA4_write_get_DTC_rqst2[]   = {0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00};        // no change from EA3
    const unsigned char xcp_EA4_write_clear_DTC_rqst1[] = {0x04,0x31,0x01,0xFD,0x70,0x00,0x00,0x00};        // EA4 format

    const unsigned char xcp_EA3_write_get_DTC_rqst1[]   = {0x03,0x22,0xFD,0x13,0x00,0x00,0x00,0x00};
    const unsigned char xcp_EA3_write_get_DTC_rqst2[]   = {0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    const unsigned char xcp_EA3_write_clear_DTC_rqst1[] = {0x06,0x31,0x01,0xF0,0x01,0x01,0x00,0x00};

    const unsigned char xcp_write_tester_present_msg[]  = {0x01,0x3E,0x00,0x00,0x00,0x00,0x00,0x00}; // tester present message to keep manufacturing services from timing out and stopping.

    /*      F L E X R A Y  -- services ---------------------------------  */
    const unsigned char fray_Nexteer_session1[]                         = {0x00, 0xFB, 0x30, 0x01};
    const unsigned char fray_Nexteer_session2 []                        = {0xFF, 0x7E, 0x10, 0x02};
// not used ?    const unsigned char Nexteer_Ack  []                    = {0x34, 0xFB, 0x30, 0x01};

    const unsigned char BMW_UKL_Nexteer_Ack[]                           = {0x34, 0xFB, 0x30, 0x01};

    const unsigned char fray_EA3_Get_DTC_rqst1[]                        = {0x00, 0xFB, 0x30, 0x01};
    const unsigned char fray_EA3_Get_DTC_rqst2[]                        = {0x13, 0xFD, 0x22, 0x03};

    const unsigned char BMW_FAAR_WE_Nexteer_Ack[]                       = {0xC0, 0x07, 0x00, 0x83};

    const unsigned char fray_EA4_Get_DTC_Rqst1[]                        = {0x00, 0xFB, 0x30, 0x01};
    const unsigned char fray_EA4_Get_DTC_Rqst2[]                        = {0x60, 0xFD, 0x22, 0x03};

    /*    CAN data requests for BMW UKL    22.14.01    START  ------  N O T E -- B I G    E I N D I A N   in  constant string   -------------------------*/
    //these values are copied into the 64 word flexray request variables (XCP_UKL_BATT_VOLT_Rqst, etc) in flexray.c when call initFray()

    //  M U S T   B E  Flipped for EA3 products,  has to do with FlexRay packet formation

    const unsigned char ccp_UKL_request_cal_Batt_Volt_str[]             = {0x78,0x90,0x01,0x08};  // 1     08 01 90 78     Battery Voltage
    const unsigned char ccp_UKL_request_cal_Batt_Curr_str[]             = {0xCC,0x88,0x01,0x08};  // 2     08 01 88 cc     Battery Current
    const unsigned char ccp_UKL_request_cal_Mot_Curr_str[]              = {0xE8,0x2A,0x01,0x08};  // 3     08 01 a2 e8     Motor Current Measurement
    const unsigned char ccp_UKL_request_cal_Mot_Vel_str[]               = {0xBC,0xA2,0x01,0x08};  // 4     08 01 a2 bc     Motor Velocity
    const unsigned char ccp_UKL_request_Comm_Torque_str[]               = {0x08,0xA2,0x01,0x08};  // 5     08 01 a2 08     Motor Torque Commanded
    const unsigned char ccp_UKL_request_Lim_Torque_str[]                = {0xFC,0xA1,0x01,0x08};  // 6     08 01 a1 fc     Motor Torque Limited
    const unsigned char ccp_UKL_request_PCB_Temp_str[]                  = {0x0C,0x90,0x01,0x08};  // 7     08 01 90 0c     Controller Board Temperature
    const unsigned char ccp_UKL_request_Mot_Temp_str[]                  = {0xC0,0x90,0x01,0x08};  // 8     08 01 90 c0     Motor Temperature
    const unsigned char ccp_UKL_request_Junction_Temp_str[]             = {0xBC,0x90,0x01,0x08};  // 9     08 01 90 bc     Junction Temperature
    const unsigned char ccp_UKL_request_HW_Angle_str[]                  = {0xEC,0xA1,0x01,0x08};  // 10    08 01 a1 ec     HW Angle
    const unsigned char ccp_UKL_request_Diff_Torque_str[]               = {0x30,0x90,0x01,0x08};  // 11    08 01 90 30     Differential Torque
    const unsigned char ccp_UKL_request_sys_state_byt[]                 = {0xF2,0xA3,0x01,0x08};  // 12    08 01 a3 f2     System State
    const unsigned char ccp_UKL_request_T1_Volt_str[]                   = {0x74,0x90,0x01,0x08};  // 13    08 01 90 74     T1 Volts
    const unsigned char ccp_UKL_request_T2_Volt_str[]                   = {0x78,0x90,0x01,0x08};  // 14    08 01 90 78     T2 Volts

    /*    CAN data requests for TARGET_BMW_UKL  NON-ADAS    END  -----------------------------------------------------------------*/


    /*    CAN data requests for BMW FAAR WE   01.00.07  START  ------  N O T E -- L I T T L E   E I N D I A N   in  constant string   -------------------------*/
    //these values are copied into the 64 word flexray request variables (XCP_FAAR_WE_BATT_VOLT_Rqst, etc) in flexray.c when call initFray()

    //  M U S T   N O T   B E  Flipped for EA4 products,  has to do with FlexRay packet formation

    const unsigned char ccp_FAAR_WE_SysStMod_byt[]          = {0xFE,0xBE,0xF3,0x1F};   // 1    FE BE F3 1F     System State
    const unsigned char ccp_FAAR_WE_BattVltg_BrdgVltg_str[] = {0xFE,0xBE,0xEF,0x0C};   // 2    FE BE EF 0C     Battery Voltage
    const unsigned char ccp_FAAR_WE_BattRtnCurrAmpr_str[]   = {0xFE,0xBE,0x8C,0xC0};   // 3    FE BF 8C C0     Measured Battery Current
    const unsigned char ccp_FAAR_WE_HwAgArbn_str[]          = {0xFE,0xBE,0xEF,0x24};   // 4    FE BE EF 24     Steering wheel angle
    const unsigned char ccp_FAAR_WE_HwTq4Meas_str[]         = {0xFE,0xBE,0xEF,0xC4};   // 5    FE BE EF C4     Torque Sensor T1
    const unsigned char ccp_FAAR_WE_HwTq5Meas_str[]         = {0xFE,0xBE,0xEF,0xC8};   // 6    FE BE EF C8     Torque Sensor T2
    const unsigned char ccp_FAAR_WE_HwTqArbn_str[]          = {0xFE,0xBE,0xF0,0xC8};   // 7    FE BE F0 C8     Final Input Torque
    const unsigned char ccp_FAAR_WE_MotCurrSumA_str[]       = {0xFE,0xBF,0xF0,0x34};   // 8    FE BE F0 34     Phase A Current
    const unsigned char ccp_FAAR_WE_MotCurrSumB_str[]       = {0xFE,0xBE,0xF0,0x38};   // 9    FE BE F0 38     Phase B Current
    const unsigned char ccp_FAAR_WE_MotCurrSumC_str[]       = {0xFE,0xBE,0xF0,0x3C};   // 10   FE BE F0 3C     Phase C Current
    const unsigned char ccp_FAAR_WE_MotVelCrf_str[]         = {0xFE,0xBE,0xF0,0x5C};   // 11   FE BE F0 5C     Rotor Speed
    const unsigned char ccp_FAAR_WE_MotTqCmd_str[]          = {0xFE,0xBF,0xF1,0x54};   // 12   FE BE F1 54     Requested Motor Torque
    const unsigned char ccp_FAAR_WE_MotTqEstimd_str[]       = {0xFE,0xBE,0xF1,0x50};   // 13   FE BE F1 50     Estimated Motor Torque
    const unsigned char ccp_FAAR_WE_LoaSca_str[]            = {0xFE,0xBF,0xF0,0xD8};   // 14   FE BE F0 D8     Derating Vector
    const unsigned char ccp_FAAR_WE_EcuTMeas_str[]          = {0xFE,0xBF,0x8B,0x20};   // 15   FE BF 8B 20     Board Temp
    const unsigned char ccp_FAAR_WE_MotWidgT_str[]          = {0xFE,0xBF,0x8B,0x54};   // 16   FE BF 8B 54     Estimated Motor Winding Temp
    const unsigned char ccp_FAAR_WE_MotMagT_str[]           = {0xFE,0xBF,0x8B,0x50};   // 17   FE BF 8B 50     EstimatedMagnet Temp
    const unsigned char ccp_FAAR_WE_MotFetT_str[]           = {0xFE,0xBE,0x8B,0x4C};   // 18   FE BF 8B 4C     Estimated FET Temp

//    const unsigned char ccp_FAAR_WE_MotTq_str[]             = {0xFE,0xBE,0xBE,0xB8};   // 19   fe be be b8     Motor Torque


//    const unsigned char ccp_FAAR_WE_SystemState_byt[]       = {0xFE,0xBE,0xC0,0x1F};   // 1    fe be c0 1f     System State
//    const unsigned char ccp_FAAR_WE_MtrCurrQax_str[]        = {0xFE,0xBE,0xBD,0xA4};   // 2    fe be bd a4     Motor Current Measurement
//    const unsigned char ccp_FAAR_WE_HwTq4Meas_HwTq4_str[]   = {0xFE,0xBE,0xBD,0x28};   // 3    fe be bd 28     HwTq4
//    const unsigned char ccp_FAAR_WE_HwTq5Meas_HwTq5_str[]   = {0xFE,0xBE,0xBD,0x2C};   // 4    fe be bd 2c     HwTq5
//    const unsigned char ccp_FAAR_WE_EcuTFild_str[]          = {0xFE,0xBE,0xBD,0x20};   // 5    fe be bd 20     Ecu Temperature Filtered
//    const unsigned char ccp_FAAR_WE_HwTqArbn_HwTq_str[]     = {0xFE,0xBE,0xBE,0x20};   // 6    fe be be 20     HW Tq total
//    const unsigned char ccp_FAAR_WE_MtrCurrDax_str[]        = {0xFE,0xBE,0xBD,0xA0};   // 7    fe be bd a0     mtr curr dax
//    const unsigned char ccp_FAAR_WE_MotAgCmp_str[]          = {0xFE,0xBF,0x12,0x40};   // 8    fe bf 12 40     Mechanical Motor Angle
//    const unsigned char ccp_FAAR_WE_BattVltg_str[]          = {0xFE,0xBE,0xBD,0x18};   // 9    fe be bd 18     Battery Voltage
//    const unsigned char ccp_FAAR_WE_BattVltgSwd1_str[]      = {0xFE,0xBE,0xBD,0x1C};   // 10   fe be bd 1c     Switched Battery Voltage 1
//    const unsigned char ccp_FAAR_WE_BrdgVltg_str[]          = {0xFE,0xBE,0xBC,0xC0};   // 11   fe be bc c0     Bridge Voltage
//    const unsigned char ccp_FAAR_WE_AssiCmdBas_str[]        = {0xFE,0xBF,0x22,0x78};   // 12   fe bf 22 78     Assist Command Base
//    const unsigned char ccp_FAAR_WE_MotTqCmd_str[]          = {0xFE,0xBE,0xBC,0x9C};   // 13   fe be bc 9c     Motor Torque Command
//    const unsigned char ccp_FAAR_WE_AssiMechT_str[]         = {0xFE,0xBF,0x20,0xD0};   // 14   fe bf 20 d0     assist mech temp
//    const unsigned char ccp_FAAR_WE_MotFetT_str[]           = {0xFE,0xBF,0x20,0xD8};   // 15   fe bf 20 d8     motor fet temp
//    const unsigned char ccp_FAAR_WE_MotMagT_str[]           = {0xFE,0xBF,0x20,0xDC};   // 16   fe bf 20 dc     motor magnet temp
//    const unsigned char ccp_FAAR_WE_MotWidgT_str[]          = {0xFE,0xBF,0x20,0xE0};   // 17   fe bf 20 e0     motor winding temp
//    const unsigned char ccp_FAAR_WE_MotREstim_str[]         = {0xFE,0xBE,0xBE,0x40};   // 18   fe be be 40     motor curr peak
//    const unsigned char ccp_FAAR_WE_MotTq_str[]             = {0xFE,0xBE,0xBE,0xB8};   // 19   fe be be b8     Motor Torque

    /*    CAN data requests for TARGET_BMW_FAAR_WE  NON-ADAS    END  -----------------------------------------------------------------*/


    /*    CAN data requests for RENAULT_NISSAN NON-ADAS    START  ------  N O T E -- L I T T L E   E I N D I A N   in  constant string   -------------------------*/

    unsigned char RENAULT_NISSAN_CRC_counter;
    unsigned char RENAULT_NISSAN_CRC_ChkSum;
    unsigned char RENAULT_NISSAN_write_0_to_speed[]                      = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; /* so far T3 does not use rolling speed, via array */

    const unsigned char ccp_RENAULT_NISSAN_engine_run[]                  = {0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00};     // sets system into OPERATE
    const unsigned char ccp_RENAULT_NISSAN_engine_off[]                  = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};     // keeps product in warm Init mode and required to shut off controller
    const unsigned char ccp_RENAULT_NISSAN_GenericAppDiagEnble[]         = {0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00};  // All fault reports and alerts are enabled

    const unsigned char ccp_RENAULT_NISSAN_BattVltg_str[]                = {0xF4,0x04,0x00,0x00,0xD4,0x3D,0xBE,0xFE};    // 1   0xFEBE3DD4  0xFE,0xBE,0x3D,0xD4     Battery Voltage
    const unsigned char ccp_RENAULT_NISSAN_Temperature_str[]             = {0xF4,0x04,0x00,0x00,0x9C,0x3E,0xBE,0xFE};    // 2   0xFEBE3E9C  0xFE,0xBE,0x3E,0x9C     Ecu Temperature Filtered
    const unsigned char ccp_RENAULT_NISSAN_DigT1_str[]                   = {0xF4,0x04,0x00,0x00,0x08,0x3E,0xBE,0xFE};    // 3   0xFEBE3E08  0xFE,0xBE,0x3E,0x08     HwTq 0
    const unsigned char ccp_RENAULT_NISSAN_DigT2_str[]                   = {0xF4,0x04,0x00,0x00,0x0C,0x3E,0xBE,0xFE};    // 4   0xFEBE3E0C  0xFE,0xBE,0x3E,0x0C     HwTq 1
    const unsigned char ccp_RENAULT_NISSAN_MtrCurrQax_str[]              = {0xF4,0x04,0x00,0x00,0x34,0x3E,0xBE,0xFE};    // 5   0xFEBE3E34  0xFE,0xBE,0x3E,0x34     Motor Current Measurement
    const unsigned char ccp_RENAULT_NISSAN_SystemState_byt[]             = {0xF4,0x01,0x00,0x00,0x22,0x41,0xBE,0xFE};    // 6   0xFEBE4122  0xFE,0xBE,0x41,0x22     System State
    const unsigned char ccp_RENAULT_NISSAN_HwTrq_HwNm_str[]              = {0xF4,0x04,0x00,0x00,0x14,0x3F,0xBE,0xFE};    // 7   0xFEBE3F14  0xFE,0xBE,0x3F,0x14     Handwheel Tq total
    const unsigned char ccp_RENAULT_NISSAN_Abs_Hw_Pos_str[]              = {0xF4,0x04,0x00,0x00,0xDC,0x3E,0xBE,0xFE};    // 8   0xFEBE3EDC  0xFE,0xBE,0x3E,0xDC     Handwheel Angle
    const unsigned char ccp_RENAULT_NISSAN_MotTrq_Crf_str[]              = {0xF4,0x04,0x00,0x00,0x7C,0x3F,0xBE,0xFE};    // 9   0xFEBE3F7C  0xFE,0xBE,0x3F,0x7C     Motor Torque Crf
    const unsigned char ccp_RENAULT_NISSAN_MotTrq_Mrf_str[]              = {0xF4,0x04,0x00,0x00,0x80,0x3F,0xBE,0xFE};    // 10  0xFEBE3F80  0xFE,0xBE,0x3F 0x80     Motor Torque Mrf
    const unsigned char ccp_RENAULT_NISSAN_VehSpd_str[]                  = {0xF4,0x04,0x00,0x00,0x40,0x40,0xBE,0xFE};    // 11  0xFEBE4040  0xFE,0xBE,0x40 0x40     Vehicle Speed
    const unsigned char ccp_RENAULT_NISSAN_Spare2_str[]                  = {0xF4,0x04,0x00,0x00,0x40,0x40,0xBE,0xFE};    // 12  0xFEBE4040  0xFE,0xBE,0x40 0x40     Spair2

    /*    CAN data requests for RENAULT_NISSAN  NON-ADAS    END  -----------------------------------------------------------------*/


    /*    CAN data requests for FORD T3 - T6     START  ------  N O T E -- L I T T L E   E I N D I A N   in  constant string   -------------------------*/

    const unsigned char ccp_FORD_T3_engine_run[]   = {0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00};     // sets system into OPERATE
    const unsigned char ccp_FORD_T3_engine_off[]   = {0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00};     // keeps product in warm Init mode and required to shut off controller
    const unsigned char ccp_FORD_T3_write_0_to_speed[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; /* so far T3 does not use rolling speed, via array */


    const unsigned char ccp_FORD_T3_ECU1_BattVltg_str[]                = {0xF4,0x04,0x00,0x00,0x40,0xFB,0xBE,0xFE};    // 1    0xFEBEFB40 0xFE,0xBE,0xFB,0x40     Battery Voltage
    const unsigned char ccp_FORD_T3_ECU1_Temperature_str[]             = {0xF4,0x04,0x00,0x00,0x60,0xFC,0xBE,0xFE};    // 2    0xFEBEFC60 0xFE,0xBE,0xFC,0x60     Ecu Temperature Filtered
    const unsigned char ccp_FORD_T3_ECU1_DigT1_str[]                   = {0xF4,0x04,0x00,0x00,0x68,0xFB,0xBE,0xFE};    // 3    0xFEBEFB68 0xFE,0xBE,0xFB,0x68     Handwheel channel a trq
    const unsigned char ccp_FORD_T3_ECU1_DigT2_str[]                   = {0xF4,0x04,0x00,0x00,0x74,0xFB,0xBE,0xFE};    // 4    0xFEBEFB74 0xFE,0xBE,0xFB,0x74     Handwheel channel b trq
    const unsigned char ccp_FORD_T3_ECU1_MtrCurrQax_str[]              = {0xF4,0x04,0x00,0x00,0xD8,0xFB,0xBE,0xFE};    // 5    0xFEBEFBD8 0xFE,0xBE,0xFB,0xD8     Motor Current Measurement
    const unsigned char ccp_FORD_T3_ECU1_SystemState_byt[]             = {0xF4,0x01,0x00,0x00,0xFC,0xFF,0xBE,0xFE};    // 6    0xFEBEFFFC 0xFE,0xBE,0xFF,0xFC     System State
    const unsigned char ccp_FORD_T3_ECU1_HwTrq_HwNm_str[]              = {0xF4,0x04,0x00,0x00,0x08,0xFD,0xBE,0xFE};    // 7    0xFEBEFD08 0xFE,0xBE,0xFD,0x08     Handwheel Tq total
    const unsigned char ccp_FORD_T3_ECU1_Abs_Hw_Pos_str[]              = {0xF4,0x04,0x00,0x00,0xC4,0xFC,0xBE,0xFE};    // 8    0xFEBEFCC4 0xFE,0xBE,0xFC,0xC4     Handwheel Angle ABS

    const unsigned char ccp_FORD_T3_ECU2_BattVltg_str[]                = {0xF4,0x04,0x00,0x00,0x40,0xFB,0xBE,0xFE};    // 1    0xFEBEFB40 0xFE,0xBE,0xFB,0x40     Battery Voltage
    const unsigned char ccp_FORD_T3_ECU2_Temperature_str[]             = {0xF4,0x04,0x00,0x00,0x60,0xFC,0xBE,0xFE};    // 2    0xFEBEFC60 0xFE,0xBE,0xFC,0x60     Ecu Temperature Filtered
    const unsigned char ccp_FORD_T3_ECU2_DigT1_str[]                   = {0xF4,0x04,0x00,0x00,0x68,0xFB,0xBE,0xFE};    // 3    0xFEBEFB68 0xFE,0xBE,0xFB,0x68     Handwheel channel a trq
    const unsigned char ccp_FORD_T3_ECU2_DigT2_str[]                   = {0xF4,0x04,0x00,0x00,0x74,0xFB,0xBE,0xFE};    // 4    0xFEBEFB74 0xFE,0xBE,0xFB,0x74     Handwheel channel b trq
    const unsigned char ccp_FORD_T3_ECU2_MtrCurrQax_str[]              = {0xF4,0x04,0x00,0x00,0xD8,0xFB,0xBE,0xFE};    // 5    0xFEBEFBD8 0xFE,0xBE,0xFB,0xD8     Motor Current Measurement
    const unsigned char ccp_FORD_T3_ECU2_SystemState_byt[]             = {0xF4,0x01,0x00,0x00,0xFC,0xFF,0xBE,0xFE};    // 6    0xFEBEFFFC 0xFE,0xBE,0xFF,0xFC     System State
    const unsigned char ccp_FORD_T3_ECU2_HwTrq_HwNm_str[]              = {0xF4,0x04,0x00,0x00,0x08,0xFD,0xBE,0xFE};    // 7    0xFEBEFD08 0xFE,0xBE,0xFD,0xE8     Handwheel Tq total
    const unsigned char ccp_FORD_T3_ECU2_Abs_Hw_Pos_str[]              = {0xF4,0x04,0x00,0x00,0xC4,0xFC,0xBE,0xFE};    // 8    0xFEBEFCC4 0xFE,0xBE,0xFC,0xC4     Handwheel Angle ABS

    /*    CAN data requests for FORD T3 - T6    END  -----------------------------------------------------------------*/


    /*    CAN data requests for CN200 NON-ADAS    START  ------  N O T E -- L I T T L E   E I N D I A N   in  constant string   -------------------------*/

    const unsigned char ccp_CN200_BattVltg_str[]                = {0xF4,0x04,0x00,0x00,0x40,0x41,0xBE,0xFE};    // 1   0xfebe4140  0xFE,0xBE,0x41,0x40     Battery Voltage
    const unsigned char ccp_CN200_Temperature_str[]             = {0xF4,0x04,0x00,0x00,0xD8,0x41,0xBE,0xFE};    // 2   0xfebe41d8  0xFE,0xBE,0x41,0xD8     Ecu Temperature Filtered
    const unsigned char ccp_CN200_DigT1_str[]                   = {0xF4,0x04,0x00,0x00,0x74,0x41,0xBE,0xFE};    // 3   0xfebe4174  0xFE,0xBE,0x41,0x74     HwTq 0
    const unsigned char ccp_CN200_DigT2_str[]                   = {0xF4,0x04,0x00,0x00,0x78,0x41,0xBE,0xFE};    // 4   0xfebe4178  0xFE,0xBE,0x41,0x78     HwTq 1
    const unsigned char ccp_CN200_MtrCurrQax_str[]              = {0xF4,0x04,0x00,0x00,0x98,0x41,0xBE,0xFE};    // 5   0xfebe4198  0xFE,0xBE,0x41,0x98     Motor Current Measurement
    const unsigned char ccp_CN200_SystemState_byt[]             = {0xF4,0x01,0x00,0x00,0xA5,0x43,0xBE,0xFE};    // 6   0xfebe43a5  0xFE,0xBE,0x43,0xA5     System State
    const unsigned char ccp_CN200_HwTrq_HwNm_str[]              = {0xF4,0x04,0x00,0x00,0x20,0x42,0xBE,0xFE};    // 7   0xfebe4220  0xFE,0xBE,0x42,0x20     Handwheel Tq total
    const unsigned char ccp_CN200_Abs_Hw_Pos_str[]              = {0xF4,0x04,0x00,0x00,0x00,0x42,0xBE,0xFE};    // 8   0xfebe4200  0xFE,0xBE,0x42,0x00     Handwheel Angle
    const unsigned char ccp_CN200_MotTrq_Crf_str[]              = {0xF4,0x04,0x00,0x00,0x74,0x42,0xBE,0xFE};    // 9   0xfebe4274  0xFE,0xBE,0x42,0x74     Motor Torque Crf
    const unsigned char ccp_CN200_MotTrq_Mrf_str[]              = {0xF4,0x04,0x00,0x00,0x38,0x41,0xBE,0xFE};    // 10  0xfebe4138  0xFE,0xBE,0x41 0x38     Motor Torque Mrf
    const unsigned char ccp_CN200_VehSpd_str[]                  = {0xF4,0x04,0x00,0x00,0xF4,0x42,0xBE,0xFE};    // 11  0xfebe42f4  0xFE,0xBE,0x42 0xF4     Vehicle Speed
    const unsigned char ccp_CN200_Spare2_str[]                  = {0xF4,0x04,0x00,0x00,0xFe,0x42,0xBE,0xFE};    // 12  0xfebe42f4  0xFE,0xBE,0x42 0xF4     Spair2
    //_Rte_AssiSumLim_MotTqCmd_Val febe4138

    /*    CAN data requests for CN200  NON-ADAS    END  -----------------------------------------------------------------*/

    /*    CAN data requests for PSA_CMP    START  ------  N O T E -- B I G    E I N D I A N   in  constant string    -------------------------*/

    const unsigned char ccp_PSA_CMP_write_engine_locked[]   = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    const unsigned char ccp_PSA_CMP_write_engine_cut[]      = {0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00};
    const unsigned char ccp_PSA_CMP_write_engine_start[]    = {0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00};
    const unsigned char ccp_PSA_CMP_write_engine_run[]      = {0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00};
    const unsigned char ccp_PSA_CMP_write_engine_stop[]     = {0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00};

    const unsigned char ccp_PSA_CMP_BattVltg_str[]               = {0xF4,0x04,0x00,0x00,0x08,0x01,0xE4,0x78};    // 1    0x08,0x01,0xE4,0x78     Battery Voltage
    const unsigned char ccp_PSA_CMP_Temperature_str[]            = {0xF4,0x04,0x00,0x00,0x08,0x01,0xF1,0x58};    // 2    0x08,0x01,0xF1,0x58     Ecu Temperature Filtered
    const unsigned char ccp_PSA_CMP_DigT1_str[]                  = {0xF4,0x04,0x00,0x00,0x08,0x01,0xE5,0x28};    // 3    0x08,0x01,0xE5,0x28     Handwheel channel a trq
    const unsigned char ccp_PSA_CMP_DigT2_str[]                  = {0xF4,0x04,0x00,0x00,0x08,0x01,0xE5,0x30};    // 4    0x08,0x01,0xE5,0x30     Handwheel channel b trq
    const unsigned char ccp_PSA_CMP_SystemState_byt[]            = {0xF4,0x01,0x00,0x00,0x08,0x01,0xC8,0xA4};    // 5    0x08,0x01,0xD4,0xCC     System State
    const unsigned char ccp_PSA_CMP_MtrCurrQax_str[]             = {0xF4,0x04,0x00,0x00,0x08,0x01,0xE4,0xD8};    // 6    0x08,0x00,0xE4,0xD8     Motor Current Measurement
    const unsigned char ccp_PSA_CMP_MtrCurrDax_str[]             = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC6,0x7C};    // 7    0x08,0x00,0xC6,0x7C     Motor Current Measurement
    const unsigned char ccp_PSA_CMP_HwTrq_HwNm_str[]             = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC6,0xE8};    // 8    0x08,0x00,0xC6,0xE8     Handwheel Tq total
    const unsigned char ccp_PSA_CMP_MtrTrqCmd_HwNm_str[]         = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC6,0x68};    // 9    0x08,0x01,0xC6,0x68     Motor Tq Commanded
    const unsigned char ccp_PSA_CMP_AstMtrTrq_HwNm_str[]         = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC8,0x2C};    // 10   0x08,0x01,0xC8,0x2C     Motor Tq Assist
    const unsigned char ccp_PSA_CMP_Abs_Hw_Pos_str[]             = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC8,0x30};    // 11   0x08,0x01,0xC8,0x30     Handwheel Abs Position
    const unsigned char ccp_PSA_CMP_Rel_Hw_Pos_str[]             = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC6,0x28};    // 12   0x08,0x01,0xC6,0x28     Handwheel Rel Position
    const unsigned char ccp_PSA_CMP_Abs_Hw_Pos_Valid_byt[]       = {0xF4,0x01,0x00,0x00,0x08,0x01,0xC8,0x34};    // 13   0x08,0x01,0xC8,0x34     Handwheel Position Valid
    const unsigned char ccp_PSA_CMP_MtrPos_str[]                 = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC6,0xC8};    // 14   0x08,0x01,0xC6,0xC8     Motor Position
    const unsigned char ccp_PSA_CMP_ADC_MtrCurr1_str[]           = {0xF4,0x04,0x00,0x00,0x08,0x01,0xE4,0x80};    // 15   0x08,0x01,0xE4,0x80     Motor current ADC 1
    const unsigned char ccp_PSA_CMP_ADC_MtrCurr2_str[]           = {0xF4,0x04,0x00,0x00,0x08,0x01,0xE4,0x84};    // 16   0x08,0x01,0xE4,0x84     Motor current ADC2

    /*    CAN data requests for PSA_CMP    END  -----------------------------------------------------------------*/



    /*    CAN data requests for G2KCA ADAS    START  ------  N O T E -- L I T T L E   E I N D I A N   in  constant string   -------------------------*/

    const unsigned char ccp_G2KCA_BattVltg_str[]                = {0xF4,0x04,0x00,0x00,0xD0,0xA8,0xBE,0xFE};    // 1    0xFE,0xBE,0xA8,0xD0     Battery Voltage
    const unsigned char ccp_G2KCA_Temperature_str[]             = {0xF4,0x04,0x00,0x00,0xD4,0xA9,0xBE,0xFE};    // 2    0xFE,0xBE,0xA9,0xD4     Ecu Temperature Filtered
    const unsigned char ccp_G2KCA_DigT1_str[]                   = {0xF4,0x04,0x00,0x00,0x90,0xAA,0xBE,0xFE};    // 3    0xFE,0xBE,0xAA,0x90     Handwheel channel a trq
    const unsigned char ccp_G2KCA_DigT2_str[]                   = {0xF4,0x04,0x00,0x00,0x94,0xAA,0xBE,0xFE};    // 4    0xFE,0xBE,0xAA,0x94     Handwheel channel b trq
    const unsigned char ccp_G2KCA_MtrCurrQax_str[]              = {0xF4,0x04,0x00,0x00,0x6C,0xA9,0xBE,0xFE};    // 5    0xFE,0xBE,0xA9,0x6C     Motor Current Measurement
    const unsigned char ccp_G2KCA_SystemState_byt[]             = {0xF4,0x01,0x00,0x00,0x1F,0xAD,0xBE,0xFE};    // 6    0xFE,0xBE,0xAD,0x1F     System State
    const unsigned char ccp_G2KCA_HwTrq_HwNm_str[]              = {0xF4,0x04,0x00,0x00,0x8C,0xAA,0xBE,0xFE};    // 7    0xFE,0xBE,0xAA,0x8C     Handwheel Tq total
    const unsigned char ccp_G2KCA_Abs_Hw_Pos_str[]              = {0xF4,0x04,0x00,0x00,0x50,0xAA,0xBE,0xFE};    // 8    0xFE,0xBE,0xAA,0x50     Handwheel Angle ABS


    /*    CAN data requests for G2KCA ADAS    END  -----------------------------------------------------------------*/


    /*    CAN data requests for C1XX    START  ------   -------------------------*/

    const unsigned char ccp_C1XX_BattVltg_str[]                 = {0xF4,0x04,0x00,0x00,0x08,0x01,0x77,0xAC};    // 1    0x08,0x01,0x77,0xAC     Battery Voltage
    const unsigned char ccp_C1XX_Temperature_str[]              = {0xF4,0x04,0x00,0x00,0x08,0x01,0x77,0xB4};    // 2    0x08,0x01,0x77,0xB4     Ecu Temperature Filtered
    const unsigned char ccp_C1XX_DigT1_str[]                    = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0x7C};    // 3    0x08,0x01,0x81,0x7C     Handwheel channel a trq
    const unsigned char ccp_C1XX_DigT2_str[]                    = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0x80};    // 4    0x08,0x01,0x81,0x80     Handwheel channel b trq
    const unsigned char ccp_C1XX_MtrCurrQax_str[]               = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0x50};    // 5    0x08,0x01,0x81,0x50     Motor Current Measurement
    const unsigned char ccp_C1XX_OnStateFltAcc_cnt[]            = {0xF4,0x02,0x00,0x00,0x08,0x00,0x6B,0x24};    // 6    0x08,0x00,0x6B,0x24     OnStateFltAcc
    const unsigned char ccp_C1XX_GateDriveFltAcc_cnt[]          = {0xF4,0x02,0x00,0x00,0x08,0x00,0x6B,0x20};    // 7    0x08,0x00,0x6B,0x20     GateDriveFltAcc
    const unsigned char ccp_C1XX_GateDrvFltSts_cnt[]            = {0xF4,0x02,0x00,0x00,0x08,0x00,0x6B,0x26};    // 8    0x08,0x00,0x6B,0x26     GateDrvFltSts
    const unsigned char ccp_C1XX_SystemState_byt[]              = {0xF4,0x01,0x00,0x00,0x08,0x01,0x82,0xEE};    // 9    0x08,0x01,0x82,0xEE     System State
    const unsigned char ccp_C1XX_HwTrq_HwNm_str[]               = {0xF4,0x04,0x00,0x00,0x08,0x01,0x82,0x3C};    // 10   0x08,0x01,0x82,0x3C     Handwheel Tq total
    const unsigned char ccp_C1XX_Abs_Hw_Pos_str[]               = {0xF4,0x04,0x00,0x00,0x08,0x01,0x80,0x04};    // 11   0x08,0x01,0x80,0x04     Handwheel Angle ABS
    const unsigned char ccp_C1XX_Rel_Hw_Pos_str[]               = {0xF4,0x04,0x00,0x00,0x08,0x01,0x80,0x0C};    // 12   0x08,0x01,0x80,0x0C     Handwheel Angle REL
    const unsigned char ccp_C1XX_ManualTrqCmdEn_cnt[]           = {0xF4,0x02,0x00,0x00,0x08,0x00,0x6B,0xE0};    // 13   0x08,0x01,0x82,0xEE     Motor Commanded Torque cnt
    const unsigned char ccp_C1XX_MtrTrq_CmdNm_str[]             = {0xF4,0x04,0x00,0x00,0x08,0x01,0x82,0x90};    // 14   0x08,0x01,0x82,0x90     Motor Commanded Torque value
    const unsigned char ccp_C1XX_CCD_MSB_Die1_cnt[]             = {0xF4,0x02,0x00,0x00,0x08,0x00,0x55,0x66};    // 15   0x08,0x00,0x55,0x66     Motor Position 1
    const unsigned char ccp_C1XX_CCD_MSB_Die2_cnt[]             = {0xF4,0x02,0x00,0x00,0x08,0x00,0x55,0x6E};    // 16   0x08,0x00,0x55,0x6E     Motor Position 2
    const unsigned char ccp_C1XX_MtrTempEst_MagTempEst_DegC_str[]   = {0xF4,0x04,0x00,0x00,0x08,0x01,0x77,0x94};// 17   0x08,0x01,0x77,0x94     Motor Magnet temp

    /*    CAN data requests for C1XX    END  -----------------------------------------------------------------*/


    /*    CAN data requests for FORD ADAS    START  ------   -------------------------*/

    const unsigned char ccp_FORD_engine_run[]   = {0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
    const unsigned char ccp_FORD_engine_off[]   = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; // keeps product in warm Init mode
    const unsigned char ccp_FORD_engine_run_2[] = {0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00};
    const unsigned char ccp_FORD_write_0_to_speed[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; /* use rolling speed, via array */

    const unsigned char ccp_FORD_BattVltg_str[]                 = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC1,0x64};    // 1    0x08 01 C1 64     Battery Voltage
    const unsigned char ccp_FORD_Temperature_str[]              = {0xF4,0x04,0x00,0x00,0x08,0x01,0xB2,0xC8};    // 2    0x08 01 B2 C8     Ecu Temperature Filtered
    const unsigned char ccp_FORD_DigT1_str[]                    = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC2,0x1C};    // 3    0x08 01 C2 1C     Handwheel channel a trq
    const unsigned char ccp_FORD_DigT2_str[]                    = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC2,0x24};    // 4    0x08 01 C2 24     Handwheel channel b trq
    const unsigned char ccp_FORD_MtrCurrQax_str[]               = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC1,0xE4};    // 5    0x08 01 C1 E4     Motor Current Measurement
    const unsigned char ccp_FORD_SystemState_byt[]              = {0xF4,0x01,0x00,0x00,0x08,0x01,0xC4,0x2B};    // 6    0x08 01 C4 2B     System State
    const unsigned char ccp_FORD_HwTrq_HwNm_str[]               = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC3,0x0C};    // 7    0x08 01 C3 0C     Handwheel Tq total
    const unsigned char ccp_FORD_Abs_Hw_Pos_str[]               = {0xF4,0x04,0x00,0x00,0x08,0x01,0xC3,0x04};    // 8    0x08 01 C3 04     Handwheel Angle ABS Rte_Sa_DualSpurDigHwAg_DigHwAgAbsltPosn_HwDeg_f32
    const unsigned char ccp_FORD_Batt_Current_str[]             = {0xF4,0x04,0x00,0x00,0x08,0x01,0xB2,0xD0};    // 9    0x08 01 B2 D0     Battery Current
    const unsigned char ccp_FORD_LatchFail_ISR_u16[]            = {0xF4,0x02,0x00,0x00,0x08,0x00,0x55,0xC0};    // 10   0x
    const unsigned char ccp_FORD_MtrCntl_ISR_u16[]              = {0xF4,0x02,0x00,0x00,0x08,0x00,0x55,0xBC};    // 11   0x
    const unsigned char ccp_FORD_MinCount_u32[]                 = {0xF4,0x04,0x00,0x00,0x08,0x00,0x55,0xB4};    // 12   0x
    const unsigned char ccp_FORD_MaxCount_u32[]                 = {0xF4,0x04,0x00,0x00,0x08,0x00,0x55,0xB8};    // 13   0x
    const unsigned char ccp_FORD_CatGate_cnt[]                  = {0xF4,0x04,0x00,0x00,0x08,0x00,0x55,0xB8};    // 14   0x

    /*    CAN data requests for FORD ADAS    END  -----------------------------------------------------------------*/


    /*    CAN data requests for FCA ADAS    START  ------   -------------------------*/

    const unsigned char ccp_FCA_BattVltg_str[]                  = {0xF4,0x04,0x00,0x00,0x08,0x01,0x79,0xA0};    // 1    0x08,0x01,0x77,0xAC     Battery Voltage
    const unsigned char ccp_FCA_Temperature_str[]               = {0xF4,0x04,0x00,0x00,0x08,0x01,0x80,0x4C};    // 2    0x08,0x01,0x77,0xB4     Ecu Temperature Filtered
    const unsigned char ccp_FCA_DigT1_str[]                     = {0xF4,0x04,0x00,0x00,0x08,0x01,0x79,0xA8};    // 3    0x08,0x01,0x81,0x7C     Handwheel channel a trq
    const unsigned char ccp_FCA_DigT2_str[]                     = {0xF4,0x04,0x00,0x00,0x08,0x01,0x79,0xB0};    // 4    0x08,0x01,0x81,0x80     Handwheel channel b trq
    const unsigned char ccp_FCA_MtrCurrQax_str[]                = {0xF4,0x04,0x00,0x00,0x08,0x01,0x7A,0xD4};    // 5    0x08,0x01,0x81,0x50     Motor Current Measurement
    const unsigned char ccp_FCA_SystemState_byt[]               = {0xF4,0x01,0x00,0x00,0x08,0x01,0x7B,0xBF};    // 6    0x08,0x01,0x82,0xEE     System State
    const unsigned char ccp_FCA_HwTrq_HwNm_str[]                = {0xF4,0x04,0x00,0x00,0x08,0x01,0x7A,0xF8};    // 7    0x08,0x01,0x82,0x3C     Handwheel Tq total
    const unsigned char ccp_FCA_Abs_Hw_Pos_str[]                = {0xF4,0x04,0x00,0x00,0x08,0x01,0x78,0x00};    // 8    0x08,0x01,0x80,0x04     Handwheel Angle ABS


    /*    CAN data requests for FCA ADAS    END  -----------------------------------------------------------------*/


//  /*    CAN data requests for T1XX    START  ------  N O T E -- L I T T L E   E I N D I A N   in  constant string  -------------------------*/
//
    const unsigned char ccp_T1XX_SystemState_byt[]       = {0xF4,0x02,0x00,0x00,0xBE,0xAC,0xBE,0xFE};   // 1    FE BE AC BE     System State
    const unsigned char ccp_T1XX_MotCurrQax_str[]        = {0xF4,0x04,0x00,0x00,0xC4,0xA8,0xBE,0xFE};   // 2    FE BE A8 C4     Motor Current Measurement
    const unsigned char ccp_T1XX_HwTq0Meas_HwTq0_str[]   = {0xF4,0x04,0x00,0x00,0x3C,0xA8,0xBE,0xFE};   // 3    FE BE A8 3C     HwTq 0
    const unsigned char ccp_T1XX_HwTq1Meas_HwTq1_str[]   = {0xF4,0x04,0x00,0x00,0x48,0xA8,0xBE,0xFE};   // 4    FE BE A8 48     HwTq 1
    const unsigned char ccp_T1XX_HwTq2Meas_HwTq2_str[]   = {0xF4,0x04,0x00,0x00,0x54,0xA8,0xBE,0xFE};   // 5    FE BE A8 54     HwTq2
    const unsigned char ccp_T1XX_HwTq3Meas_HwTq3_str[]   = {0xF4,0x04,0x00,0x00,0x58,0xA8,0xBE,0xFE};   // 6    FE BE A8 58     HwTq3
    const unsigned char ccp_T1XX_EcuTFild_str[]          = {0xF4,0x04,0x00,0x00,0x34,0xA9,0xBE,0xFE};   // 7    FE BE A9 34     Ecu Temperature Filtered
    const unsigned char ccp_T1XX_HwAgArbn_HwAg_str[]     = {0xF4,0x04,0x00,0x00,0xB4,0xA9,0xBE,0xFE};   // 8    FE BE A9 B4     Handwheel Angle
    const unsigned char ccp_T1XX_HwAg0_str[]             = {0xF4,0x04,0x00,0x00,0xAC,0xA9,0xBE,0xFE};   // 9    FE BE A9 AC         10 tooth
    const unsigned char ccp_T1XX_HwAg1_str[]             = {0xF4,0x04,0x00,0x00,0xB0,0xA9,0xBE,0xFE};   // 10   FE BE A9 B0     11 tooth
    const unsigned char ccp_T1XX_HwTqArbn_HwTq_str[]     = {0xF4,0x04,0x00,0x00,0xF0,0xA9,0xBE,0xFE};   // 11   FE BE A9 F0     HW Tq total
    const unsigned char ccp_T1XX_MotCurrDax_str[]        = {0xF4,0x04,0x00,0x00,0xC0,0xA8,0xBE,0xFE};   // 12   FE BE A8 C0     mtr curr dax
    const unsigned char ccp_T1XX_HwTqArbn_HwTqChA_str[]  = {0xF4,0x04,0x00,0x00,0xF4,0xA9,0xBE,0xFE};   // 13   FE BE A9 F4     channel a trq
    const unsigned char ccp_T1XX_HwTqArbn_HwTqChB_str[]  = {0xF4,0x04,0x00,0x00,0xF8,0xA9,0xBE,0xFE};   // 14   FE BE A9 F8     channel b trq
    const unsigned char ccp_T1XX_MotAgCmp_str[]          = {0xF4,0x04,0x00,0x00,0xBC,0xA4,0xBE,0xFE};   // 15   FE BE A4 BC     Mechanical Motor Angle
    const unsigned char ccp_T1XX_BattVltg_str[]          = {0xF4,0x04,0x00,0x00,0x24,0xA8,0xBE,0xFE};   // 16   FE BE A8 24     Battery Voltage
    const unsigned char ccp_T1XX_BattVltgSwd1_str[]      = {0xF4,0x04,0x00,0x00,0x28,0xA8,0xBE,0xFE};   // 17   FE BE A8 28     Switched Battery Voltage 1
    const unsigned char ccp_T1XX_BattVltgSwd2_str[]      = {0xF4,0x04,0x00,0x00,0x2C,0xA8,0xBE,0xFE};   // 18   FE BE A8 2C     Switched Battery Voltage 2
    const unsigned char ccp_T1XX_BrdgVltg_str[]          = {0xF4,0x04,0x00,0x00,0x04,0xA8,0xBE,0xFE};   // 19   FE BE A8 04     Bridge Voltage
    const unsigned char ccp_T1XX_AssiCmdBas_str[]        = {0xF4,0x04,0x00,0x00,0xD4,0xA7,0xBE,0xFE};   // 20   FE BE A7 D4     Assist Command Base
    const unsigned char ccp_T1XX_MotTqCmd_str[]          = {0xF4,0x04,0x00,0x00,0xE8,0xA7,0xBE,0xFE};   // 21   FE BE A7 E8     Motor Torque Command
    const unsigned char ccp_T1XX_AssiMechT_str[]         = {0xF4,0x04,0x00,0x00,0x24,0xAB,0xBE,0xFE};   // 22   FE BE AB 24     assist mech temp
    const unsigned char ccp_T1XX_MotFetT_str[]           = {0xF4,0x04,0x00,0x00,0x28,0xAB,0xBE,0xFE};   // 23   FE BE AB 28     motor fet temp
    const unsigned char ccp_T1XX_MotMagT_str[]           = {0xF4,0x04,0x00,0x00,0x2C,0xAB,0xBE,0xFE};   // 24   FE BE AB 2C     motor magnet temp
    const unsigned char ccp_T1XX_MotWidgT_str[]          = {0xF4,0x04,0x00,0x00,0x30,0xAB,0xBE,0xFE};   // 25   FE BE AB 30     motor winding temp
    const unsigned char ccp_T1XX_MotREstim_str[]         = {0xF4,0x04,0x00,0x00,0x3C,0xAA,0xBE,0xFE};   // 26   FE BE AA 3C     motor curr peak
    const unsigned char ccp_T1XX_MotTq_str[]             = {0xF4,0x04,0x00,0x00,0xD4,0xAA,0xBE,0xFE};   // 27   FE BE AA D4     Motor Torque

    /*    CAN data requests for T1XX    END  -----------------------------------------------------------------*/

    //  /*    CAN data requests for GWM A0607    START  ------  N O T E -- L I T T L E   E I N D I A N   in  constant string  -------------------------*/
    //
            const unsigned char ccp_GWM_A0607_SystemState_byt[]       = {0xF4,0x01,0x00,0x00,0x22,0xA9,0xBE,0xFE};   // 1    0xFEBEA922     System State  //Rte_SysStMod_SysSt_Val
            const unsigned char ccp_GWM_A0607_MotCurrQax_fp[]         = {0xF4,0x04,0x00,0x00,0xC0,0xA4,0xBE,0xFE};   // 2    0xFEBEA4C0     Motor Current Measurement  //Rte_CDD_MotCtrlMgr_MotCurrQax_Val
            const unsigned char ccp_GWM_A0607_HwTq0Meas_HwTq4_fp[]    = {0xF4,0x04,0x00,0x00,0x3C,0xA4,0xBE,0xFE};   // 3    0xFEBEA43C     HwTq 4   //Rte_CDD_HwTq4Meas_HwTq4_Val
            const unsigned char ccp_GWM_A0607_HwTq1Meas_HwTq5_fp[]    = {0xF4,0x04,0x00,0x00,0x40,0xA4,0xBE,0xFE};   // 4    0xFEBEA440     HwTq 5   //Rte_CDD_HwTq5Meas_HwTq5_Val
            const unsigned char ccp_GWM_A0607_MotHwPosn_fp[]          = {0xF4,0x02,0x00,0x00,0xE4,0xA5,0xBE,0xFE};   // 5    0xFEBEA5E4     Motor Handwheel Position   // Rte_HwAgSysArbn_HwAgFinal_Val
            const unsigned char ccp_GWM_A0607_BattVltg_fp[]           = {0xF4,0x04,0x00,0x00,0xE0,0xA3,0xBE,0xFE};   // 6    0xFEBEA3E0     Battery Voltage     //Rte_BattVltg_BrdgVltg_Val
            const unsigned char ccp_GWM_A0607_MotTq_fp[]              = {0xF4,0x04,0x00,0x00,0x2C,0xA7,0xBE,0xFE};   // 7    0xFEBEA72C     Motor Torque        //Rte_Swp_MotTqCmdSwp_Val
            const unsigned char ccp_GWM_A0607_HwTrq_fp[]              = {0xF4,0x04,0x00,0x00,0x08,0xA6,0xBE,0xFE};   // 8    0xFEBEA608     Handwheel Torque    //Rte_HwTqArbn_HwTq_Val
            const unsigned char ccp_GWM_A0607_MotMagTestim_fp[]       = {0xF4,0x04,0x00,0x00,0x54,0xA7,0xBE,0xFE};   // 9    0xFEBEA754     Motor Mag Temp Estimated    //Rte_TEstimn_MotMagT_Val
            const unsigned char ccp_GWM_A0607_ECUTFilt_fp[]           = {0xF4,0x04,0x00,0x00,0x58,0xA5,0xBE,0xFE};   // 10   0xFEBEA558     ECU Temp Filtered   // Rte_EcuTMeas_EcuTFild_Val

/*    CAN data requests for GWM_A0607    END  -----------------------------------------------------------------*/



    // Torque values for  TOC T1XX, C1XX,9BXX using 'FD0D' manufacturing service. Single message control.
    //    Ratiometric scaling to 2048 as 1nm

//  const unsigned char ms_write_torque_value_pos_0nm[]     = {0x04,0x2F,0xFD,0x0D,0x00,0x00,0x00,0x00};   // 0 nm torque *** note 5th byte is 00 not 03 for bytes to follow

//  const unsigned char ms_write_torque_value_pos_p1nm[]    = {0x06,0x2F,0xFD,0x0D,0x03,0x00,0xCD,0x00};   // positive .1 nm 00 CD = 205  205/2048 or 2^11 =.1
//  const unsigned char ms_write_torque_value_neg_p1nm[]    = {0x06,0x2F,0xFD,0x0D,0x03,0xFF,0x33,0x00};   // negative .1 nm       = -205 =  FF 33

//  const unsigned char ms_write_torque_value_pos_p5nm[]    = {0x06,0x2F,0xFD,0x0D,0x03,0x04,0x00,0x00};   // positive .5 nm 04 00 = 1024  1024/2048 or 2^11 =.5
//  const unsigned char ms_write_torque_value_neg_p5nm[]    = {0x06,0x2F,0xFD,0x0D,0x03,0xFC,0x00,0x00};   // negative .5 nm       = -1024 = FC 00

//  const unsigned char ms_write_torque_value_pos_1p00nm[]  = {0x06,0x2F,0xFD,0x0D,0x03,0x08,0x00,0x00};   // positive 1.0 nm 08 00 = 2048  2048/2048 or 2^11 =1
//  const unsigned char ms_write_torque_value_neg_1p00nm[]  = {0x06,0x2F,0xFD,0x0D,0x03,0xF8,0x00,0x00};   // negative 1.0 nm       = -2048  = F8 00

//  const unsigned char ms_write_torque_value_pos_2p00nm[]  = {0x06,0x2F,0xFD,0x0D,0x03,0x10,0x00,0x00};   // positive 2.0 nm 10 00 =    2 * 2048 or 2^11 = 4096
//  const unsigned char ms_write_torque_value_neg_2p00nm[]  = {0x06,0x2F,0xFD,0x0D,0x03,0xF0,0x00,0x00};   // negative 2.0 nm       = -4096  = F0 00

//  const unsigned char ms_write_torque_value_pos_4p00nm[]  = {0x06,0x2F,0xFD,0x0D,0x03,0x20,0x00,0x00};   // positive 4.00 nm 20 00 =   4 * 2048 or 2^11 =     8192
//  const unsigned char ms_write_torque_value_neg_4p00nm[]  = {0x06,0x2F,0xFD,0x0D,0x03,0xE0,0x00,0x00};   // negative 4.00 nm       = -8192  = F E0 00 ( F is dropped per looking at etool)

//  const unsigned char ms_write_torque_value_pos_6p00nm[]  = {0x06,0x2F,0xFD,0x0D,0x03,0x30,0x00,0x00};   // positive 6.00 nm 30 00 =   6 * 2048 or 2^11 =     12288
//  const unsigned char ms_write_torque_value_neg_6p00nm[]  = {0x06,0x2F,0xFD,0x0D,0x03,0xD0,0x00,0x00};   // negative 6.00 nm       = -12288  = F D0 00    ( F is dropped per looking at etool)


    /*    CAN data requests for TOC T1XX, C1XX,9BXX    END  -----------------------------------------------------------------*/

/*  ---------    Torque values for  TOC G2KCA EA4 using 'FD40' manufacturing service.  START   ---------------------------------------*/
/*                  The 'FD40' and SHORT TERM ADJUST '30' service spans two messages, with (significant delay between each transmit - Phil )
 *                      NOW also used by FORD T3-T6 EA4  16OCT17   */

    const unsigned char ms_write_torque_value_x30[]         = {0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00};    // start service ?


    // Lets try using the standard service 'FD40', and set torque to  0.0nm  - Leonard 30MAY17
    const unsigned char ms_write_torque_value_pos_0nm[]    = {0x10,0x08,0x2F,0xFD,0x40,0x03,0x00,0x00};   // positive 0 nm = 00 00 00 00
    const unsigned char ms_write_torque_value_pos_0nm2[]   = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_pos_p1nm[]    = {0x10,0x08,0x2F,0xFD,0x40,0x03,0x3D,0xCC};   // positive .1 nm = 3D CC CC CD
    const unsigned char ms_write_torque_value_pos_p1nm2[]   = {0x21,0xCC,0xCD,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_neg_p1nm[]    = {0x10,0x08,0x2F,0xFD,0x40,0x03,0xBD,0xCC};   // negative .1 nm = BD CC CC CD
    const unsigned char ms_write_torque_value_neg_p1nm2[]   = {0x21,0xCC,0xCD,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_pos_p5nm[]    = {0x10,0x08,0x2F,0xFD,0x40,0x03,0x3F,0x00};   // positive .5 nm = 3F 00 00 00
    const unsigned char ms_write_torque_value_pos_p5nm2[]   = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_neg_p5nm[]    = {0x10,0x08,0x2F,0xFD,0x40,0x03,0xBF,0x00};   // negative .5 nm = BF 00 00 00
    const unsigned char ms_write_torque_value_neg_p5nm2[]   = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_pos_1p00nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0x3F,0x80};   // positive 1.0 nm = 3F 80 00 00
    const unsigned char ms_write_torque_value_pos_1p00nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_neg_1p00nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0xBF,0x80};   // negative 1.0 nm = BF 80 00 00
    const unsigned char ms_write_torque_value_neg_1p00nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_pos_1p50nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0x3F,0xC0};   // positive 1.5 nm = 3F C0 00 00
    const unsigned char ms_write_torque_value_pos_1p50nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_neg_1p50nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0xBF,0xC0};   // negative 1.5 nm = BF C0 00 00
    const unsigned char ms_write_torque_value_neg_1p50nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_pos_2p00nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0x40,0x00};   // positive 2.0 nm = 40 00 00 00
    const unsigned char ms_write_torque_value_pos_2p00nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_neg_2p00nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0xC0,0x00};   // negative 2.0 nm = C0 00 00 00
    const unsigned char ms_write_torque_value_neg_2p00nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_pos_2p50nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0x40,0x20};   // positive 2.5 nm = 40 20 00 00
    const unsigned char ms_write_torque_value_pos_2p50nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_neg_2p50nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0xC0,0x20};   // negative 2.5 nm = C0 20 00 00
    const unsigned char ms_write_torque_value_neg_2p50nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_pos_3p00nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0x40,0x40};   // positive 3.0 nm = 40 40 00 00
    const unsigned char ms_write_torque_value_pos_3p00nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_neg_3p00nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0xC0,0x40};   // negative 3.0 nm = C0 40 00 00
    const unsigned char ms_write_torque_value_neg_3p00nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_pos_3p50nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0x40,0x60};   // positive 3.5 nm = 40 60 00 00
    const unsigned char ms_write_torque_value_pos_3p50nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_neg_3p50nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0xC0,0x00};   // negative 3.5 nm = C0 00 00 00
    const unsigned char ms_write_torque_value_neg_3p50nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_pos_4p00nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0x40,0x80};   // positive 4.00 nm = 40 80 00 00
    const unsigned char ms_write_torque_value_pos_4p00nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_neg_4p00nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0xC0,0x80};   // negative 4.00 nm = C0 80 00 00
    const unsigned char ms_write_torque_value_neg_4p00nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_pos_6p00nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0x40,0xC0};   // positive 6.00 nm = 40 C0 00 00
    const unsigned char ms_write_torque_value_pos_6p00nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_write_torque_value_neg_6p00nm[]  = {0x10,0x08,0x2F,0xFD,0x40,0x03,0xC0,0xC0};   // negative 6.00 nm = C0 C0 00 00
    const unsigned char ms_write_torque_value_neg_6p00nm2[] = {0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00};


/*    CAN data requests for TOC TARGET_PSA_CMP EA3    END     -----------------------------------------------------------------*/

    /*  ---------    Torque values for  TOC PSA EA3 using 'FD30' manufacturing service.  START   ---------------------------------------*/
    /*                  The 'FD30' End Of Line Torque Trim Value service spans two messages   */

    const unsigned char ms_PSA_write_torque_value_pos_0nm[]     = {0x10,0x08,0x2E,0xFD,0x30,0x00,0x00,0x00};    // positive values NOT correct, positive 0 nm = 00 00 00 00
    const unsigned char ms_PSA_write_torque_value_pos_0nm2[]    = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_pos_p1nm[]    = {0x10,0x08,0x2E,0xFD,0x30,0x3E,0xB6,0x4D};   // 0p10nm  2.42A 2%, positive .1 nm = 3D CC CC CD
    const unsigned char ms_PSA_write_torque_value_pos_p1nm2[]   = {0x21,0x7F,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_neg_p1nm[]    = {0x10,0x08,0x2E,0xFD,0x30,0xBE,0xB6,0x4D};   // negative .1 nm = BD CC CC CD
    const unsigned char ms_PSA_write_torque_value_neg_p1nm2[]   = {0x21,0x7F,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_pos_p5nm[]    = {0x10,0x08,0x2E,0xFD,0x30,0x3F,0x0F,0xAF};   // 0p35nm  9.68A 8%, positive .5 nm = 3F 00 00 00
    const unsigned char ms_PSA_write_torque_value_pos_p5nm2[]   = {0x21,0x64,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_neg_p5nm[]    = {0x10,0x08,0x2E,0xFD,0x30,0xBF,0x0F,0xAF};   // negative .5 nm = BF 00 00 00
    const unsigned char ms_PSA_write_torque_value_neg_p5nm2[]   = {0x21,0x64,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_pos_1p00nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0x3F,0x95,0x94};   // 0p80nm  19.36A 20%, positive 1.0 nm = 3F 80 00 00
    const unsigned char ms_PSA_write_torque_value_pos_1p00nm2[] = {0x21,0xAF,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_neg_1p00nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0xBF,0x95,0x94};   // negative 1.0 nm = 3F 80 00 00
    const unsigned char ms_PSA_write_torque_value_neg_1p00nm2[] = {0x21,0xAF,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_pos_1p50nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0x3F,0xC0,0x00};   // positive 1.5 nm = 3F C0 00 00 added 10MAR18
    const unsigned char ms_PSA_write_torque_value_pos_1p50nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_neg_1p50nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0xBF,0xFC,0x00};   // negative 1.5 nm = BF FC 00 00 added 10MAR18
    const unsigned char ms_PSA_write_torque_value_neg_1p50nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_pos_2p00nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0x3F,0xDC,0xCC};   // 1p70nm  36.3A 40%, positive 2.0 nm = 40 00 00 00
    const unsigned char ms_PSA_write_torque_value_pos_2p00nm2[] = {0x21,0xCD,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_neg_2p00nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0xBF,0xDC,0xCC};   // negative 2.0 nm = C0 00 00 00
    const unsigned char ms_PSA_write_torque_value_neg_2p00nm2[] = {0x21,0xCD,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_pos_2p50nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0x40,0x20,0x00};   // positive 2.5 nm = 40 20 00 00 added 10MAR18
    const unsigned char ms_PSA_write_torque_value_pos_2p50nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_neg_2p50nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0xC0,0x02,0x00};   // negative 2.5 nm = C0 02 00 00 added 10MAR18
    const unsigned char ms_PSA_write_torque_value_neg_2p50nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_pos_3p00nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0x40,0x40,0x00};   // positive 3.0 nm = 40 40 00 00 added 10MAR18
    const unsigned char ms_PSA_write_torque_value_pos_3p00nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_neg_3p00nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0x40,0x00,0x00};   // negative 3.0 nm = 40 00 00 00 added 10MAR18
    const unsigned char ms_PSA_write_torque_value_neg_3p00nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_pos_3p50nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0x40,0x60,0x00};   // positive 3.5 nm = 40 60 00 00 added 10MAR18
    const unsigned char ms_PSA_write_torque_value_pos_3p50nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_neg_3p50nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0x06,0x00,0x00};   // negative 3.5 nm = 06 00 00 00 added 10MAR18
    const unsigned char ms_PSA_write_torque_value_neg_3p50nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_pos_4p00nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0x40,0x30,0x00};   //  2.67Nm 80%, positive 4.00 nm = 40 80 00 00
    const unsigned char ms_PSA_write_torque_value_pos_4p00nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_neg_4p00nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0xC0,0x30,0x00};   //  -2.67Nm, negative 4.00 nm  = C0 80 00 00
    const unsigned char ms_PSA_write_torque_value_neg_4p00nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_pos_6p00nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0x40,0xC0,0x00};   // 100%, positive 6.00 nm = 40 C0 00 00
    const unsigned char ms_PSA_write_torque_value_pos_6p00nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};

    const unsigned char ms_PSA_write_torque_value_neg_6p00nm[]  = {0x10,0x08,0x2E,0xFD,0x30,0xC0,0xC0,0x00};   // negative 6.00 nm = C0 C0 00 00
    const unsigned char ms_PSA_write_torque_value_neg_6p00nm2[] = {0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x00};


    /*    CAN data requests for TOC TARGET_PSA_CMP   END     -----------------------------------------------------------------*/


    /*    CAN data requests for 9Bxx    START  ------  N O T E -- B I G   E I N D I A N   in  constant string  -------------------------

    const unsigned char ccp_request_system_state[]                  = {0xF4,0x01,0x00,0x00,0x08,0x01,0x83,0xB6};   // 1    one byte ENUM                                      0
    const unsigned char ccp_request_RelHwPos_str[]                  = {0xF4,0x04,0x00,0x00,0x08,0x01,0x80,0x0C};   // 2    P1A 4 byte float
    const unsigned char ccp_request_AbsHwPos_str[]                  = {0xF4,0x04,0x00,0x00,0x08,0x01,0x80,0x10};   // 3    P2A 4 byte float
    const unsigned char ccp_request_ColPos_str[]                    = {0xF4,0x04,0x00,0x00,0x08,0x01,0x82,0x78};   // 4    P1B 4 byte float
    const unsigned char ccp_request_AnaHwTrq1_str[]                 = {0xF4,0x04,0x00,0x00,0x08,0x01,0x82,0xE8};   // 5    TP2B 4 byte float
    const unsigned char ccp_request_AnaHwTrq2_str[]                 = {0xF4,0x04,0x00,0x00,0x08,0x01,0x82,0xF0};   // 6    Handwheel / Column position in deg 4 byte float
    const unsigned char ccp_request_Ch1_T1_T2_str[]                 = {0xF4,0x04,0x00,0x00,0x08,0x01,0x83,0x04};   // 7    T1A 4 byte float
    const unsigned char ccp_request_DigHwTrq3_str[]                 = {0xF4,0x04,0x00,0x00,0x08,0x01,0x82,0x18};   // 8    T1A 4 byte float
    const unsigned char ccp_request_DigHwTrq4_str[]                 = {0xF4,0x04,0x00,0x00,0x08,0x01,0x82,0x20};   // 9    T2B 4 byte float
    const unsigned char ccp_request_Ch2_T3_T4_str[]                 = {0xF4,0x04,0x00,0x00,0x08,0x01,0x83,0x08};   // 10    T2B 4 byte float
    const unsigned char ccp_request_HwTrq_Final_str[]               = {0xF4,0x04,0x00,0x00,0x08,0x01,0x83,0x0C};   // 11   HwTrqNm  4 byte float
    const unsigned char ccp_request_battery_voltage_str[]           = {0xF4,0x04,0x00,0x00,0x08,0x01,0x82,0x98};   // 12   4 byte float
    const unsigned char ccp_request_battery_current_str[]           = {0xF4,0x04,0x00,0x00,0x08,0x01,0x80,0x5C};   // 13   4 byte float
    const unsigned char ccp_request_controller_temp_str[]           = {0xF4,0x04,0x00,0x00,0x08,0x01,0x77,0x70};   // 14   4 byte float
    const unsigned char ccp_request_MtrCurrQax_str[]                = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0xF0};   // 15   4 byte float
    const unsigned char ccp_request_EstQaxCurr_str[]                = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0x70};   // 16   4 byte float
    const unsigned char ccp_request_MtrTrq_Cmd_str[]                = {0xF4,0x04,0x00,0x00,0x08,0x01,0x83,0x48};   // 17   4 byte float returns commanded trq value
    const unsigned char ccp_request_MtrCurrDax_str[]                = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0xEC};   // 18   4 byte float
    const unsigned char ccp_request_MtrCurrA_str[]                  = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0x70};   // 19   4 byte float
    const unsigned char ccp_request_MtrCurrB_str[]                  = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0x74};   // 20   4 byte float
    const unsigned char ccp_request_MtrCurrC_str[]                  = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0x78};   // 21   4 byte float
    const unsigned char ccp_request_DigMSB_MtrPos1_Rev_cnt[]        = {0xF4,0x02,0x00,0x00,0x08,0x01,0x81,0xC4};   // 22   4 byte float returns MSP SPI ChA value
    const unsigned char ccp_request_DigMSB_MtrPos2_Rev_cnt[]        = {0xF4,0x02,0x00,0x00,0x08,0x01,0x81,0xD4};   // 23   4 byte float returns MSB SPI ChB value
    const unsigned char ccp_request_DigMSB_MtrPos1_Roll_cnt[]       = {0xF4,0x02,0x00,0x00,0x08,0x01,0x81,0xC6};   // 24   cnt returns ChC MSB Sin value
    const unsigned char ccp_request_DigMSB_MtrPos2_Roll_cnt[]       = {0xF4,0x02,0x00,0x00,0x08,0x01,0x81,0xD6};   // 25   cnt returns ChC MSB Cos value
    const unsigned char ccp_request_DigMSB_MtrPosMecl_Rev_str[]     = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0x88};   // 26   Motor Position currently being used by controller
    const unsigned char ccp_request_AnaMSB_Cos_cnt[]                = {0xF4,0x02,0x00,0x00,0x08,0x01,0x82,0xA4};   // 27   4 byte float returns MSP SPI ChA value
    const unsigned char ccp_request_AnaMSB_Sin_cnt[]                = {0xF4,0x02,0x00,0x00,0x08,0x01,0x82,0xA6};   // 28   4 byte float returns MSB SPI ChB value
    const unsigned char ccp_request_AnaMSB_MtrPosMecl_Rev_cnt[]     = {0xF4,0x02,0x00,0x00,0x08,0x01,0x83,0x1A};   // 29   cnt returns ChC MSB Sin value
    const unsigned char ccp_request_AnaMSB_MtrPosMecl_Roll_cnt[]    = {0xF4,0x02,0x00,0x00,0x08,0x01,0x83,0x1D};   // 30   cnt returns ChC MSB Cos value
    const unsigned char ccp_request_MtrCurrPos_Rev_str[]            = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0x7C};   // 31   Motor Position currently being used by controller
    const unsigned char ccp_request_ElecMtrPos_Rev_str[]            = {0xF4,0x04,0x00,0x00,0x08,0x01,0x81,0x80};   // 32   Motor Position currently being used by controller
    const unsigned char ccp_request_prod_3p3V_str[]                 = {0xF4,0x04,0x00,0x00,0x08,0x01,0x82,0xC4};   // 33   Motor Position currently being used by controller
    const unsigned char ccp_request_prod_5V_P1_str[]                = {0xF4,0x04,0x00,0x00,0x08,0x01,0x82,0xC8};   // 34   Motor Position currently being used by controller
    const unsigned char ccp_request_prod_5V_P2_str[]                = {0xF4,0x04,0x00,0x00,0x08,0x01,0x82,0xCC};   // 35   Motor Position currently being used by controller

    //    CAN data requests for 9Bxx    END  -----------------------------------------------------------------*/

    /* Torque values for  TOC using 'FD0D' manufacturing service, (floats) in Nm value for cal/functionals.  */
        // 9Bxx uses percents

const unsigned char ms_write_motor_torq_serv_pos_0prcnt[]   = {0x04,0x2F,0xFD,0x0D,0x00,0x00,0x00,0x00};   // 0 nm torque *** note 5th byte is 00 not 03 for bytes to follow

//const unsigned char ms_write_motor_torq_serv_pos_0prcnt[] = {0x06,0x2F,0xFD,0x0D,0x03,0x00,0x00,0x00}; // positive values NOT correct
//const unsigned char ms_write_motor_torq_serv_neg_0prcnt[] = {0x06,0x2F,0xFD,0x0D,0x03,0x00,0x00,0x00}; // negative values NOT correct

const unsigned char ms_write_motor_torq_serv_pos_2prcnt[]   = {0x06,0x2F,0xFD,0x0D,0x03,0x00,0xA0,0x00}; //0p10nm, 2.42A
const unsigned char ms_write_motor_torq_serv_neg_2prcnt[]   = {0x06,0x2F,0xFD,0x0D,0x03,0xFF,0x60,0x00};

const unsigned char ms_write_motor_torq_serv_pos_8prcnt[]   = {0x06,0x2F,0xFD,0x0D,0x03,0x02,0x7F,0x00}; //0p35nm, 9.68A
const unsigned char ms_write_motor_torq_serv_neg_8prcnt[]   = {0x06,0x2F,0xFD,0x0D,0x03,0xFD,0x81,0x00};

const unsigned char ms_write_motor_torq_serv_pos_16prcnt[]  = {0x06,0x2F,0xFD,0x0D,0x03,0x04,0xFB,0x00}; //0p80nm, 19.36A
const unsigned char ms_write_motor_torq_serv_neg_16prcnt[]  = {0x06,0x2F,0xFD,0x0D,0x03,0xFB,0x05,0x00};

const unsigned char ms_write_motor_torq_serv_pos_30prcnt[]  = {0x06,0x2F,0xFD,0x0D,0x03,0x09,0x5C,0x00}; //1p70nm, 36.3A
const unsigned char ms_write_motor_torq_serv_neg_30prcnt[]  = {0x06,0x2F,0xFD,0x0D,0x03,0xF6,0xA4,0x00};

const unsigned char ms_write_motor_torq_serv_pos_95prcnt[]  = {0x06,0x2F,0xFD,0x0D,0x03,0x20,0x00,0x00}; //imax, 114.95A (95%)
const unsigned char ms_write_motor_torq_serv_neg_95prcnt[]  = {0x06,0x2F,0xFD,0x0D,0x03,0xE0,0x00,0x00};

    /*    CAN data requests for TOC  9Bxx    END  -----------------------------------------------------------------*/



/* ---------  A D C 1 variables  - Global  ---------  */
/*
    AD1IN[0]    MSB - Sin
    AD1IN[1]    MSB - Cos
    AD1IN[2]    MSB - InvSin
    AD1IN[3]    MSB - InvCos
    AD1IN[4]    TC -  Sin
    AD1IN[5]    TC -  Cos
    AD1IN[6]    T1
    AD1IN[7]    T2
    AD1IN[8]    Prod 3.3v
    AD1IN[9]    Prod 5v
    AD1IN[10]   Ignition
    AD1IN[11]   2.5v Ref
    AD1IN[12]   Reserved for Current Measurement - Large
    AD1IN[13]   Reserved for Current Measurement - Small
    AD1IN[14]   Reserved Speed In (or any Analog input)
 */
uint16 adc1_Group1_history[10][12];     // user storage, rolling history of adc fifo, set up for 12ch/10 sets of samples
adcData_t adc1_Group1_raw[12];              // user storage (structured data), to offload adc fifo, set up for 12ch/1 sets of samples
uint16 adc1_Group1_sum[12];             // user storage, accumilation of history set
uint16 adc1_Group1_filtered[12];            // user storage, FIR filtered data, Use this set for evaluation of counts
int adc1_Group1_mV[12];             // user storage, if ad_2_5_vref_flag is TRUE, value is AtoD value in mV, else -1
uint32 acd1_count;

int oldest;                             // pointer to oldest entry in circular buffer

/* ---------  A D C 2 variables  - Global  ---------  */
/*
    AD2IN[0]    TCPIPID2
    AD2IN[1]    SENSEID3
    AD2IN[2]    SENSEID4
    AD2IN[3]    FRAYID5
    AD2IN[4]    HEX SW-1
    AD2IN[5]    HEX SW-2
    AD2IN[6]    HEX SW-3
    AD2IN[7]    HEX SW-4
    AD2IN[15]   DIGITALID1

 */
adcData_t adc2_Group1_raw[9];               // user storage (structured data), to offload adc fifo, set up for 9ch/1 sets of samples
uint32 acd2_count;

/* ---------  A to D Voltage Reference - Global -----*/

int ad_2_5_vref_flag;               // set when 2.5 volt ref has been established, after > two passes of FIR filter
int ad_2_5_vref_val;                // AtoD counts for filtered 2.5volt ref, established pre main(), used in converting channel values to mV
int ad_ground_offset_in_tick;       // when using B_Board and 96way 5volt power, offset will compensate for readbacks loss because of board interconnect

int AtoD_print_type;    /* 0= done, 1= single ch print, 2= all 11chs print */
int AtoD_print_count;   /* number of times to print, will print each analog scan until decremented to 0 */

/* ---------  S P I  variables  for analog output - Global  ---------  */

//      SPI data format     -- Only using one Transfer Group "0",
//                              SPI 8ch D to A data is written in 3byte (24bits) transfers, one transfer for each channel
//                              Data is moved from DtoA_array[8 by 3] a row at a time, using setSPIdata() and  Transfer Group 0.
//                                  (The last row [7], contains two commands. Load ch7 and output all channels with newly loaded data.)


unsigned short DtoA_array[8][3];    /* Intermediate array to store SPI data for chip configuration  */
                                /* Load or edit prior to kicking off SPI activity.  */
                                /*  byte0=command&address byte1=dataHigh byte2=dataLow  */
                                /* 0xffff = 5v, 0x3333/volt = 13,107dec/volt */

/* ---------------   F O R D   A N A L O G    O U T P U T   D A T A   (New TC and T locations 16SEP14) ---------------------------  */

    //const short cal_DtoA_load1[8][3] = {
    //      {0x00,0x19,0x99},   /* D/A ch0 - p1 at 0.5 volts */
    //      {0x01,0x19,0x99},   /* D/A ch1 - p2 at 0.5 volts */
    //      {0x02,0x19,0x99},   /* D/A ch2 - p3 at 0.5 volts */                15MAR12 L.Cronk
    //      {0x03,0x19,0x99},   /* D/A ch3 - T1 at 0.5 volts */
    //      {0x04,0xe6,0x65},   /* D/A ch4 - T2 at 4.5 volts */
    //      {0x05,0x70,0xa3},   /* D/A ch5 - sine/cosine 2.2v (old TACH1)*/
    //      {0x06,0x2e,0x14},   /* D/A ch6 - inverse sine/cosine .9v (old TACH2) */
    //      {0x27,0x00,0x00}};  /* D/A ch7 - not used  */
    const short cal_DtoA_load2[8][3] = {
            {0x00,0xa4,0x33},   /* D/A ch0 - MSB Sin    at 3.20 volts  at 45degs CAL set A, all at 100% */
            {0x01,0xa4,0x33},   /* D/A ch1 - MSB Cos    at 3.20 volts */
            {0x02,0x5b,0xcb},   /* D/A ch2 - MSB InvSin at 1.79 volts */
            {0x03,0x5b,0xcb},   /* D/A ch3 - MSB InvCos at 1.79 volts           29MAR12 L.Cronk */
            {0x04,0x6a,0x33},   /* D/A ch4 - TC Sin     at 2.07 volts */
            {0x05,0x6a,0x33},   /* D/A ch5 - TC Cos     at 2.07 volts */
            {0x06,0xcc,0xcc},   /* D/A ch6 - T1         at 4.0  volts           30OCT12 Fix     */
            {0x27,0x33,0x33}};  /* D/A ch7 - T2         at 1.0  volts           30OCT12 Fix     */
    //const short cal_DtoA_load3[8][3] = {
    //      {0x00,0x4c,0xcc},   /* D/A ch0 - p1 at 1.5 volts */
    //      {0x01,0x4c,0xcc},   /* D/A ch1 - p2 at 1.5 volts */
    //      {0x02,0x4c,0xcc},   /* D/A ch2 - p3 at 1.5 volts */
    //      {0x03,0x4c,0xcc},   /* D/A ch3 - T1 at 1.5 volts                    15MAR12 L.Cronk */
    //      {0x04,0xb3,0x32},   /* D/A ch4 - T2 at 3.5 volts */
    //      {0x05,0x70,0xa3},   /* D/A ch5 - sine/cosine 2.2v (old TACH1)*/
    //      {0x06,0x2e,0x14},   /* D/A ch6 - inverse sine/cosine .9v (old TACH2) */
    //      {0x27,0x00,0x00}};  /* D/A ch7 - not used  */
    //const short cal_DtoA_load4[8][3] = {
    //      {0x00,0x66,0x66},   /* D/A ch0 - p1 at 2.0 volts */
    //      {0x01,0x66,0x66},   /* D/A ch1 - p2 at 2.0 volts */
    //      {0x02,0x66,0x66},   /* D/A ch2 - p3 at 2.0 volts                    15MAR12 L.Cronk */*/
    //      {0x03,0x66,0x66},   /* D/A ch3 - T1 at 2.0 volts */
    //      {0x04,0x99,0x99},   /* D/A ch4 - T2 at 3.0 volts */
    //      {0x05,0x70,0xa3},   /* D/A ch5 - sine/cosine 2.2v (old TACH1)*/
    //      {0x06,0x2e,0x14},   /* D/A ch6 - inverse sine/cosine .9v (old TACH2) */
    //      {0x27,0x00,0x00}};  /* D/A ch7 - not used  */
    //const short cal_DtoA_load5[8][3] = {
    //      {0x00,0x7f,0xff},   /* D/A ch0 - p1 at 2.5 volts */
    //      {0x01,0x7f,0xff},   /* D/A ch1 - p2 at 2.5 volts */
    //      {0x02,0x7f,0xff},   /* D/A ch2 - p3 at 2.5 volts                    15MAR12 L.Cronk */*/
    //      {0x03,0x7f,0xff},   /* D/A ch3 - T1 at 2.5 volts */
    //      {0x04,0x7f,0xff},   /* D/A ch4 - T2 at 2.5 volts */
    //      {0x05,0x70,0xa3},   /* D/A ch5 - sine/cosine 2.2v (old TACH1)*/
    //      {0x06,0x2e,0x14},   /* D/A ch6 - inverse sine/cosine .9v (old TACH2) */
    //      {0x27,0x00,0x00}};  /* D/A ch7 - not used  */
    //const short cal_DtoA_load6[8][3] = {
    //      {0x00,0x99,0x99},   /* D/A ch0 - p1 at 3.0 volts */
    //      {0x01,0x99,0x99},   /* D/A ch1 - p2 at 3.0 volts */
    //      {0x02,0x99,0x99},   /* D/A ch2 - p3 at 3.0 volts */
    //      {0x03,0x99,0x99},   /* D/A ch3 - T1 at 3.0 volts                    15MAR12 L.Cronk */*/
    //      {0x04,0x66,0x66},   /* D/A ch4 - T2 at 2.0 volts */
    //      {0x05,0x70,0xa3},   /* D/A ch5 - sine/cosine 2.2v (old TACH1)*/
    //      {0x06,0x2e,0x14},   /* D/A ch6 - inverse sine/cosine .9v (old TACH2) */
    //      {0x27,0x00,0x00}};  /* D/A ch7 - not used  */
    //const short cal_DtoA_load7[8][3] = {
    //      {0x00,0xb3,0x32},   /* D/A ch0 - p1 at 3.5 volts */
    //      {0x01,0xb3,0x32},   /* D/A ch1 - p2 at 3.5 volts */
    //      {0x02,0xb3,0x32},   /* D/A ch2 - p3 at 3.5 volts */
    //      {0x03,0xb3,0x32},   /* D/A ch3 - T1 at 3.5 volts                    15MAR12 L.Cronk */*/
    //      {0x04,0x4c,0xcc},   /* D/A ch4 - T2 at 1.5 volts */
    //      {0x05,0x70,0xa3},   /* D/A ch5 - sine/cosine 2.2v (old TACH1)*/
    //      {0x06,0x2e,0x14},   /* D/A ch6 - inverse sine/cosine .9v (old TACH2) */
    //      {0x27,0x00,0x00}};  /* D/A ch7 - not used  */
    const short cal_DtoA_load8[8][3] = {
            {0x00,0x5b,0xcb},   /* D/A ch0 - MSB Sin    at 1.79 volts  at 225degs CAL set B, all at 100% */
            {0x01,0x5b,0xcb},   /* D/A ch1 - MSB Cos    at 1.79 volts */
            {0x02,0xa4,0x33},   /* D/A ch2 - MSB InvSin at 3.20 volts */
            {0x03,0xa4,0x33},   /* D/A ch3 - MSB InvCos at 3.20 volts */
            {0x04,0x3e,0xc1},   /* D/A ch4 - TC Sin     at 1.22 volts */
            {0x05,0x3e,0xc1},   /* D/A ch5 - TC Cos     at 1.22 volts */
            {0x06,0xcc,0xcc},   /* D/A ch6 - T1         at 4.0  volts           29MAR12 L.Cronk */
            {0x27,0x33,0x33}};  /* D/A ch7 - T2         at 1.0  volts           30OCT12 Fix     */
    //const short cal_DtoA_load9[8][3] = {
    //      {0x00,0xe6,0x65},   /* D/A ch0 - p1 at 4.5 volts */
    //      {0x01,0xe6,0x65},   /* D/A ch1 - p2 at 4.5 volts */
    //      {0x02,0xe6,0x65},   /* D/A ch2 - p3 at 4.5 volts */
    //      {0x03,0xe6,0x65},   /* D/A ch3 - T1 at 4.5 volts                    15MAR12 L.Cronk */*/
    //      {0x04,0x19,0x99},   /* D/A ch4 - T2 at 0.5 volts */
    //      {0x05,0x70,0xa3},   /* D/A ch5 - sine/cosine 2.2v (old TACH1)*/
    //      {0x06,0x2e,0x14},   /* D/A ch6 - inverse sine/cosine .9v (old TACH2) */
    //      {0x27,0x00,0x00}};  /* D/A ch7 - not used  */
    const short cal_DtoA_load10[8][3] = {
            {0x00,0xac,0x56},   /* D/A ch0 - MSB Sin    at 3.36 volts  at 60deg */
            {0x01,0x99,0x99},   /* D/A ch1 - MSB Cos    at 3.00 volts  at 60deg */
            {0x02,0x53,0xa8},   /* D/A ch2 - MSB InvSin at 1.63 volts  at 60deg 100% */
            {0x03,0x66,0x66},   /* D/A ch3 - MSB InvCos at 2.00 volts  at 60deg 100%    04APR12 L.Cronk */
            {0x04,0x6f,0x15},   /* D/A ch4 - TC Sin     at 2.17 volts  at 60deg */
            {0x05,0x63,0xd6},   /* D/A ch5 - TC Cos     at 1.95 volts  at 60deg*/
            {0x06,0x7f,0xff},   /* D/A ch6 - T1         at 2.5  volts                   0 amps */
            {0x27,0x7f,0xff}};  /* D/A ch7 - T2         at 2.5  volts                   0 amps */



    const short cal_DtoA_load11[8][3] = {
            {0x00,0xac,0x56},   /* D/A ch0 - MSB Sin    at 3.36 volts  at 60deg */
            {0x01,0x99,0x99},   /* D/A ch1 - MSB Cos    at 3.00 volts  at 60deg */
            {0x02,0x53,0xa8},   /* D/A ch2 - MSB InvSin at 1.63 volts  at 60deg 100% */
            {0x03,0x66,0x66},   /* D/A ch3 - MSB InvCos at 2.00 volts  at 60deg 100%    04APR12 L.Cronk */
            {0x04,0x6f,0x15},   /* D/A ch4 - TC Sin     at 2.17 volts  at 60deg */
            {0x05,0x63,0xd6},   /* D/A ch5 - TC Cos     at 1.95 volts  at 60deg*/
            {0x06,0x66,0x66},   /* D/A ch6 - T1         at 2.0  volts                   5,15,25,40 and 100 amps */
            {0x27,0x99,0x99}};  /* D/A ch7 - T2         at 3.0  volts                   5,15,25,40 and 100 amps */


    const short cal_DtoA_load12[8][3] = {
            {0x00,0xac,0x56},   /* D/A ch0 - MSB Sin    at 3.36 volts  at 60deg */
            {0x01,0x99,0x99},   /* D/A ch1 - MSB Cos    at 3.00 volts  at 60deg */
            {0x02,0x53,0xa8},   /* D/A ch2 - MSB InvSin at 1.63 volts  at 60deg 100% */
            {0x03,0x66,0x66},   /* D/A ch3 - MSB InvCos at 2.00 volts  at 60deg 100%    04APR12 L.Cronk */
            {0x04,0x6f,0x15},   /* D/A ch4 - TC Sin     at 2.17 volts  at 60deg */
            {0x05,0x63,0xd6},   /* D/A ch5 - TC Cos     at 1.95 volts  at 60deg*/
            {0x06,0x33,0x33},   /* D/A ch6 - T1         at 1.0  volts                   10,20,35 and 46 amps */
            {0x27,0xcc,0xcc}};  /* D/A ch7 - T2         at 4.0  volts                   10,20,35 and 46 amps */



    const short cal_DtoA_load13[8][3] = {    /* SET ALL but TC ZEROl */
            {0x00,0x00,0x00},   /* D/A ch0 - MSB Sin    0V  */
            {0x01,0x00,0x00},   /* D/A ch1 - MSB Cos    0V   */
            {0x02,0x00,0x00},   /* D/A ch2 - MSB InvSin 0V  */
            {0x03,0x00,0x00},   /* D/A ch3 - MSB InvCos 0V  */
            {0x04,0x6f,0x15},   /* D/A ch4 - TC Sin     at 2.17 volts  at 60deg 19July13 P. Horny - Need to keep these active or DTCs flag*/
            {0x05,0x63,0xd6},   /* D/A ch5 - TC Cos     at 1.95 volts  at 60deg 19July13 P. Horny - Need to keep these active or DTCs flag*/
            {0x06,0x00,0x00},   /* D/A ch6 - T1         0V */
            {0x27,0x00,0x00}};  /* D/A ch7 - T2         0V */



    const short cal_DtoA_load15[8][3] = {
            {0x00,0xac,0x56},   /* D/A ch0 - MSB Sin    at 3.36 volts  at 60deg */
            {0x01,0x99,0x99},   /* D/A ch1 - MSB Cos    at 3.00 volts  at 60deg */
            {0x02,0x53,0xa8},   /* D/A ch2 - MSB InvSin at 1.63 volts  at 60deg 100% */
            {0x03,0x66,0x66},   /* D/A ch3 - MSB InvCos at 2.00 volts  at 60deg 100%    04APR12 L.Cronk */
            {0x04,0x6f,0x15},   /* D/A ch4 - TC Sin     at 2.17 volts  at 60deg */
            {0x05,0x63,0xd6},   /* D/A ch5 - TC Cos     at 1.95 volts  at 60deg*/
            {0x06,0x99,0x99},   /* D/A ch6 - T1         at 3.0  volts                   5,15,25,40 and 100 amps */
            {0x27,0x66,0x66}};  /* D/A ch7 - T2         at 2.0  volts                   5,15,25,40 and 100 amps */


    const short cal_DtoA_load16[8][3] = {
            {0x00,0xac,0x56},   /* D/A ch0 - MSB Sin    at 3.36 volts  at 60deg */
            {0x01,0x99,0x99},   /* D/A ch1 - MSB Cos    at 3.00 volts  at 60deg */
            {0x02,0x53,0xa8},   /* D/A ch2 - MSB InvSin at 1.63 volts  at 60deg 100% */
            {0x03,0x66,0x66},   /* D/A ch3 - MSB InvCos at 2.00 volts  at 60deg 100%    04APR12 L.Cronk */
            {0x04,0x6f,0x15},   /* D/A ch4 - TC Sin     at 2.17 volts  at 60deg */
            {0x05,0x63,0xd6},   /* D/A ch5 - TC Cos     at 1.95 volts  at 60deg*/
            {0x06,0xcc,0xcc},   /* D/A ch6 - T1         at 4.0  volts                   10,20,35 and 46 amps */
            {0x27,0x33,0x33}};  /* D/A ch7 - T2         at 1.0  volts                   10,20,35 and 46 amps */



      // new default D/A to set all at 2.5v when doing the Vref flag check
      // before, having inv sine/cos at .9v was 'pulling down' the 2.5 volt ref check
      // and causing it to fail.

    const short cal_DtoA_load17[8][3] = {
            {0x00,0x7f,0xff},   // all set to 2.5V
            {0x01,0x7f,0xff},
            {0x02,0x7f,0xff},
            {0x03,0x7f,0xff},
            {0x04,0x7f,0xff},                                                   /* 15MAR12 L.Cronk */
            {0x05,0x7f,0xff},
            {0x06,0x7f,0xff},
            {0x27,0x7f,0xff}};


    /* -------------   T E S T   A N A L O G    O U T P U T   D A T A   ( Primarily Used by Calibration Lab for certification )  ----  */
    const short test_DtoA_load0[8][3] = {
            {0x00,0x00,0x00},   /* D/A ch0 - MSB Sin    at 0.0 volts */
            {0x01,0x00,0x00},   /* D/A ch1 - MSB Cos    at 0.0 volts */
            {0x02,0x00,0x00},   /* D/A ch2 - MSB InvSin at 0.0 volts */
            {0x03,0x00,0x00},   /* D/A ch3 - MSB InvCos at 0.0 volts */
            {0x04,0x00,0x00},   /* D/A ch4 - TC Sin     at 0.0 volts */
            {0x05,0x00,0x00},   /* D/A ch5 - TC Cos     at 0.0 volts */
            {0x06,0x00,0x00},   /* D/A ch6 - T1         at 0.0 volts */
            {0x27,0x00,0x00}};  /* D/A ch7 - T2         at 0.0 volts */
    const short test_DtoA_load1[8][3] = {
            {0x00,0x19,0x99},   /* D/A ch0 - MSB Sin    at 0.5 volts */
            {0x01,0x19,0x99},   /* D/A ch1 - MSB Cos    at 0.5 volts */
            {0x02,0x19,0x99},   /* D/A ch2 - MSB InvSin at 0.5 volts */
            {0x03,0x19,0x99},   /* D/A ch3 - MSB InvCos at 0.5 volts */
            {0x04,0x19,0x99},   /* D/A ch4 - TC Sin     at 0.5 volts */
            {0x05,0x19,0x99},   /* D/A ch5 - TC Cos     at 0.5 volts */
            {0x06,0x19,0x99},   /* D/A ch6 - T1         at 0.5 volts */
            {0x27,0x19,0x99}};  /* D/A ch7 - T2         at 0.5 volts */
    const short test_DtoA_load2[8][3] = {
            {0x00,0x33,0x33},   /* D/A ch0 - MSB Sin    at 1.0 volts */
            {0x01,0x33,0x33},   /* D/A ch1 - MSB Cos    at 1.0 volts */
            {0x02,0x33,0x33},   /* D/A ch2 - MSB InvSin at 1.0 volts */
            {0x03,0x33,0x33},   /* D/A ch3 - MSB InvCos at 1.0 volts */
            {0x04,0x33,0x33},   /* D/A ch4 - TC Sin     at 1.0 volts */
            {0x05,0x33,0x33},   /* D/A ch5 - TC Cos     at 1.0 volts */
            {0x06,0x33,0x33},   /* D/A ch6 - T1         at 1.0 volts */
            {0x27,0x33,0x33}};  /* D/A ch7 - T2         at 1.0 volts */
    const short test_DtoA_load3[8][3] = {
            {0x00,0x4c,0xcc},   /* D/A ch0 - MSB Sin    at 1.5 volts */
            {0x01,0x4c,0xcc},   /* D/A ch1 - MSB Cos    at 1.5 volts */
            {0x02,0x4c,0xcc},   /* D/A ch2 - MSB InvSin at 1.5 volts */
            {0x03,0x4c,0xcc},   /* D/A ch3 - MSB InvCos at 1.5 volts */
            {0x04,0x4c,0xcc},   /* D/A ch4 - TC Sin     at 1.5 volts */
            {0x05,0x4c,0xcc},   /* D/A ch5 - TC Cos     at 1.5 volts */
            {0x06,0x4c,0xcc},   /* D/A ch6 - T1         at 1.5 volts */
            {0x27,0x4c,0xcc}};  /* D/A ch7 - T2         at 1.5 volts */
    const short test_DtoA_load4[8][3] = {
            {0x00,0x66,0x66},   /* D/A ch0 - MSB Sin    at 2.0 volts */
            {0x01,0x66,0x66},   /* D/A ch1 - MSB Cos    at 2.0 volts */
            {0x02,0x66,0x66},   /* D/A ch2 - MSB InvSin at 2.0 volts */
            {0x03,0x66,0x66},   /* D/A ch3 - MSB InvCos at 2.0 volts */
            {0x04,0x66,0x66},   /* D/A ch4 - TC Sin     at 2.0 volts */
            {0x05,0x66,0x66},   /* D/A ch5 - TC Cos     at 2.0 volts */
            {0x06,0x66,0x66},   /* D/A ch6 - T1         at 2.0 volts */
            {0x27,0x66,0x66}};  /* D/A ch7 - T2         at 2.0 volts */
    const short test_DtoA_load5[8][3] = {
            {0x00,0x7f,0xff},   /* D/A ch0 - MSB Sin    at 2.5 volts */
            {0x01,0x7f,0xff},   /* D/A ch1 - MSB Cos    at 2.5 volts */
            {0x02,0x7f,0xff},   /* D/A ch2 - MSB InvSin at 2.5 volts */
            {0x03,0x7f,0xff},   /* D/A ch3 - MSB InvCos at 2.5 volts */
            {0x04,0x7f,0xff},   /* D/A ch4 - TC Sin     at 2.5 volts */
            {0x05,0x7f,0xff},   /* D/A ch5 - TC Cos     at 2.5 volts */
            {0x06,0x7f,0xff},   /* D/A ch6 - T1         at 2.5 volts */
            {0x27,0x7f,0xff}};  /* D/A ch7 - T2         at 2.5 volts */
    const short test_DtoA_load6[8][3] = {
            {0x00,0x99,0x99},   /* D/A ch0 - MSB Sin    at 3.0 volts */
            {0x01,0x99,0x99},   /* D/A ch1 - MSB Cos    at 3.0 volts */
            {0x02,0x99,0x99},   /* D/A ch2 - MSB InvSin at 3.0 volts */
            {0x03,0x99,0x99},   /* D/A ch3 - MSB InvCos at 3.0 volts */
            {0x04,0x99,0x99},   /* D/A ch4 - TC Sin     at 3.0 volts */
            {0x05,0x99,0x99},   /* D/A ch5 - TC Cos     at 3.0 volts */
            {0x06,0x99,0x99},   /* D/A ch6 - T1         at 3.0 volts */
            {0x27,0x99,0x99}};  /* D/A ch7 - T2         at 3.0 volts */
    const short test_DtoA_load7[8][3] = {
            {0x00,0xb3,0x32},   /* D/A ch0 - MSB Sin    at 3.5 volts */
            {0x01,0xb3,0x32},   /* D/A ch1 - MSB Cos    at 3.5 volts */
            {0x02,0xb3,0x32},   /* D/A ch2 - MSB InvSin at 3.5 volts */
            {0x03,0xb3,0x32},   /* D/A ch3 - MSB InvCos at 3.5 volts */
            {0x04,0xb3,0x32},   /* D/A ch4 - TC Sin     at 3.5 volts */
            {0x05,0xb3,0x32},   /* D/A ch5 - TC Cos     at 3.5 volts */
            {0x06,0xb3,0x32},   /* D/A ch6 - T1         at 3.5 volts */
            {0x27,0xb3,0x32}};  /* D/A ch7 - T2         at 3.5 volts */
    const short test_DtoA_load8[8][3] = {
            {0x00,0xcc,0xcc},   /* D/A ch0 - MSB Sin    at 4.0 volts */
            {0x01,0xcc,0xcc},   /* D/A ch1 - MSB Cos    at 4.0 volts */
            {0x02,0xcc,0xcc},   /* D/A ch2 - MSB InvSin at 4.0 volts */
            {0x03,0xcc,0xcc},   /* D/A ch3 - MSB InvCos at 4.0 volts */
            {0x04,0xcc,0xcc},   /* D/A ch4 - TC Sin     at 4.0 volts */
            {0x05,0xcc,0xcc},   /* D/A ch5 - TC Cos     at 4.0 volts */
            {0x06,0xcc,0xcc},   /* D/A ch6 - T1         at 4.0 volts */
            {0x27,0xcc,0xcc}};  /* D/A ch7 - T2         at 4.0 volts */
    const short test_DtoA_load9[8][3] = {
            {0x00,0xe6,0x65},   /* D/A ch0 - MSB Sin    at 4.5 volts */
            {0x01,0xe6,0x65},   /* D/A ch1 - MSB Cos    at 4.5 volts */
            {0x02,0xe6,0x65},   /* D/A ch2 - MSB InvSin at 4.5 volts */
            {0x03,0xe6,0x65},   /* D/A ch3 - MSB InvCos at 4.5 volts */
            {0x04,0xe6,0x65},   /* D/A ch4 - TC Sin     at 4.5 volts */
            {0x05,0xe6,0x65},   /* D/A ch5 - TC Cos     at 4.5 volts */
            {0x06,0xe6,0x65},   /* D/A ch6 - T1         at 4.5 volts */
            {0x27,0xe6,0x65}};  /* D/A ch7 - T2         at 4.5 volts */
    const short test_DtoA_load10[8][3] = {
            {0x00,0xff,0xff},   /* D/A ch0 - MSB Sin    at 5.0 volts */
            {0x01,0xff,0xff},   /* D/A ch1 - MSB Cos    at 5.0 volts */
            {0x02,0xff,0xff},   /* D/A ch2 - MSB InvSin at 5.0 volts */
            {0x03,0xff,0xff},   /* D/A ch3 - MSB InvCos at 5.0 volts */
            {0x04,0xff,0xff},   /* D/A ch4 - TC Sin     at 5.0 volts */
            {0x05,0xff,0xff},   /* D/A ch5 - TC Cos     at 5.0 volts */
            {0x06,0xff,0xff},   /* D/A ch6 - T1         at 5.0 volts */
            {0x27,0xff,0xff}};  /* D/A ch7 - T2         at 5.0 volts */



    const short test_DtoA_load17[8][3] = {
            {0x00,0x7f,0xff},   // all set to 2.5V
            {0x01,0x7f,0xff},
            {0x02,0x7f,0xff},
            {0x03,0x7f,0xff},
            {0x04,0x7f,0xff},                                                   /* 15MAR12 L.Cronk */
            {0x05,0x7f,0xff},
            {0x06,0x7f,0xff},
            {0x27,0x7f,0xff}};      // Write command to update "all" and ch7 data


    /* --------- G L O B A L   F L E X R A Y   stuff  --------------------------------------------------------------------  */

//    const unsigned char fray_Nexteer_session1[]                          = {0x00, 0xFB, 0x30, 0x01};
//    const unsigned char fray_Nexteer_session2 []                         = {0xFF, 0x7E, 0x10, 0x02};
//// not used ?    const unsigned char Nexteer_Ack  []                             = {0x34, 0xFB, 0x30, 0x01};
//    // not used ?    uint32 go_ahead = 0;
    uint8 HW_ACK[64][4] = {0};
    uint8 fray_rx_data[64][4] = {0};     // storage for CAN rec data[D_SIZE] = {0};
    int fray_rx_data_length;
    uint8 swapped_fray_rx_data[64][4] = {0};
    int fray_request_index;
    uint8_t fray_dump_err_data[40][9];      // storage for Flex/CAN response messages, must store response and process in MAIN, error stack if sprintf called from ISR


    extern headerSectionConfig headerSectionConfigStruct;
    extern    headerSectionConfig *currentMessageBufferSettings;
    extern   bufferTransferConfig bufferTransferConfigStruct;
    extern    bufferTransferConfig *bufferTransferSettings;

    //Flexray Error notification variables for dumps/restart bus, etc
    extern int fray_error_flag;                     //used in main to restart fray comms if bus_halt error detected.
    extern int fray_error_occurred_flag;            //set to 0 after dumperr/data sent, indicates jump to frayErrorNotif occurred
    extern int fray_error_counter;                  //counts # of times frayErrorNotif has been called, set limit on this to max uint32 counts
    extern uint32 fray_error_notification;          //stores which notification caused frayErrorNotif
    extern int wait_for_fray_cold_start_node_flag;  //Set to 1 in frayStartCommunication() if cold start not active (flexray_comm_status_vector_CCSV == 0x2). Period check of cold start node in rtiNotif until detect it is active.
    extern uint32 flexray_comm_status_vector_CCSV;  //Used to check cold start node active.

    // used to build messages
    uint8 MFG_TX_nexteer_session_MSG[64][4] = {0};
    uint8 Nexteer_session[64][4] = {0};
    uint8 XCP_TX_request_connect_MSG[64][4] = {0};

    uint8 MFG_TX_system_state_MSG[64][4]        ={0};
    uint8 MFG_TX_request_software_version_MSG[64][4]={0};
    uint8 MFG_TX_request_software_rev_MSG[64][4]    ={0};
    uint8 MFG_TX_get_dtcs_MSG[64][4]            ={0};
    uint8 MFG_TX_clear_dtcs_MSG[64][4]          ={0};
    uint8 MFG_TX_cca_part_num_MSG[64][4]        ={0};
    uint8 MFG_TX_sys_serial_num_MSG[64][4]      ={0};
    uint8 MFG_TX_mtr_trq_cmd_MSG[64][4] ;

    int system_state_MFG;
    char software_version_MFG[100];
    char software_rev_MFG[10];

    //---------------------------------B M W   U K L---------------------------------------------------------

    extern flexrayPacket *KLEMMEN;

    extern flexrayPacket VEH_COG_struct;
    extern flexrayPacket *VEH_COG;

    extern flexrayPacket DT_PT_struct;
    extern flexrayPacket *DT_PT;

    extern flexrayPacket AVL_struct;
    extern flexrayPacket *AVL;

    extern flexrayPacket XCP_TX_struct;
    extern flexrayPacket *XCP_TX;

    extern flexrayPacket XCP_RX_struct;
    extern flexrayPacket *XCP_RX;

    extern flexrayPacket MFG_TX_struct;
    extern flexrayPacket *MFG_TX;

    extern flexrayPacket MFG_RX_struct;
    extern flexrayPacket *MFG_RX;

    uint8 KLEMMEN_MSG[64][4] = {0};
    uint8 DT_PT_MSG[64][4] = {0};
    uint8 VEH_COG_MSG[64][4] = {0};

    uint8 XCP_UKL_Batt_Volt_Rqst[64][4] = {0};
    uint8 XCP_UKL_Batt_Curr_Rqst[64][4] = {0};
    uint8 XCP_UKL_Mot_Curr_Rqst[64][4] = {0};
    uint8 XCP_UKL_Mot_Vel_Rqst[64][4] = {0};
    uint8 XCP_UKL_Comm_Torque_Rqst[64][4] = {0};
    uint8 XCP_UKL_Lim_Torque_Rqst[64][4] = {0};
    uint8 XCP_UKL_PCB_Temp_Rqst[64][4] = {0};
    uint8 XCP_UKL_Mot_Temp_Rqst[64][4] = {0};
    uint8 XCP_UKL_Junction_Temp_Rqst[64][4] = {0};
    uint8 XCP_UKL_HW_Angle_Rqst[64][4] = {0};
    uint8 XCP_UKL_Diff_Torque_Rqst[64][4] = {0};
    uint8 XCP_UKL_sys_state_Rqst[64][4] = {0};
    uint8 XCP_UKL_T1_Volt_Rqst[64][4] = {0};
    uint8 XCP_UKL_T2_Volt_Rqst[64][4] = {0};

    uint8 Get_UKL_DTC_Rqst[64][4] = {0};

//    const unsigned char BMW_UKL_Nexteer_Ack[] = {0x34, 0xFB, 0x30, 0x01};

    short KLEMMEN_CNT = 0;
    short DT_PT_CNT = 0;
    short VEH_COG_CNT = 0;

//    const unsigned char ccp_UKL_request_cal_Batt_Volt_str[]             = {0x04,0x90,0x01,0x08};  // MSB sine 2 byte u3p13
//    const unsigned char ccp_UKL_request_cal_Batt_Curr_str[]             = {0xA0,0x88,0x01,0x08};  // MSB cosine 2 byte u3p13
//    const unsigned char ccp_UKL_request_cal_Mot_Curr_str[]              = {0x94,0x90,0x01,0x08};  // MSB Invsine 2 byte u3p13
//    const unsigned char ccp_UKL_request_cal_Mot_Vel_str[]               = {0xAC,0xA2,0x01,0x08};  // MSB Invcos 2 byte u3p13
//
//    const unsigned char ccp_UKL_request_Comm_Torque_str[]               = {0xF8,0xA1,0x01,0x08};  // 4 byte float
//    const unsigned char ccp_UKL_request_Lim_Torque_str[]                = {0xEC,0xA1,0x01,0x08};  // 4 byte float
//
//    const unsigned char ccp_UKL_request_PCB_Temp_str[]                  = {0x0C,0x90,0x01,0x08};  // 2 byte  Changed to u3p13
//    const unsigned char ccp_UKL_request_Mot_Temp_str[]                  = {0xC0,0x90,0x01,0x08};  // 2 byte  Changed to u3p13
//
//    const unsigned char ccp_UKL_request_Junction_Temp_str[]             = {0xBC,0x90,0x01,0x08};  // 4 byte float
//    const unsigned char ccp_UKL_request_HW_Angle_str[]                  = {0xDC,0xA1,0x01,0x08};  // 1 byte
//    const unsigned char ccp_UKL_request_Diff_Torque_str[]               = {0x30,0x90,0x01,0x08};  // 4 byte float
//    const unsigned char ccp_UKL_request_sys_state_byt[]                 = {0xC4,0xA3,0x01,0x08};  // 1 byte
//    const unsigned char ccp_UKL_request_T1_Volt_str[]                   = {0x74,0x90,0x01,0x08};  // 4 byte float
//    const unsigned char ccp_UKL_request_T2_Volt_str[]                   = {0x78,0x90,0x01,0x08};  // 4 byte float

//    const unsigned char fray_EA3_Get_DTC_rqst1[]                             = {0x00, 0xFB, 0x30, 0x01};
//    const unsigned char fray_EA3_Get_DTC_rqst2[]                             = {0x13, 0xFD, 0x22, 0x03};


    //---------------------------------- END OF BMW UKL FLEXRAY STUFF --------------------------------------------------------------------------


    //-----------F A A R    W E ------------------------------------------------------------------------------------------------------------

    extern flexrayPacket CON_VEH_FAAR_WE_struct;
    extern flexrayPacket *CON_VEH_FAAR_WE;

    extern flexrayPacket ST_CENG_FAAR_WE_struct;
    extern flexrayPacket *ST_CENG_FAAR_WE;

    extern flexrayPacket VEH_COG_FAAR_WE_struct;
    extern flexrayPacket *VEH_COG_FAAR_WE;

//    const unsigned char BMW_FAAR_WE_Nexteer_Ack[] = {0xC0, 0x07, 0x00, 0x83};

    uint8 CON_VEH_FAAR_WE_MSG[64][4] = {0};
    uint8 ST_CENG_FAAR_WE_MSG[64][4] = {0};
    uint8 VEH_COG_FAAR_WE_MSG[64][4] = {0};

    uint8 VEH_COG_FAAR_WE_MSG_0kph[4]       = {0x00, 0x00, 0xD0, 0x00}; //0xC0 = near-stand still
    uint8 VEH_COG_FAAR_WE_MSG_load_kph[4]   = {0x00, 0x00, 0xD0, 0x00}; //0xD0 = not near stand-still, i have to find out what threshold is required.
    uint8 VEH_COG_FAAR_WE_MSG_valid_msg[4]  = {0x00, 0x00, 0x00, 0x81};

    uint8 XCP_FAAR_WE_TesterPresent_Rqst_MSG[64][4];

    uint8 XCP_FAAR_WE_SysStMod_Rqst[64][4];
    uint8 XCP_FAAR_WE_BattVltg_BrdgVltg_Rqst[64][4];
    uint8 XCP_FAAR_WE_BattRtnCurrAmpr_Rqst[64][4];
    uint8 XCP_FAAR_WE_HwAgArbn_Rqst[64][4];
    uint8 XCP_FAAR_WE_HwTq4Meas_Rqst[64][4];
    uint8 XCP_FAAR_WE_HwTq5Meas_Rqst[64][4];
    uint8 XCP_FAAR_WE_HwTqArbn_Rqst[64][4];
    uint8 XCP_FAAR_WE_MotCurrSumA_Rqst[64][4];
    uint8 XCP_FAAR_WE_MotCurrSumB_Rqst[64][4];
    uint8 XCP_FAAR_WE_MotCurrSumC_Rqst[64][4];
    uint8 XCP_FAAR_WE_MotVelCrf_Rqst[64][4];
    uint8 XCP_FAAR_WE_MotTqCmd_Rqst[64][4];
    uint8 XCP_FAAR_WE_MotTqEstimd_Rqst[64][4];
    uint8 XCP_FAAR_WE_LoaSca_Rqst[64][4];
    uint8 XCP_FAAR_WE_EcuTMeas_Rqst[64][4];
    uint8 XCP_FAAR_WE_MotWidgT_Rqst[64][4];
    uint8 XCP_FAAR_WE_MotMagT_Rqst[64][4];
    uint8 XCP_FAAR_WE_MotFetT_Rqst[64][4];


//    uint8 XCP_FAAR_WE_MotTq_Rqst[64][4];

    uint8 fray_EA4_Get_DTC_Rqst[64][4] = {0};

    short CON_VEH_FAAR_WE_CNT = 0;
    short ST_CENG_FAAR_W_CNT = 0;
    uint8 VEH_COG_FAAR_WE_CNT = 0;

//    const unsigned char fray_EA4_Get_DTC_Rqst1[]                    = {0x00, 0xFB, 0x30, 0x01};
//    const unsigned char fray_EA4_Get_DTC_Rqst2[]                    = {0x60, 0xFD, 0x22, 0x03};

    uint8 XCP_output_counter = 0;


    //---------------------------------- END OF FAAR WE FLEXRAY STUFF --------------------------------------------------------------------------

    //----------------------------MTS variables for systems lab machine control and feedback--------------------------------------------------

    float MTS_Vehicle_Speed_flt; // float variable for vehicle speed from the MTS machine
    uint16 MTS_Vehicle_Speed_uint16; // vehicle speed converted to 16 bit (2 bytes) form float
    uint8 MTS_Vehicle_Speed_HEX_LoByte; // scaled low byte HEX value of vehicle speed
    uint8 MTS_Vehicle_Speed_HEX_HiByte; // scaled high byte HEX value of vehicle speed

    uint8 MTS_Store_DAQ_Data_Mode_HEX_Byte; // variable for getting DAQ storage mode from the MTS machine and outputting the value
    // in the output stream to signal the LabView app to store(1) or NOT store(0) data

    uint8 MTS_running_flag; //byte set in canMessagenotif if getting CAN messages from MTS. 8 sec no CAN, send p_off from rti_notif
    int MTS_running_counter;

    uint8 MTS_System_State_HEX_Byte; // byte to store system state from the MTS machine
    uint8 MTS_System_State_HEX_Byte_old; // byte to check for CHANGE of system state from the MTS machine
    uint8 MTS_System_State_change_flag; // flag to signal a change in desired system state coming from the MTS stand

    float MTS_Angle_Cmd_fp_in; // float variable to store Angle command from MTS to Device
    float MTS_Torque_Cmd_fp_in; // float variable to store torque command from MTS to Device
    float old_MTS_torque_Cmd_fp_in;

    uint8 MTS_Bus_Fault_State_HEX_Byte;    // byte to store MTS Bus fault state

    float DUT_Motor_torque_fp; //variable to store motor torque value for comparison to input from MTS
    unsigned char DUT_Motor_Angle_out_str[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00 }; // string for CAN out message for DUT Motor Angle out fp
    unsigned char DUT_Motor_Torque_out_str[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00 }; // string for CAN out message for DUT Motor Torque out fp on CAN bus#2
    unsigned char DUT_Motor_Current_out_str[] = { 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00 }; //string for CAN out message for DUT Motor Current out fp on CAN bus#2
    unsigned char DUT_Motor_Temp_out_str[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00 }; // string for CAN out message for DUT Motor Temo out fp on CAN bus#2
    unsigned char DUT_Controller_Current_out_str[] = { 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00 }; // string for CAN out message for DUT Controller Current out fp on CAN bus#2

    uint8 General_Fault_state_out_flag;        // byte to hold fault ststae status
    uint8 Fault_FET_temp_out_flag;      // byte to hold fault FET temperature status
    uint8 Fault_Motor_temp_out_flag;         // byte to hold fault motor temp status

    unsigned char General_Fault_state_out_str[] = { 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00 }; // string for CAN out message for DUT Motor Angle out fp
    unsigned char Fault_FET_temp_out_str[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00 }; // string for CAN out message for DUT Motor Torque out fp on CAN bus#2
    unsigned char Fault_Motor_temp_out_str[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00 };

    //----------------------------END OF  MTS variables for systems lab machine control and feedback------------------------------------------

    //------------------------------------- Generic DAQ mode vars -----------------------------------------------------------------------------
    extern unsigned int number_of_DAQ_variables;
    extern int DAQ_mode_step_cntr;
    extern unsigned int DAQ_mode_on_off;
    extern const unsigned char XCP_connect[];
    extern int print_data_flag;
    extern int Set_DAQ_List_mode_DAQ_rate;

    extern  struct variable_input {
        char name[100];
        uint8 address[4];
        uint8 data[9];
        char type[15];
    } variable_info[30];

    // new rev07
    extern int buffered_idx;

    #define CAN 0
    #define FRAY 1
    int comm_is_CAN_or_FRAY = FRAY;     //value is required for printing DAQ data
    char endian[15] = "little_endian";  //value is required for printing DAQ data
    char target_processor[15] = "renesis"; //not used for anything yet

    //Suggest using generic variable names for DAQ mode XCP stuff. Just point it to the appropriate message box.
    #define CAN_XCP_DAQ_TX canMESSAGE_BOX10 //Copy appropriate message box used for XCP over CAN
    #define CAN_XCP_DAQ_RX canMESSAGE_BOX11 //Copy appropriate message box used for XCP over CAN

    extern char temp_address[30][8]; //used to swap variable_info.address into the correct order for fray or endian

    extern uint8 XCP_Stop_all_selcted_DAQs_CAN[]; //used in start_daq_mode command
    extern uint8 XCP_Start_all_selcted_DAQs_CAN[]; //used in stop_daq_mode command

    extern uint8 XCP_Stop_all_selcted_DAQs_fray[64][4]; //used in start_daq_mode_command
    extern uint8 XCP_Start_all_selcted_DAQs_fray[64][4]; //used in stop_daq_mode command

    extern int call_start_daq_after_this_command_flag;

    int enable_data_stream_flag = 0;

    // --------------------------------------------- XCP Fast Rate Vars (XCP_fast_rate.c) -----------------------------------------------------------------------//
    extern int XCP_fast_rate_period;
    extern int XCP_fast_rate_active_flag;
    extern uint8_t XCP_fast_rate_data[30][9];

    // -----------------------------------------End of XCP Fast Rate Vars -----------------------------------------------------------------------//


    // -----------------------------------------variable input Vars (variable_input.c) -----------------------------------------------------------------------//
    extern int read_variables_flag;
    // -----------------------------------------End of variable input Vars -----------------------------------------------------------------------//
    // -----------------------------------------NTC_get.c Vars -----------------------------------------------------------------------//
    extern int NTC_get_period;
    extern int NTC_get_flag;
    extern int NTC_main_get_flag;
    extern int NTC_get_print_flag;

    // new rev06
    extern int MAX_ECU1_XCP_reply_index_bkgd;
    extern char dtc1_bkgd_return_message[257];
    // -----------------------------------------End of NTC_get.c Vars -----------------------------------------------------------------------//

    // -----------------------------------------L02 test only Vars -----------------------------------------------------------------------//
    int MTS_available_flag = NO; //flag in main when printing_daq_variables to append MTS data
    int MTS_only_print = 0;
    // --------------------------------------End of L02 test only Vars -----------------------------------------------------------------------//
    extern int debug_flag1;
    extern int debug_flag2;
    extern int debug_flag3;
    extern int debug_flag4;

    // Debug Phil
    unsigned long temp_clock_grab_beginning;
    unsigned long temp_clock_grab_ending;

/* USER CODE END */

/** @fn void main(void)
*   @brief Application main function
*   @note This function is empty by default.
*
*   This function is called after startup.
*   The user can use this function to implement the application.
*/

/* USER CODE BEGIN (2) */



/* USER CODE END */

int main(void)
{
/* USER CODE BEGIN (3) */

    /************************************************************************************************
    /************************************************************************************************
     * DAQ MODE VARIABLE INIT:
     * Input variable information in generic structure for DAQ_mode.c. (someday can use for dumperr?)
     * Leave un-used as \0 = NULL
     * */
    number_of_DAQ_variables = 15; //This determines how many DAQ requests are built, sent, and printed.
                                  //16 seems to be max for BMW Faar We at the moment

    //L02 things to re-transmit:
    //D1 Motor Angle FB (bus)
    //D1 Motor Torque FB (bus)
    //D1 Motor Current FB (bus)
    //D1 Motor Temp FB (bus)
    //D1 Controller Current FB (bus)

    // new rev07
    strcpy(variable_info[0].name, "Rte_CDD_MotAgCmp_DigMotHwPosn"); /* 1 */ //_Rte_SysStMod_SysSt_Val
    strcpy(variable_info[1].name, "Rte_AssiSumLim_MotTqCmd_Val"); /* 2 */
    strcpy(variable_info[2].name, "Rte_CDD_MotCtrlMgr_MotCurrQax_Val"); /* 3 */
    strcpy(variable_info[3].name, "Rte_TEstimn_MotWidgT_Val"); /* 4 */
    strcpy(variable_info[4].name, "Rte_EcuTMeas_EcuTFild_Val"); /* 5 */
    strcpy(variable_info[5].name, "Rte_SysStMod_SysSt_Val"); /* 6 */
    strcpy(variable_info[6].name, "Rte_BattVltg_BrdgVltg_Val"); /* 7 */
    strcpy(variable_info[7].name, "Rte_HwTqArbn_HwTq_Val"); /* 8 */
    strcpy(variable_info[8].name, "Rte_CDD_HwTq4Meas_HwTq4_Val"); /* 9 */
    strcpy(variable_info[9].name, "Rte_CDD_HwTq5Meas_HwTq5_Val"); /* 10 */
    strcpy(variable_info[10].name, "Rte_TEstimn_AssiMechT_Val"); /* 11 */
    strcpy(variable_info[11].name, "Rte_TEstimn_MotFetT_Val"); /* 12 */
    strcpy(variable_info[12].name, "Rte_TEstimn_MotWidgT_Val"); /* 13 */
    strcpy(variable_info[13].name, "Rte_EcuTMeas_dEcuTMeasEcuTCalcd"); /* 14 */
    strcpy(variable_info[14].name, "Rte_PwrLimr_MotTqCmdPwrLimd_Val"); /* 15 */
    strcpy(variable_info[15].name, "Rte_CDD_MotAgCmp_MotAgCumvAlgndMrf_Val"); /* 16 */
    strcpy(variable_info[16].name, "\0");/* 17 */
    strcpy(variable_info[17].name, "_Rte_TEstimn_MotFetT_Val"); /* 18 */
    strcpy(variable_info[18].name, "_Rte_TEstimn_MotFetT_Val"); /* 19 */
    strcpy(variable_info[19].name, "_Rte_TEstimn_MotFetT_Val"); /* 20 */
    strcpy(variable_info[20].name, "_Rte_TEstimn_MotFetT_Val"); /* 21 */
    strcpy(variable_info[21].name, "_Rte_TEstimn_MotFetT_Val"); /* 22 */
    strcpy(variable_info[22].name, "_Rte_TEstimn_MotFetT_Val"); /* 23 */
    strcpy(variable_info[23].name, "_Rte_TEstimn_MotFetT_Val"); /* 24 */
    strcpy(variable_info[24].name, "_Rte_TEstimn_MotFetT_Val"); /* 25 */
    strcpy(variable_info[25].name, "_Rte_TEstimn_MotFetT_Val"); /* 26 */
    strcpy(variable_info[26].name, "_Rte_TEstimn_MotFetT_Val"); /* 27 */
    strcpy(variable_info[27].name, "_Rte_TEstimn_MotFetT_Val"); /* 28 */
    strcpy(variable_info[28].name, "_Rte_TEstimn_MotFetT_Val"); /* 29 */
    strcpy(variable_info[29].name, "_Rte_TEstimn_MotFetT_Val"); /* 20 */

    //need to store strings into a temp variable, then swap address order based on endian-ness/FRAY below
    // new rev07
    strcpy(temp_address[0], "febf34f0");
    strcpy(temp_address[1], "febec4b4");
    strcpy(temp_address[2], "febec5c4");
    strcpy(temp_address[3], "febf70c0");
    strcpy(temp_address[4], "febf708c");
    strcpy(temp_address[5], "febec85a");
    strcpy(temp_address[6], "febec4d8");
    strcpy(temp_address[7], "febec648");
    strcpy(temp_address[8], "febec544");
    strcpy(temp_address[9], "febec548");
    strcpy(temp_address[10], "febf70ac");
    strcpy(temp_address[11], "febf70b8");
    strcpy(temp_address[12], "febf70c0");
    strcpy(temp_address[13], "febf7160");
    strcpy(temp_address[14], "febec6f4");
    strcpy(temp_address[15], "febec55c");
    strcpy(temp_address[16], "\0");
    strcpy(temp_address[17], "febf4b80");
    strcpy(temp_address[18], "febf4b80");
    strcpy(temp_address[19], "febf4b80");
    strcpy(temp_address[20], "febf4b80");
    strcpy(temp_address[21], "febf4b80");
    strcpy(temp_address[22], "febf4b80");
    strcpy(temp_address[23], "febf4b80");
    strcpy(temp_address[24], "febf4b80");
    strcpy(temp_address[25], "febf4b80");
    strcpy(temp_address[26], "febf4b80");
    strcpy(temp_address[27], "febf4b80");
    strcpy(temp_address[28], "febf4b80");
    strcpy(temp_address[29], "febf4b80");

    //take the addresses and swap them based on endian and fray/can
    // This copies addresses to variable_info.address in proper order for use
    swap_addresses_based_on_type();

    //Float
    //Char
    //Short
    strcpy(variable_info[0].type,"Float");
    strcpy(variable_info[1].type,"Float");
    strcpy(variable_info[2].type,"Float");
    strcpy(variable_info[3].type,"Float");
    strcpy(variable_info[4].type,"Float");
    strcpy(variable_info[5].type,"Char");
    strcpy(variable_info[6].type,"Float");
    strcpy(variable_info[7].type,"Float");
    strcpy(variable_info[8].type,"Float");
    strcpy(variable_info[9].type,"Float");
    strcpy(variable_info[10].type,"Float");
    strcpy(variable_info[11].type,"Float");
    strcpy(variable_info[12].type,"Float");
    strcpy(variable_info[13].type,"Float");
    strcpy(variable_info[14].type,"Float");
    strcpy(variable_info[15].type,"Float");
    strcpy(variable_info[16].type,"\0");
    strcpy(variable_info[17].type,"Float");
    strcpy(variable_info[18].type,"Float");
    strcpy(variable_info[19].type,"Float");
    strcpy(variable_info[20].type,"Float");
    strcpy(variable_info[21].type,"Float");
    strcpy(variable_info[22].type,"Float");
    strcpy(variable_info[23].type,"Float");
    strcpy(variable_info[24].type,"Float");
    strcpy(variable_info[25].type,"Float");
    strcpy(variable_info[26].type,"Float");
    strcpy(variable_info[27].type,"Float");
    strcpy(variable_info[28].type,"Float");
    strcpy(variable_info[29].type,"Float");

    /* Init Global Vars  */

    strcpy(sepchars," ,\r\n\0");        // Separation characters used in commands, may differentiate parameters and/or signal end of command

    memset(words[0],0,225); /* clear words for message processing */

    tester_state = STOP;    // B_Box tester using state machine

    can1_request_index = 10000; // some large case value, if not set before call will cause switch to exit
    can2_request_index = 10000; // some large case value, if not set before call will cause switch to exit

    bus1_warn_state = 0;
    bus2_warn_state = 0;
    bus1_off_state = 0;
    bus2_off_state = 0;

    can1_stat_temp = 0;
    can2_stat_temp = 0;

    mp = 0;                 /* initialize message pointer */
    data_frame = 0;         /* set to default */
    flag_to_process = 0;    /* initialize command processing flag to no */
    tx_to_rx_delay_flag = 0;    /* init flag for delay when transmitting RS458, so last byte is not cut off during transmission by transmitter */

    ad_ground_offset_in_tick = 0;       // when using B_Board and 96way 5volt power, offset will compensate for readbacks loss because of board interconnect
                                        //      determined in AtoD reference init

    fault1_cnt = 0;
    fault2_cnt = 0;
    fault3_cnt = 0;

    CIB_reset_flag = 1; // set to 1 after reset, set and leave at zero after first dumperr
    dump_cnt = 9; // initiate at 9, inc after each request. Acts as sequence indicator in RTS dump_err file to determine if a dump_err was not logged.

    ign1_status = OFF;
    ign2_status = OFF;

//  ign_on_flag = FALSE;
//  Engine_on_Signal = 1;    // RUN mode
//  speed_flag = 0;     /* set speed 0Kph for 0 amps out */

    SW1_high_or_low = HIGH;                 // Initialized to "high" and set to "low" in GIO notification during ISR
    SW1_is_snapping_snapped1_snapped2_reset_none = NONE;    // init "none", if-when user pushes"snapping", based on sw1 time low: var -> ("snapped1 then "snapped2")or"reset"
    SW1_active_low_time = 0;        // time stamp of when falling edge of SW1 occurred
    SW1_time_held_low = 0;          // time in mS, SW1 was held low by user


    can1_sys_state_warm_init = -1; // init to -1 ...no reading (special check for Crank Testing)
    can2_sys_state_warm_init = -1; // init to -1 ...no reading (special check for Crank Testing)

    ucurr_flag = 0;                 // flag to main to process user initiated TOC commands
    ucurr_direction_POS_NEG = 0;    // ucurr direction swapper

    hcurr_direction_POS_NEG = 0;    // hcurr direction swapper
    hcurr_flag = OFF;               // flag to epa4 and main to determine if and when to process load profile

    high_torque_timer_flag = 0; // set to zero or off only set in high torque commands
    high_torque_timer_counter = 0; // counter defaults to zero

    stop_T1T2switching = 1;  // stop switching for low current


    //  New B_CIB code 22MAR18
/******  FORD is unique,  hcurr values are only set on demand by a torque command, some may or may not be available at time of dumperr
*         so a flag is set at time of request so parse() will not write invalid values over valid values.
*/
    FORD_hcurr_low_value_is_set  = FALSE;       // set to FALSE, when aquired in main() set to true, set back to FALSE after dumperr.
    FORD_hcurr_med_value_is_set  = FALSE;
    FORD_hcurr_high_value_is_set = FALSE;

    can1_FORD_T3_ECU1_MtrCurrQax1_fp = -100;       // init Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
    can1_FORD_T3_ECU1_MtrCurrQax2_fp = -100;
    can1_FORD_T3_ECU1_MtrCurrQax3_fp = -100;

    can1_FORD_T3_ECU1_HwTrq_HwNm1_fp = -100;
    can1_FORD_T3_ECU1_HwTrq_HwNm2_fp = -100;
    can1_FORD_T3_ECU1_HwTrq_HwNm3_fp = -100;

    can1_FORD_T3_ECU2_MtrCurrQax1_fp = -100;
    can1_FORD_T3_ECU2_MtrCurrQax2_fp = -100;
    can1_FORD_T3_ECU2_MtrCurrQax3_fp = -100;

    can1_FORD_T3_ECU2_HwTrq_HwNm1_fp = -100;
    can1_FORD_T3_ECU2_HwTrq_HwNm2_fp = -100;
    can1_FORD_T3_ECU2_HwTrq_HwNm3_fp = -100;

    can1_FORD_MtrCurrQax1_fp = -100;    // init Qax reads to -100 ..also set back after a dumperr
    can1_FORD_MtrCurrQax2_fp = -100;
    can1_FORD_MtrCurrQax3_fp = -100;

    can1_FORD_HwTrq_HwNm1_fp = -100;
    can1_FORD_HwTrq_HwNm2_fp = -100;
    can1_FORD_HwTrq_HwNm3_fp = -100;

    can2_FORD_MtrCurrQax1_fp = -100;
    can2_FORD_MtrCurrQax2_fp = -100;
    can2_FORD_MtrCurrQax3_fp = -100;

    can2_FORD_HwTrq_HwNm1_fp = -100;
    can2_FORD_HwTrq_HwNm2_fp = -100;
    can2_FORD_HwTrq_HwNm3_fp = -100;

    can1_FCA_MtrCurrQax1_fp = -100;     // init Qax reads to -100 ..also set back after a dumperr
    can1_FCA_MtrCurrQax2_fp = -100;
    can1_FCA_MtrCurrQax3_fp = -100;

    can1_FCA_HwTrq_HwNm1_fp = -100;
    can1_FCA_HwTrq_HwNm2_fp = -100;
    can1_FCA_HwTrq_HwNm3_fp = -100;

    can2_FCA_MtrCurrQax1_fp = -100;
    can2_FCA_MtrCurrQax2_fp = -100;
    can2_FCA_MtrCurrQax3_fp = -100;

    can2_FCA_HwTrq_HwNm1_fp = -100;
    can2_FCA_HwTrq_HwNm2_fp = -100;
    can2_FCA_HwTrq_HwNm3_fp = -100;

    can_C1XX_MtrCurrQax1_fp = -100;  // init Hcurr Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
    can_C1XX_MtrCurrQax2_fp = -100;
    can_C1XX_MtrCurrQax3_fp = -100;

    can_C1XX_HwTrq_HwNm1_fp = -100;
    can_C1XX_HwTrq_HwNm2_fp = -100;
    can_C1XX_HwTrq_HwNm3_fp = -100;

    can_T1XX_MotCurrQax1_fp = -100;  // init Hcurr Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
    can_T1XX_MotCurrQax2_fp = -100;
    can_T1XX_MotCurrQax3_fp = -100;

    can_T1XX_HwTqArbn_HwTq1_fp = -100;
    can_T1XX_HwTqArbn_HwTq2_fp = -100;
    can_T1XX_HwTqArbn_HwTq3_fp = -100;

    can_GWM_A0607_MotCurrQax1_fp = -100;  // init Hcurr Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
    can_GWM_A0607_MotCurrQax2_fp = -100;
    can_GWM_A0607_MotCurrQax3_fp = -100;

    can_GWM_A0607_HwTqArbn_HwTq1_fp = -100;
    can_GWM_A0607_HwTqArbn_HwTq2_fp = -100;
    can_GWM_A0607_HwTqArbn_HwTq3_fp = -100;

    can1_G2KCA_MtrCurrQax1_fp = -100;       // init Qax reads to -100 ..also set back after a dumperr
    can1_G2KCA_MtrCurrQax2_fp = -100;
    can1_G2KCA_MtrCurrQax3_fp = -100;

    can1_G2KCA_HwTrq_HwNm1_fp = -100;
    can1_G2KCA_HwTrq_HwNm2_fp = -100;
    can1_G2KCA_HwTrq_HwNm3_fp = -100;

    can2_G2KCA_MtrCurrQax1_fp = -100;
    can2_G2KCA_MtrCurrQax2_fp = -100;
    can2_G2KCA_MtrCurrQax3_fp = -100;

    can2_G2KCA_HwTrq_HwNm1_fp = -100;
    can2_G2KCA_HwTrq_HwNm2_fp = -100;
    can2_G2KCA_HwTrq_HwNm3_fp = -100;

    // Note - PSA does not have a Hcurr sequence

    can1_CN200_MtrCurrQax1_fp = -100;       // init Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
    can1_CN200_MtrCurrQax2_fp = -100;
    can1_CN200_MtrCurrQax3_fp = -100;

    can1_CN200_HwTrq_HwNm1_fp = -100;
    can1_CN200_HwTrq_HwNm2_fp = -100;
    can1_CN200_HwTrq_HwNm3_fp = -100;

    can1_RENAULT_NISSAN_MtrCurrQax1_fp = -100;       // init Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
    can1_RENAULT_NISSAN_MtrCurrQax2_fp = -100;
    can1_RENAULT_NISSAN_MtrCurrQax3_fp = -100;

    can1_RENAULT_NISSAN_HwTrq_HwNm1_fp = -100;
    can1_RENAULT_NISSAN_HwTrq_HwNm2_fp = -100;
    can1_RENAULT_NISSAN_HwTrq_HwNm3_fp = -100;

    // Note BMW does not have a Hcurr sequence


        /* ----------------------------------   T 1 X X   S E N T   D A T A    ---------------------------  */

        //  (Initialize to Position sensors to ChA = 180 deg (7FF) and ChB = 0 deg (000), 12bit digital sensor )
        //  (Initialize to Torque sensor NUL  or  T1 and T2 are FFF/2 = 7FF  , 12bit digital sensor )
      //                USE LABVIEW APPs to calculate CRC ( one for 3 nibble and the other for 4 nibble CRC calcs)
            //      Position format = data0,data1,data2,addr,CRC
            //      Torque format   = data0,data1,data2,CRC

  // Since now doing all HET Ram updates only on user demand, no need to set update flags here --       sent_update_flag = ACTIVE;

        sent_ChA_toggle_HW_address_counter = 0; // init handwheel address toggle to address#0
        sent_ChB_toggle_HW_address_counter = 0; // init handwheel address toggle to address#0

  //    //  Init preamble edges for all Sent signals - Sync, Status and Start(falling edge) of Data0
  //
  //    // old -- thought all were same ,,Loop will load all 8 SENT signal edge times,, load as Torque sensors and then edit 4 signals to look like Handwheel sensors, easier.
  //    for(loop_cnt_c=0;loop_cnt_c < 8;loop_cnt_c++)       // stuff initial SENT edge times for 8 channels - Position ChA (addr 0,1) ChB (addr 0,1) Torque ChA T1,T2 ChB T1, T2
  //    {
  //        sent_edge_event_time[loop_cnt_c][0]  = 20;  // 0 Falling - Start of SENT_Fixed with 20 tick delay for clearing of trigger pulse+dead time
  //        sent_edge_event_time[loop_cnt_c][1]  = 24;  // 4 Rising  - Start of SENT_Sync
  //        sent_edge_event_time[loop_cnt_c][2]  = 76;  // 56 Falling - Start of SENT_Fixed
  //        sent_edge_event_time[loop_cnt_c][3]  = 80;  // 4 Rising  - Start of Status
  //        sent_edge_event_time[loop_cnt_c][4]  = 88;  // 8 Status now "0000" Falling - Start of SENT_Fixed
  //        sent_edge_event_time[loop_cnt_c][5]  = 92;  // 4 Rising  - Start of Data0
  //        sent_edge_event_time[loop_cnt_c][6]  = 107; // 15 Falling - Start of SENT_Fixed, Delay for Data0    (0x7) 8+7
  //        sent_edge_event_time[loop_cnt_c][7]  = 111; // 4 Rising  - Start of Data1
  //        sent_edge_event_time[loop_cnt_c][8]  = 134; // 23 Falling - Start of SENT_Fixed, Delay for Data1    (0xF) 8+15
  //        sent_edge_event_time[loop_cnt_c][9]  = 138; // 4 Rising  - Start of Data2
  //        sent_edge_event_time[loop_cnt_c][10] = 161; // 23 Falling - Start of SENT_Fixed, Delay for Data2    (0xF) 8+15
  //        sent_edge_event_time[loop_cnt_c][11] = 165; // 4 Rising  - Start of CRC
  //        sent_edge_event_time[loop_cnt_c][12] = 180; // 15 Falling - Start of SENT_Fixed, Delay for CRC  (7,F,F CRC= 7) 8+7
  //        sent_edge_event_time[loop_cnt_c][13] = 184; // 4 Rising  - End of SENT_FIxed
  //        sent_edge_event_time[loop_cnt_c][14] = 209; // at 209 No Action - Dummy used to ensure no pin activity in loop prior to rearming
  //    }

        // Loop will load all 4 SENT signal Torque edge times,,
  //    for(loop_cnt_c=4;loop_cnt_c < 8;loop_cnt_c++)       // stuff initial SENT edge times for channels 4 thru 8 -  Torque ChA T1,T2 ChB T1, T2
  //    {
  //        sent_edge_event_time[loop_cnt_c][0]  = 138; // 0 Falling - Start of SENT_Fixed with 138 tick delay(165uS) for clearing of trigger pulse+dead time
  //        sent_edge_event_time[loop_cnt_c][1]  = 142; // 4 Rising  - Start of SENT_Sync
  //        sent_edge_event_time[loop_cnt_c][2]  = 194; // 56 Falling - Start of SENT_Fixed
  //        sent_edge_event_time[loop_cnt_c][3]  = 198; // 4 Rising  - Start of Status
  //        sent_edge_event_time[loop_cnt_c][4]  = 206; // 8 Status now "0000" Falling - Start of SENT_Fixed
  //        sent_edge_event_time[loop_cnt_c][5]  = 210; // 4 Rising  - Start of Data0
  //        sent_edge_event_time[loop_cnt_c][6]  = 225; // 15 Falling - Start of SENT_Fixed, Delay for Data0    (0x7) 8+7
  //        sent_edge_event_time[loop_cnt_c][7]  = 229; // 4 Rising  - Start of Data1
  //        sent_edge_event_time[loop_cnt_c][8]  = 252; // 23 Falling - Start of SENT_Fixed, Delay for Data1    (0xF) 8+15
  //        sent_edge_event_time[loop_cnt_c][9]  = 256; // 4 Rising  - Start of Data2
  //        sent_edge_event_time[loop_cnt_c][10] = 279; // 23 Falling - Start of SENT_Fixed, Delay for Data2    (0xF) 8+15
  //        sent_edge_event_time[loop_cnt_c][11] = 283; // 4 Rising  - Start of CRC
  //        sent_edge_event_time[loop_cnt_c][12] = 298; // 15 Falling - Start of SENT_Fixed, Delay for CRC  (7,F,F CRC= 7) 8+7
  //        sent_edge_event_time[loop_cnt_c][13] = 302; // 4 Rising  - End of SENT_FIxed
  //        sent_edge_event_time[loop_cnt_c][14] = 314; // at 314 ,,(old)359 No Action - Dummy used to ensure no pin activity in loop prior to rearming
  //    }
        for(loop_cnt_c=4;loop_cnt_c < 8;loop_cnt_c++)       // stuff initial SENT edge times for channels 4 thru 8 -  Torque ChA T1,T2 ChB T1, T2
        {
            sent_edge_event_time[loop_cnt_c][0]  = 40;  // 0 Falling - Start of SENT_Fixed with 138 tick delay(165uS) for clearing of trigger pulse+dead time
            sent_edge_event_time[loop_cnt_c][1]  = 44;  // 4 Rising  - Start of SENT_Sync
            sent_edge_event_time[loop_cnt_c][2]  = 96;  // 52 Falling - Start of SENT_Fixed
            sent_edge_event_time[loop_cnt_c][3]  = 100; // 4 Rising  - Start of Status
            sent_edge_event_time[loop_cnt_c][4]  = 108; // 8 Status now "0000" Falling - Start of SENT_Fixed
            sent_edge_event_time[loop_cnt_c][5]  = 112; // 4 Rising  - Start of Data0

            sent_edge_event_time[loop_cnt_c][6]  = 127; // 15 Falling - Start of SENT_Fixed, Delay for Data0    (0x7) 8+7
            sent_edge_event_time[loop_cnt_c][7]  = 131; // 4 Rising  - Start of Data1
            sent_edge_event_time[loop_cnt_c][8]  = 154; // 23 Falling - Start of SENT_Fixed, Delay for Data1    (0xF) 8+15
            sent_edge_event_time[loop_cnt_c][9]  = 158; // 4 Rising  - Start of Data2
            sent_edge_event_time[loop_cnt_c][10] = 181; // 23 Falling - Start of SENT_Fixed, Delay for Data2    (0xF) 8+15
            sent_edge_event_time[loop_cnt_c][11] = 185; // 4 Rising  - Start of CRC
            sent_edge_event_time[loop_cnt_c][12] = 200; // 15 Falling - Start of SENT_Fixed, Delay for CRC  (7,F,F CRC= 7) 8+7
            sent_edge_event_time[loop_cnt_c][13] = 204; // 4 Rising  - End of SENT_FIxed
            sent_edge_event_time[loop_cnt_c][14] = 399; // (old)at 399  ,,(old)359 No Action - Dummy used to ensure no pin activity in loop prior to rearming
        }


        // We were able to avoid offsetting the SENT signal. adding i2C pullups, minimized effect of ringing.  Did hold off SENT Response to triggers
        //   until i2C Sensor initialization  sequence is complete before having HET code respond to product triggers. Runs fine now.
//      if(target_product == TARGET_C1XX)
 //     {   // C1XX load SENT 4 at an offset of 10 ticks to minimize FET off switch ringing on ISO GND causing i2C clock issues
 //         sent_edge_event_time[5][0]  = 50;   // 0 Falling - Start of SENT_Fixed with 138 tick delay(165uS) for clearing of trigger pulse+dead time
 //         sent_edge_event_time[5][1]  = 54;   // 4 Rising  - Start of SENT_Sync
  //        sent_edge_event_time[5][2]  = 106;  // 52 Falling - Start of SENT_Fixed
    //      sent_edge_event_time[5][3]  = 110;  // 4 Rising  - Start of Status
    //      sent_edge_event_time[5][4]  = 118;  // 8 Status now "0000" Falling - Start of SENT_Fixed
    //      sent_edge_event_time[5][5]  = 122;  // 4 Rising  - Start of Data0
//
    //      sent_edge_event_time[5][6]  = 137;  // 15 Falling - Start of SENT_Fixed, Delay for Data0    (0x7) 8+7
    //      sent_edge_event_time[5][7]  = 141;  // 4 Rising  - Start of Data1
    //      sent_edge_event_time[5][8]  = 164;  // 23 Falling - Start of SENT_Fixed, Delay for Data1    (0xF) 8+15
    //      sent_edge_event_time[5][9]  = 168;  // 4 Rising  - Start of Data2
    //      sent_edge_event_time[5][10] = 191;  // 23 Falling - Start of SENT_Fixed, Delay for Data2    (0xF) 8+15
    //      sent_edge_event_time[5][11] = 195;  // 4 Rising  - Start of CRC
    //      sent_edge_event_time[5][12] = 210;  // 15 Falling - Start of SENT_Fixed, Delay for CRC  (7,F,F CRC= 7) 8+7
   //       sent_edge_event_time[5][13] = 214; // 4 Rising  - End of SENT_FIxed
   //       sent_edge_event_time[5][14] = 399; // at 399  ,,(old)359 No Action - Dummy used to ensure no pin activity in loop prior to rearming
  //    }

      // stuff initial SENT additional edge times for Handwheel - Position ChA (addr 0),, Init ChA to 180 deg which is (180/360) * 4095 = 2047 or 7FF
      {
            sent_edge_event_time[0][0]  = 20;   // 0 Falling - Start of SENT_Fixed with 20 tick delay for clearing of trigger pulse+dead time
            sent_edge_event_time[0][1]  = 24;   // 4 Rising  - Start of SENT_Sync
            sent_edge_event_time[0][2]  = 76;   // 52 Falling - Start of SENT_Fixed
            sent_edge_event_time[0][3]  = 80;   // 4 Rising  - Start of Status
            sent_edge_event_time[0][4]  = 88;   // 8 Status now "0000" Falling - Start of SENT_Fixed
            sent_edge_event_time[0][5]  = 92;   // 4 Rising  - Start of Data0

        sent_edge_event_time[0][6]  = 107;  // 15 Falling - Start of SENT_Fixed, Delay for Data0    (0x7) 8+7
        sent_edge_event_time[0][7]  = 111;  // 4 Rising  - Start of Data1
        sent_edge_event_time[0][8]  = 134;  // 23 Falling - Start of SENT_Fixed, Delay for Data1    (0xF) 8+15
        sent_edge_event_time[0][9]  = 138;  // 4 Rising  - Start of Data2
        sent_edge_event_time[0][10] = 161;  // 23 Falling - Start of SENT_Fixed, Delay for Data2    (0xF) 8+15
        sent_edge_event_time[0][11] = 165;  // 4 Rising  - Start of Addr
        sent_edge_event_time[0][12] = 173;  // 8 Falling - Start of SENT_Fixed, Delay for Addr      (0x0) 8+0
        sent_edge_event_time[0][13] = 177;  // 4 Rising  - Start of CRC
        sent_edge_event_time[0][14] = 189;  // 12 Falling - Start of SENT_Fixed, Delay for CRC   (7,F,F,0 CRC= 4) 8+4
        sent_edge_event_time[0][15] = 193;  // 4 Rising  - End of SENT_FIxed
        sent_edge_event_time[0][16] = 249;  // x at 249 No Action - Dummy used to ensure no pin activity in loop prior to rearming

      }

      // stuff initial SENT additional edge times for Handwheel - Position ChB (addr 0),, Init ChB to 180 deg which is (180/360) * 4095 = 2047 or 7FF
      {
            sent_edge_event_time[1][0]  = 20;   // 0 Falling - Start of SENT_Fixed with 20 tick delay for clearing of trigger pulse+dead time
            sent_edge_event_time[1][1]  = 24;   // 4 Rising  - Start of SENT_Sync
            sent_edge_event_time[1][2]  = 76;   // 52 Falling - Start of SENT_Fixed
            sent_edge_event_time[1][3]  = 80;   // 4 Rising  - Start of Status
            sent_edge_event_time[1][4]  = 88;   // 8 Status now "0000" Falling - Start of SENT_Fixed
            sent_edge_event_time[1][5]  = 92;   // 4 Rising  - Start of Data0

        sent_edge_event_time[1][6]  = 107;  // 15 Falling - Start of SENT_Fixed, Delay for Data0    (0x7) 8+7
        sent_edge_event_time[1][7]  = 111;  // 4 Rising  - Start of Data1
        sent_edge_event_time[1][8]  = 134;  // 23 Falling - Start of SENT_Fixed, Delay for Data1    (0xF) 8+15
        sent_edge_event_time[1][9]  = 138;  // 4 Rising  - Start of Data2
        sent_edge_event_time[1][10] = 161;  // 23 Falling - Start of SENT_Fixed, Delay for Data2    (0xF) 8+15
        sent_edge_event_time[1][11] = 165;  // 4 Rising  - Start of Addr
        sent_edge_event_time[1][12] = 173;  // 8 Falling - Start of SENT_Fixed, Delay for Addr      (0x0) 8+0
        sent_edge_event_time[1][13] = 177;  // 4 Rising  - Start of CRC
        sent_edge_event_time[1][14] = 189;  // 12 Falling - Start of SENT_Fixed, Delay for CRC   (7,F,F,0 CRC= 4) 8+4
        sent_edge_event_time[1][15] = 193;  // 4 Rising  - End of SENT_FIxed
        sent_edge_event_time[1][16] = 249;  // x at 249 No Action - Dummy used to ensure no pin activity in loop prior to rearming

      }


      // stuff initial SENT additional edge times for Handwheel - Position ChA (addr 1),, Init ChA to 0 deg which is (0/360) * 4095 = 0 or 000
      {
            sent_edge_event_time[2][0]  = 20;   // 0 Falling - Start of SENT_Fixed with 20 tick delay for clearing of trigger pulse+dead time
            sent_edge_event_time[2][1]  = 24;   // 4 Rising  - Start of SENT_Sync
            sent_edge_event_time[2][2]  = 76;   // 52 Falling - Start of SENT_Fixed
            sent_edge_event_time[2][3]  = 80;   // 4 Rising  - Start of Status
            sent_edge_event_time[2][4]  = 88;   // 8 Status now "0000" Falling - Start of SENT_Fixed
            sent_edge_event_time[2][5]  = 92;   // 4 Rising  - Start of Data0

        sent_edge_event_time[2][6]  = 100;  // 8 Falling - Start of SENT_Fixed, Delay for Data0     (0x0) 8+0
        sent_edge_event_time[2][7]  = 104;  // 4 Rising  - Start of Data1
        sent_edge_event_time[2][8]  = 112;  // 8 Falling - Start of SENT_Fixed, Delay for Data1     (0x0) 8+0
        sent_edge_event_time[2][9]  = 116;  // 4 Rising  - Start of Data2
        sent_edge_event_time[2][10] = 124;  // 8 Falling - Start of SENT_Fixed, Delay for Data2     (0x0) 8+0
        sent_edge_event_time[2][11] = 128;  // 4 Rising  - Start of Addr
        sent_edge_event_time[2][12] = 137;  // 9 Falling - Start of SENT_Fixed, Delay for Addr      (0x0) 8+1
        sent_edge_event_time[2][13] = 141;  // 4 Rising  - Start of CRC
        sent_edge_event_time[2][14] = 150;  // 9 Falling - Start of SENT_Fixed, Delay for CRC   (0,0,0,1 CRC= 1) 8+1
        sent_edge_event_time[2][15] = 154;  // 4 Rising  - End of SENT_FIxed
        sent_edge_event_time[2][16] = 249;  // x at 249 No Action - Dummy used to ensure no pin activity in loop prior to rearming

      }


      // stuff initial SENT additional edge times for Handwheel - Position ChB (addr 1),, Init ChB to 0 deg which is (0/360) * 4095 = 0 or 000
      {
            sent_edge_event_time[3][0]  = 20;   // 0 Falling - Start of SENT_Fixed with 20 tick delay for clearing of trigger pulse+dead time
            sent_edge_event_time[3][1]  = 24;   // 4 Rising  - Start of SENT_Sync
            sent_edge_event_time[3][2]  = 76;   // 52 Falling - Start of SENT_Fixed
            sent_edge_event_time[3][3]  = 80;   // 4 Rising  - Start of Status
            sent_edge_event_time[3][4]  = 88;   // 8 Status now "0000" Falling - Start of SENT_Fixed
            sent_edge_event_time[3][5]  = 92;   // 4 Rising  - Start of Data0

        sent_edge_event_time[3][6]  = 100;  // 8 Falling - Start of SENT_Fixed, Delay for Data0     (0x0) 8+0
        sent_edge_event_time[3][7]  = 104;  // 4 Rising  - Start of Data1
        sent_edge_event_time[3][8]  = 112;  // 8 Falling - Start of SENT_Fixed, Delay for Data1     (0x0) 8+0
        sent_edge_event_time[3][9]  = 116;  // 4 Rising  - Start of Data2
        sent_edge_event_time[3][10] = 124;  // 8 Falling - Start of SENT_Fixed, Delay for Data2     (0x0) 8+0
        sent_edge_event_time[3][11] = 128;  // 4 Rising  - Start of Addr
        sent_edge_event_time[3][12] = 137;  // 9 Falling - Start of SENT_Fixed, Delay for Addr      (0x0) 8+1
        sent_edge_event_time[3][13] = 141;  // 4 Rising  - Start of CRC
        sent_edge_event_time[3][14] = 150;  // 9 Falling - Start of SENT_Fixed, Delay for CRC   (0,0,0,1 CRC= 1) 8+1
        sent_edge_event_time[3][15] = 154;  // 4 Rising  - End of SENT_FIxed
        sent_edge_event_time[3][16] = 249;  // x at 249 No Action - Dummy used to ensure no pin activity in loop prior to rearming

     }




//old original code sprintf(return_message,"INTEL SYS(EPS16_33.C 6/20/05 L. Cronk)\r\n id= %s",CIB_config_data.BOARD_ID);

    /* ------------  enable interrupts --------------------------- */

    rtiInit();      // HAL function will Initialize RTI driver

    mibspiInit();       //HAL function will Initialize MIBSPI driver  used for analog output

    sciInit();      //Initializes the SCI (UART) module

    /** - Bug in HalCoGen must reinitialize global transfer.mode variable */
 //   g_sciTransfer_t[1U].mode   = 0U << 8U;    // not declared,, error, for now fix remains in sci.c , sciInit()

    gioInit();      //Initializes GIO module

    adcInit();

//    adcCalibration(adcREG1);
    adcMidPointCalibration(adcREG1);


    canInit();      // Initialize CAN1 and CAN2 nodes

    adcEnableNotification(adcREG1, adcGROUP1);
    adcEnableNotification(adcREG2, adcGROUP1);      // ADC2 is designed for a "oneshot" to aquire the "HEX ID switches" and "Board_Id codes"

    adcStartConversion(adcREG2, adcGROUP1); // Start A/D single scan for group1 adc2[0 thur 7 and 15] 9 channels


    rtiEnableNotification(rtiNOTIFICATION_COMPARE0);        // HAL function will Clr pending and unmask RTI compare 0 interrupt

    hetInit();      // Set up Het Ports, (If required), Load HET ram with code and start HET program.

    _enable_IRQ();      //enable IRQ - Clear I flag in CPU reg

    rtiStartCounter(rtiCOUNTER_BLOCK1);     // HAL function, Start Counter Block 1, set up to up count 1mS to 1000 (1 Sec)

    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][], done here because we need system_msec_clock running

    //Special initialization for FlexRay products
    switch(target_product)
    {
    case TARGET_BMW_UKL:
    case TARGET_BMW_FAAR_WE:
        frayInit();
        frayStartCommunication();
        initFrayMsg();
//      init_DAQ_mode_fray();
    break;
    }


    // wait for analog system to acquire
    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1 Sec
    while(system_msec_clock < system_msec_clock_temp);


    //old   gioSetBit(gioPORTA, 7, 0);  // layout issue REVB boards , must take GIOA[7] to ground for identification scheme to work.  25FEB15

    /* ----------  D E T E R M I N E   B O A R D  I D    (board_id_bin)  ----------------   */
    /*  HEX SW-1    AD2IN[4]
        HEX SW-2    AD2IN[5]
        HEX SW-3    AD2IN[6]
        HEX SW-4    AD2IN[7]
    */
    board_id_bin = 0;
    if(adc2_Group1_raw[4].value > 2048) board_id_bin += 1;
    if(adc2_Group1_raw[5].value > 2048)  board_id_bin += 2;
    if(adc2_Group1_raw[6].value > 2048)  board_id_bin += 4;
    if(adc2_Group1_raw[7].value > 2048)  board_id_bin += 8;

    /* ----------  D E T E R M I N E   B O A R D  C O M P O N E N E T S   (board_configuration_bin)  ----------------   */
    /*  DIGITALID1          if AD2IN[15] , NHET[18] is LOW
        TCPIPID2            if AD2IN[0]  , NHET[20] is LOW
        SENSEID3 SENSEID4   if AD2IN[1] NHET[21] is LOW and AD2IN[2] NHET[22] is HIGH = Analog Sensor Board
        FRAYID5             if AD2IN[3]  , NHET[23] is LOW
    */
    board_configuration_bin = 0;
    if(adc2_Group1_raw[8].value > 2048)  board_configuration_bin += 1;  // adc[15] is assigned [8] in group list
    if(adc2_Group1_raw[0].value > 2048)  board_configuration_bin += 2;
    if(adc2_Group1_raw[1].value > 2048)  board_configuration_bin += 4;
    if(adc2_Group1_raw[2].value > 2048)  board_configuration_bin += 8;
    if(adc2_Group1_raw[3].value > 2048)  board_configuration_bin += 16;

//  board_configuration_bin = gioGetPort(hetPORT1) & 0x00F40000;    // Hex code for which saughter boards are installed, located at NHET[18,20,21,22,23]

    sprintf(CIB_config_data.BOARD_ID,"%X",board_id_bin);    /*  id, store in string as hex string */
//old,stored new loc and 0x0a looks like 10dec, bad.    sprintf(board_id,"%d",board_id_bin >> 12);  /* shift right 12 to get id, store in string as hex string */


    strcpy(CIB_config_data.SOFTWARE_VERSION , "GWM A0607 rev01 02.00.05 27Jul2021");    // program version name
//old   char version [] = {"Ford S550-UP375 rev9 06_00_08  09/09/14"};  // program version name


    sprintf(sbuf_tx_main,"I am at Board ID = %s\r\n",CIB_config_data.BOARD_ID);
                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1, debug

/* ----------  D E T E R M I N E   C O N F I G U R A T I O N     ----------------   */
    // test zero result,  zero at bit means board is present, note SENSOR board has 2 bits, so 4 posible configurations, not present=4 or 1,2 or 3 type
//  if(board_configuration_bin   & 0x00040000){strcpy( CIB_config_data.DIGITAL, "NO");} else {strcpy( CIB_config_data.DIGITAL, "YES");}
//  if(board_configuration_bin   & 0x00100000){strcpy( CIB_config_data.TCPIP, "NO");} else {strcpy( CIB_config_data.TCPIP, "YES MONITOR_data_blank");}
//  if(((board_configuration_bin & 0x00600000) == 0x00600000)){strcpy( CIB_config_data.SENSOR, "NO");} else {strcpy( CIB_config_data.SENSOR, "YES");}
//  if(board_configuration_bin   & 0x00800000){strcpy( CIB_config_data.FLEX, "NO");} else { strcpy( CIB_config_data.FLEX, "YES");}

    if(board_configuration_bin   & 0x1){strcpy( CIB_config_data.DIGITAL, "NO");} else {strcpy( CIB_config_data.DIGITAL, "YES");}
    if(board_configuration_bin   & 0x2){strcpy( CIB_config_data.TCPIP, "NO");} else {strcpy( CIB_config_data.TCPIP, "YES MONITOR_data_blank");}
    if(((board_configuration_bin & 0xC) == 0xC)){strcpy( CIB_config_data.SENSOR, "NO");} else {strcpy( CIB_config_data.SENSOR, "YES");}
    if(board_configuration_bin   & 0x10){strcpy( CIB_config_data.FLEX, "NO");} else { strcpy( CIB_config_data.FLEX, "YES");}

/* ----------  I N I T I A L I Z E  -  SCI2 communications CIB, { LAN or RS485 }   ----------------   */
    if(strstr(CIB_config_data.TCPIP, "YES") != NULL)    // if YES is not in string, a NULL is returned
//  if(strncmp(CIB_config_data.TCPIP, "YES", 3) == 0)   // returns 0 if first 3 chars in strings are equal
//  if(strcmp(CIB_config_data.TCPIP, "YES") == 0)   // returns 0 if strings are equal(old way, now IP and MAC are appended, so this will not work)

    {
        scilinREG_is_CIB_or_Monitor_or_WEB = MONITOR;       // Monitor uses LAN, but first we will query Lantronix for MAC and IP address
        monitor_rec_index = 0;                          // Set index to handle first set of Receives from Lantronix in Notification
                                                        // Then we set to WEB personality mode.
    }
    else
    {
        scilinREG_is_CIB_or_Monitor_or_WEB = CIB;       // CIB means we will talk RS485
    }

    sprintf(sbuf_tx_main,"I N I T I A L I Z E D -  SCI2 is CIB or Monitor or WEBcommunications = %d --  Baud Register = %d \r\n",scilinREG_is_CIB_or_Monitor_or_WEB,scilinREG->BRS);
        sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

    switch(scilinREG_is_CIB_or_Monitor_or_WEB)
    {
    case CIB:
        /* ----------  I N I T I A L I Z E  -  SCI2 for RS485    ----------------   */
            /* Enable SCI to interrupt on ADDR only */
            scilinREG->GCR1 = scilinREG->GCR1 | 0x01;           // turn on Address-bit mode
            scilinREG->GCR1 = scilinREG->GCR1 | ADDR_MODE;      // turn on ADDR_MODE/SLEEP_MODE so only interrupts off of ADDR bits
            sciEnableNotification(scilinREG,SCI_RX_INT | SCI_TX_INT);   // enable interrupt complete call to sciNotification()

            /* Kick off RS485 read of 1 byte at a time. This is re-triggered after each receive - P. Horny 19Mar14*/
            /*  Dummy read, sets system_var .length to "1".  Function is used several times in Notification to ensure--reset .length to "1"  */
            sciReceive(scilinREG,1,sbuf_rx);

        break;

    case MONITOR:
        /* ----------  S T A R T I N G   L A N    M O D U L E  : I N I T I A L I Z E  -  SCI2 for RS485    ----------------   */
//          scilinREG->BRS = 259U;   /* 19200 baudrate, required if you want to talk to lantronix during first 3 seconds after lantronix reset */
            scilinREG->BRS = 520U;  /* 9600 baudrate, required if you want to talk to lantronix during first 3 seconds after lantronix reset */


            strcpy(sbuf_tx_main,"zzz");     // "zzz" with LAN, "yyy" without LAN
        //    sciSend(sciREG1,strlen(sbuf_tx_main),sbuf_tx_main);       // echo to port1 - CCS terminal
            sciSend(sciREG, 3,sbuf_tx_main);        // echo to port1 - CCS terminal


            adcREG1->EVTCLR = 1;        //CLR AD1EVT pin to LANTRONIX reset pin (low)

            system_msec_clock_temp = system_msec_clock + 500;   // wait .5 sec while held low
            while(system_msec_clock < system_msec_clock_temp);

            adcREG1->EVTSET = 1;        //Set CLR AD1EVT pin to LANTRONIX reset pin (high)

            system_msec_clock_temp = system_msec_clock + 2500;  // wait .5 Sec, wait for Lantronix to release the pin (book says 200mS)
            while(system_msec_clock < system_msec_clock_temp);


            for(loop_cnt_a = 0; loop_cnt_a < 3 ; loop_cnt_a++)
            {
                sciSendByte(scilinREG, 'z');
//              sciSend(scilinREG, 3, sbuf_tx_main);    // within 3 seconds after reset of LANtronix, we can get to its Monitor program
                system_msec_clock_temp = system_msec_clock + 500;
                while(system_msec_clock < system_msec_clock_temp);
                sciSendByte(sciREG,'?');
            }

            /* Kick off RS485 read of 1 byte at a time. This is re-triggered after each receive - P. Horny 19Mar14*/
            /*  Dummy read, sets system_var .length to "1".  Function is used several times in Notification to ensure--reset .length to "1"  */
            sciReceive(scilinREG, 1,sbuf_rx);
//          sciSend(sciREG1, 1, "D");

        break;

    case WEB:
            scilinREG->BRS = 10U;       // 10U; = 460800 baud    // 42U; = 115200 baud  //259U;  =  19200 baudrate
        break;
    }   //end switch(scilinREG_is_CIB_or_Monitor_or_WEB)



/* ----------  I N I T I A L I Z E  -  AtoD Reference    -------------------------   */

    /* TMS570LS20 Bulgian Board using 3.3 A/D Vcc and 2.5vref */
//  ad_2_5_vref_flag = FALSE;   // set when 2.5 volt ref has been established, after > two passes of FIR filter(finite impulse response(FIR) digital filter)
//  if((adc1_Group1_filtered[11] > 1570) && (adc1_Group1_filtered[11] < 1660))      // initial range check, based on micro ADC Vref value and 2.5Vref present
//  {
//      if (adc1_Group1_filtered[11] < 1610)    // test for weather B_Board is powered though 96way connector, JTAG or 5v wall plug, if it is 96way, add 20 ticks to all A/D measurements
//      {
//          ad_ground_offset_in_tick = 20;      // when using B_Board and 96way 5volt power, 20 offset will compensate for readbacks loss because of board interconnect
//          system_msec_clock_temp = system_msec_clock + 100;   // wait for new set of filtered measurements to be calculated with offset
//          while(system_msec_clock < system_msec_clock_temp);
//      }
//      ad_2_5_vref_flag = TRUE;
//      ad_2_5_vref_val = adc1_Group1_filtered[11];     // AtoD counts for filtered 2.5volt ref, established pre main(), used in converting channel values to mV
//  }


    /* TMS570LS31 MicroCore1 Board using 5.0 A/D Vcc and 2.5vref    */
    ad_2_5_vref_flag = FALSE;   // set when 2.5 volt ref has been established, after > two passes of FIR filter(finite impulse response(FIR) digital filter)
    ad_ground_offset_in_tick = 0;

    if((adc1_Group1_filtered[11] > 1000) && (adc1_Group1_filtered[11] < 1050))      // initial range check, based on micro ADC Vref value and 2.5Vref present
    {
        if (adc1_Group1_filtered[11] < 1017)    // test for weather B_Board is powered though 96way connector, JTAG or 5v wall plug, if it is 96way, add 20 ticks to all A/D measurements
        {
            ad_ground_offset_in_tick = 8;       // when using B_Board and 96way 5volt power, 8 offset will compensate for readbacks loss because of board interconnect
            system_msec_clock_temp = system_msec_clock + 100;   // wait for new set of filtered measurements to be calculated with offset
            while(system_msec_clock < system_msec_clock_temp);
        }
        ad_2_5_vref_flag = TRUE;
        ad_2_5_vref_val = adc1_Group1_filtered[11];     // AtoD counts for filtered 2.5volt ref, established pre main(), used in converting channel values to mV
    }


//                 I N I T A L Z E  - msbspi1 for DISPLAY via spt to uart converter   ------------

//    mibspiREG1->TGCTRL[0U] = (uint32)((uint32)1U << 30U)  /* oneshot */
//                           | (uint32)((uint32)0U << 29U)  /* pcurrent reset */
//                           | (uint32)((uint32)TRG_ALWAYS << 20U)  /* trigger event */
//                           | (uint32)((uint32)TRG_DISABLED << 16U)  /* trigger source */
//                           | (uint32)((uint32)0U << 8U);  /* start buffer */
//
//    mibspiREG1->TGCTRL[1U] = (uint32)((uint32)1U << 30U)  /* oneshot */
//                           | (uint32)((uint32)0U << 29U)  /* pcurrent reset */
//                           | (uint32)((uint32)TRG_ALWAYS << 20U)  /* trigger event */
//                           | (uint32)((uint32)TRG_DISABLED << 16U)  /* trigger source */
//                           | (uint32)((uint32)3U << 8U);  /* start buffer */
//
//    mibspiREG1->TGCTRL[2U] = (uint32)((uint32)1U << 30U)  /* oneshot */
//                           | (uint32)((uint32)0U << 29U)  /* pcurrent reset */
//                           | (uint32)((uint32)TRG_ALWAYS << 20U)  /* trigger event */
//                           | (uint32)((uint32)TRG_DISABLED << 16U)  /* trigger source */
//                           | (uint32)((uint32)(3U+2U) << 8U);  /* start buffer */
//
 //     #define MIBSPI1_LTGPEND_CONFIGVALUE  ((uint32)((uint32)((3U+2U+2U+2U+0U+0U+0U+0U)-1U) << 8U))
//    mibspiREG1->TGCTRL[8U] = (uint32)(3U+2U+2U+2U+0U+0U+0U+0U) << 8U;
//
//    mibspiREG1->LTGPEND = (mibspiREG1->LTGPEND & 0xFFFF00FFU) | (uint32)((uint32)((3U+2U+2U+2U+0U+0U+0U+0U)-1U) << 8U);



///* ----------  I N I T I A L I Z E  -  msbspi1 for Analog I/O Sensor Board    ----------------   */
//
//// MibSPI has 255 word Tx buffer, we set up (in spi.c), we have setup one group (of 3 bytes each) called transfer groups, load with data and push transmission
//    // of a transfer group, with the chip select being enabled and disabled at the beginning and end of each groups transmission (see spi.c).
//    // This is done because of the LTC2600CGN 16bit DAC addressing requirements.
//
//// Manually load data first row (D/A ch0), from DtoA_array[] into transfer group 0, with three 8bit chunks of command/address/data for DAC.
//// This is done every time we want to update the DAC with new analog output values
//// So, update group data, then initiate transmission of group0 which will automatically write all 8 D/A channels.
//
//   // For a total of 8 channels
//
//    /** @fn void spiSetData(spiBASE_t *spi, uint32 group, uint16 * data)
//    *   @brief Set Buffer Data
//    *   @param[in] spi   - Spi module base address
//    *   @param[in] group - Transfer group (0..7)
//    *   @param[in] data  - new data for transfer group
//    *
//    *   This spiSetData() function updates the data for the specified transfer group,
//    *   the length of the data must match the length of the transfer group.
//    *   Hence, During Normal Program Execution -----
//    *
//    *     1) update data, in proper location of DtoA_array array, as desired
//    *     2) move DtoA_array[0,0] data to spi transfer groups, TGs, using spiSetData() function
//    *         3) kick off transmission using spiTransfer() function, Notification.c ISR will complete transfer.
//    */
//
//  // step 1, moving desired data into DtoA_array
//
    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
//
//  //    spiSetData(spiBASE_t *spi, uint32 group, uint16 * data);
//  // Step 2, let function copy data to spi's buffer based on Group "0", format,,, 3bytes starting at the address of DtoA_array
    mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
//
//    //    *   This function enables interrupt for a particular transfer group which has finished transmitting.
//    //    */
//    //    void spiEnableGroupNotification(spiBASE_t *spi, uint32 group, uint32 level)
    mibspiEnableGroupNotification(mibspiREG1, 0, 0);
//
//    //    void spiTransfer(spiBASE_t *spi, uint32 group)
    mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).
//    sent_data_calculation_from_analog();  // translate T1/T2 analog data to SENT format
//

//
    /*  -----------------   E N A B L E   H E T   Interupts watching for SENT triggers    -----------------    */
//old    het_test1 = hetREG1->OFF1;         // clear any HET pending interupts by reading Offset Index priority register
//old    hetREG1->FLG = 0XFFFFFFFF;         // ditto

//old    hetREG1->INTENAS = 0x00000001U;        // enable HET_using_cases_11.HET line 0x0 interrupt
//old    hetREG1->INTENAS = 0x00000002U;        // enable HET_using_cases_11.HET line 0x1 interrupt
//old    hetREG1->INTENAS = 0x00002002;     // enable HET_using_cases_11.HET line 0x1 and line 0x2D interrupt


    het_test1 = hetREG1->OFF1;          // clear any HET pending interrupts by reading Offset Index priority register
    hetREG1->FLG = 0XFFFFFFFF;          // ditto
   hetREG1->INTENAS = 0XFFFFFFFF;       // tired of calculating which bit to use, just enable them all
// //////////////////////////////////// hetREG1->INTENAS = 0x00040001;      // enable HET_Pulses_using_running_counter_04.HET line 0x0 and line 0x120 interrupt


    canEnableErrorNotification(canREG1);   // CAN recovery using TMS570 ISR,,, also see:   goto Z_lable; for Manual style as in Dons code
    canEnableErrorNotification(canREG2);   // CAN recovery using TMS570 ISR,,, also see:   goto Z_lable; for Manual style as in Dons code

    while(1)
    {

/*  >>>>>>>>>>>>>>>>>  P H I L 'S   N E W   F L E X  and  N T C 's   and   D A Q   M O D E  streaming    <<<<<<<<<<<<<<<< */

        if(comm_is_CAN_or_FRAY == FRAY)
        {
            flexray_comm_status_vector_CCSV = get_CCSV_state();
            if((flexray_comm_status_vector_CCSV == CCSV_NORMAL_PASSIVE) || (flexray_comm_status_vector_CCSV == CCSV_HALT))//if(fray_error_flag == 1) //flag updated in frayErrorNotif
            {
                //

                if(fray_error_counter<0xFFFFFFFF){fray_error_counter++;}    //bump up fray error counter if <0xFFFFFFFF, prevent restarting/overflow counter
                //frayEnableErrorInterrupt(); //function only impacts bus state error case
                frayRestartCommunication(); //function only impacts bus state error case
                fray_error_occurred_flag = 1; //flag set = 0 after dumperr command
            }
        }

      //NOT COMPLETED:
        //Periodic capture of NTCs at a different rate than DAQ mode stuff.
        //Probably need to set up a NEW get_DTCs function that runs in the background instead of holding up main
        // Current get_DTCs use will prevent normal DAQ data print, and migh result in some data not printed.
     // Now Completed rev06
        if(NTC_main_get_flag==YES)
        {
            NTC_main_get_flag = NO;
            get_DTCs1_background();
            NTC_main_get_flag = 100; //wait for response value
        }
        else if((NTC_main_get_flag == 100)&&(ECU1_XCP_reply_index == MAX_ECU1_XCP_reply_index_bkgd))
        {
            ECU1_XCP_reply_index = 0;
            NTC_main_get_flag = 0;

            build_dtc1_bkgd_return_message();

            NTC_get_print_flag = YES;
        }

        /*NEW METHOD:
        *   1) Labview sends "set_config" followed by daq config data (after some handshaking). CIB parses and stores data.
        *       CIB has default values in case no set_config command.
        *   2) Labview program sends "enable_data_stream" command
        *       a) if((ign1_status > 0)&&(DAQ_mode_on_off == ON)&&(print_data_flag == 1)) ----> Send daq mode + MTS stand + NTC data. Send rate = DAQ rate. Flag to print set after rx of all DAQ vars.
        *       b) else if((ign1_status == 0)&&(MTS_only_print == 1)) ----> Send MTS stand data only. Send rate = DAQ rate. Flag to print is in rtinotification.
        *       c) else if((ign1_status == 1) && (NTC_get_print_flag == 1)) ----> Send NTC data only. Send rate = NTC rate. Flag to print is after get_DTCs in main finishes.
        *   3) p_on and p_off control if DAQ mode data is being collected.
        *       if enable_data_stream command occurs after p_on, DAQ mode is started by setting call_start_daq_after_this_command_flag flag, this causes main to send "start_daq_mode" command.
        *       if enable_data_stream command occurs before p_on, every p_on sets call_start_daq_after_this_command_flag flag, so main can command "start_daq_mode" command.
        *       p_off always sends sends CAN/Flexray command to "stop daq mode". p_off always sets CIB flags to stop looking for DAQ mode data.
        *   4) "disable_data_stream" command shuts stops all periodic comms output to labview program. Also immediately sends out stop daq mode command on CAN/Flexray.
        *   5) A lot of the below is now L02 stand specific for retransmit of certain variables.
        */

     // rev07
        if (enable_data_stream_flag == 1)
        {
            /********************************************************************************/
            /* if enable data stream is ON and ign is ON, append MTS and/or NTC to DAQ data.*/
            if ((ign1_status > 0) && (DAQ_mode_on_off == ON) && (print_data_flag == 1))
            {

                temp_clock_grab_beginning = system_msec_clock;
                print_data_flag = 0;

                print_periodic_variables();
                strcat(return_message, "\r");

                //if MTS is available, strcat
                if (MTS_available_flag == 1)
                {
                    sprintf(temp_return_message,
                            "mts_data,%d,%d,%.3f,%d,%.3f,%.3f,%d\r",
                            MTS_running_flag, MTS_Store_DAQ_Data_Mode_HEX_Byte,
                            MTS_Vehicle_Speed_flt, MTS_System_State_HEX_Byte,
                            MTS_Angle_Cmd_fp_in, MTS_Torque_Cmd_fp_in,
                            MTS_Bus_Fault_State_HEX_Byte);
                    strcat(return_message, temp_return_message);
                }
                //if NTCs available, strcat NTCs
                if (NTC_get_print_flag == 1)
                {
                    NTC_get_print_flag = 0;
                    strcat(return_message, dtc1_bkgd_return_message);
                }
                //Always add cib_timer,system_msec_clock
                sprintf(temp_return_message, "cib,%lu,%d,%s,%s\r",
                        system_msec_clock, ign1_status,
                        CIB_config_data.BOARD_ID,snap_authorization_str);
                strcat(return_message, temp_return_message);

                //*********************************************
                // Jeremy and I ran into an issue when sending multiple packets of data over TCP with 10ms between each packet.
                //      SCI data looked PERFECT
                //      Root cause points most likely to the Lantronix module previous transmission midway through and starting next transmission.
                //      There is no problem when sending large packets of data using Lantronix module. Only error is when you send multiple, separate packets
                //          in a row, with ~10ms between each packet. Could be part of the SCI to TCPIP packet building that we don't see.
                //  Potential fix is to buffer 5 chunks of data for DAQ Rate < 50 ms and push out at 5 X ms DAQ rate (so 10ms DAQ rate sends TCIP data
                //      for 5 DAQ collections out at 50ms intervals).
                //  Adding \n to the end of every packet
                //
                if(Set_DAQ_List_mode_DAQ_rate < 50)
                {
                    if(buffered_idx == 0)
                    {
                        strcpy(buffered_return_message,return_message);
                        strcat(buffered_return_message,"\n"); //add \n between packets so labview can easily differientiate
                        buffered_idx++;
                    }
                    else if(buffered_idx < 4)
                    {
                        strcat(buffered_return_message,return_message);
                        strcat(buffered_return_message,"\n"); //add \n between packets so labview can easily differientiate
                        buffered_idx++;
                    }
                    else
                    {
                        strcat(buffered_return_message,return_message);
                        strcat(buffered_return_message,"\n"); //add \n between packets so labview can easily differientiate
                        strcpy(words[0], "daq");
                        transmit_str_485(buffered_return_message);
                        buffered_idx = 0;
                    }
                }
                else
                {
                    strcat(return_message,"\n");
                    strcpy(words[0], "daq");
                    transmit_str_485(return_message);
                }

                // ------Transmit 'periodic' CAN Variable Data from DUT's-----------------
                // ------And Transmit 'event' CAN Variable Data from DUT's-----------------

                int jj, r = 0;
                unsigned char swap[4];  // method 1 var
                for (jj = 0; jj < number_of_DAQ_variables; jj++)
                {
           // rev07
                    if (strcmp(variable_info[jj].name,"Rte_CDD_MotAgCmp_DigMotHwPosn") == 0) //store motor angle for retransmit on CAN
                    {
                        for (r = 0; r < 4; r++) {swap[r] = variable_info[jj].data[3 - r];}
                        memcpy(DUT_Motor_Angle_out_str, swap, 4);
                    }
                    else if (strcmp(variable_info[jj].name,"Rte_AssiSumLim_MotTqCmd_Val") == 0)//store motor torque for retransmit on CAN
                    {
                        for (r = 0; r < 4; r++) {swap[r] = variable_info[jj].data[3 - r];}
                        memcpy(DUT_Motor_Torque_out_str, swap, 4);
                        memcpy(&DUT_Motor_torque_fp, &swap, 4);
                    }
                    else if (strcmp(variable_info[jj].name,"Rte_CDD_MotCtrlMgr_MotCurrQax_Val") == 0)//store motor current for retransmit on CAN
                    {
                        for (r = 0; r < 4; r++) {swap[r] = variable_info[jj].data[3 - r];}
                        memcpy(DUT_Motor_Current_out_str, swap, 4);
                    }
                    else if (strcmp(variable_info[jj].name,"Rte_TEstimn_MotWidgT_Val") == 0)//store motor temp for retransmit on CAN
                    {
                        for (r = 0; r < 4; r++) {swap[r] = variable_info[jj].data[3 - r];}
                        memcpy(DUT_Motor_Temp_out_str, swap, 4);
                    }
                    else if (strcmp(variable_info[jj].name,"Rte_EcuTMeas_EcuTFild_Val") == 0)//store ECU temp for retransmit on CAN
                    {
                        for (r = 0; r < 4; r++) {swap[r] = variable_info[jj].data[3 - r];}
                        memcpy(DUT_Controller_Current_out_str, swap, 4);
                    }
                }

                switch(CIB_config_data.BOARD_ID[0])
                {

                case '1':
                {
                  // transmit periodic Variable data for device #1
                  canTransmit(canREG2, L02_MTS_D1_1D1_Motor_Angle_out, ( uint8 *) DUT_Motor_Angle_out_str);               // CAN ID 1D1 CAN message box 1 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D1_2D1_Motor_Torque_out, ( uint8 *) DUT_Motor_Torque_out_str);             // CAN ID 2D1 CAN message box 2 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D1_3D1_Motor_Current_out, ( uint8 *) DUT_Motor_Current_out_str);           // CAN ID 3D1 CAN message box 3 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D1_4D1_Motor_Temp_out, ( uint8 *) DUT_Motor_Temp_out_str);                 // CAN ID 4D1 CAN message box 4 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D1_5D1_Controller_Current_out, ( uint8 *) DUT_Controller_Current_out_str); // CAN ID 5D1 CAN message box 5 -string needs to be filled in flexray notification from DAQ mode variables

                  // transmit 'event' Variable data for device #1
                  if(General_Fault_state_out_flag > 0)
                  {
                    canTransmit(canREG2, L02_MTS_D1_711_General_Fault_State_out, ( uint8 *) General_Fault_state_out_str);
                  }  // End if(Fault_state_out > 0)

                  if(Fault_FET_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D1_712_FET_Temp_Fault_out, ( uint8 *) Fault_FET_temp_out_str);
                  }  // END if(Fault_FET_temp_out_flag == 1)

                  if(Fault_Motor_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D1_713_Motor_Temp_Fault_out, ( uint8 *) Fault_Motor_temp_out_str);
                  }  // END if(Fault_Motor_temp_out_flag == 1)

                }  // case '1'
               break;  // break case '1'

                case '2':
                {
                  // transmit periodic Variable data for device #2
                  canTransmit(canREG2, L02_MTS_D2_1D2_Motor_Angle_out, ( uint8 *) DUT_Motor_Angle_out_str);               // CAN ID 1D2 CAN message box 1 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D2_2D2_Motor_Torque_out, ( uint8 *) DUT_Motor_Torque_out_str);             // CAN ID 2D2 CAN message box 2 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D2_3D2_Motor_Current_out, ( uint8 *) DUT_Motor_Current_out_str);           // CAN ID 3D2 CAN message box 3 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D2_4D2_Motor_Temp_out, ( uint8 *) DUT_Motor_Temp_out_str);                 // CAN ID 4D2 CAN message box 4 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D2_5D2_Controller_Current_out, ( uint8 *) DUT_Controller_Current_out_str); // CAN ID 5D2 CAN message box 5 -string needs to be filled in flexray notification from DAQ mode variables

                  // transmit 'event' Variable data for device #2
                  if(General_Fault_state_out_flag > 0)
                  {
                    canTransmit(canREG2, L02_MTS_D2_721_General_Fault_State_out, ( uint8 *) General_Fault_state_out_str);
                  }  // End if(Fault_state_out > 0)

                  if(Fault_FET_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D2_722_FET_Temp_Fault_out, ( uint8 *) Fault_FET_temp_out_str);
                  }  // END if(Fault_FET_temp_out_flag == 1)

                  if(Fault_Motor_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D2_723_Motor_Temp_Fault_out, ( uint8 *) Fault_Motor_temp_out_str);
                  }  // END if(Fault_Motor_temp_out_flag == 1)

                }  // case '2'
               break;  // break case '2'

                case '3':
                {
                  // transmit periodic Variable data for device #3
                  canTransmit(canREG2, L02_MTS_D3_1D3_Motor_Angle_out, ( uint8 *) DUT_Motor_Angle_out_str);               // CAN ID 1D3 CAN message box 1 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D3_2D3_Motor_Torque_out, ( uint8 *) DUT_Motor_Torque_out_str);             // CAN ID 2D3 CAN message box 2 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D3_3D3_Motor_Current_out, ( uint8 *) DUT_Motor_Current_out_str);           // CAN ID 3D3 CAN message box 3 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D3_4D3_Motor_Temp_out, ( uint8 *) DUT_Motor_Temp_out_str);                 // CAN ID 4D3 CAN message box 4 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D3_5D3_Controller_Current_out, ( uint8 *) DUT_Controller_Current_out_str); // CAN ID 5D3 CAN message box 5 -string needs to be filled in flexray notification from DAQ mode variables

                  // transmit 'event' Variable data for device #3
                  if(General_Fault_state_out_flag > 0)
                  {
                    canTransmit(canREG2, L02_MTS_D3_731_General_Fault_State_out, ( uint8 *) General_Fault_state_out_str);
                  }  // End if(Fault_state_out > 0)

                  if(Fault_FET_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D3_732_FET_Temp_Fault_out, ( uint8 *) Fault_FET_temp_out_str);
                  }  // END if(Fault_FET_temp_out_flag == 1)

                  if(Fault_Motor_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D3_733_Motor_Temp_Fault_out, ( uint8 *) Fault_Motor_temp_out_str);
                  }  // END if(Fault_Motor_temp_out_flag == 1)

                }  // case '3'
               break;  // break case '3'

                case '4':
                {
                  // transmit periodic Variable data for device #4
                  canTransmit(canREG2, L02_MTS_D4_1D4_Motor_Angle_out, ( uint8 *) DUT_Motor_Angle_out_str);               // CAN ID 1D4 CAN message box 1 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D4_2D4_Motor_Torque_out, ( uint8 *) DUT_Motor_Torque_out_str);             // CAN ID 2D4 CAN message box 2 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D4_3D4_Motor_Current_out, ( uint8 *) DUT_Motor_Current_out_str);           // CAN ID 3D4 CAN message box 3 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D4_4D4_Motor_Temp_out, ( uint8 *) DUT_Motor_Temp_out_str);                 // CAN ID 4D4 CAN message box 4 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D4_5D4_Controller_Current_out, ( uint8 *) DUT_Controller_Current_out_str); // CAN ID 5D4 CAN message box 5 -string needs to be filled in flexray notification from DAQ mode variables

                  // transmit 'event' Variable data for device #4
                  if(General_Fault_state_out_flag > 0)
                  {
                    canTransmit(canREG2, L02_MTS_D4_741_General_Fault_State_out, ( uint8 *) General_Fault_state_out_str);
                  }  // End if(Fault_state_out > 0)

                  if(Fault_FET_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D4_742_FET_Temp_Fault_out, ( uint8 *) Fault_FET_temp_out_str);
                  }  // END if(Fault_FET_temp_out_flag == 1)

                  if(Fault_Motor_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D4_743_Motor_Temp_Fault_out, ( uint8 *) Fault_Motor_temp_out_str);
                  }  // END if(Fault_Motor_temp_out_flag == 1)

                }  // case '4'
               break;  // break case '4'

                case '5':
                {
                  // transmit periodic Variable data for device #5
                  canTransmit(canREG2, L02_MTS_D5_1D5_Motor_Angle_out, ( uint8 *) DUT_Motor_Angle_out_str);               // CAN ID 1D5 CAN message box 1 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D5_2D5_Motor_Torque_out, ( uint8 *) DUT_Motor_Torque_out_str);             // CAN ID 2D5 CAN message box 2 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D5_3D5_Motor_Current_out, ( uint8 *) DUT_Motor_Current_out_str);           // CAN ID 3D5 CAN message box 3 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D5_4D5_Motor_Temp_out, ( uint8 *) DUT_Motor_Temp_out_str);                 // CAN ID 4D5 CAN message box 4 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D5_5D5_Controller_Current_out, ( uint8 *) DUT_Controller_Current_out_str); // CAN ID 5D5 CAN message box 5 -string needs to be filled in flexray notification from DAQ mode variables

                  // transmit 'event' Variable data for device #5
                  if(General_Fault_state_out_flag > 0)
                  {
                    canTransmit(canREG2, L02_MTS_D5_751_General_Fault_State_out, ( uint8 *) General_Fault_state_out_str);
                  }  // End if(Fault_state_out > 0)

                  if(Fault_FET_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D5_752_FET_Temp_Fault_out, ( uint8 *) Fault_FET_temp_out_str);
                  }  // END if(Fault_FET_temp_out_flag == 1)

                  if(Fault_Motor_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D5_753_Motor_Temp_Fault_out, ( uint8 *) Fault_Motor_temp_out_str);
                  }  // END if(Fault_Motor_temp_out_flag == 1)

                }  // case '5'
               break;  // break case '5'

                case '6':
                {
                  // transmit periodic Variable data for device #6
                  canTransmit(canREG2, L02_MTS_D6_1D6_Motor_Angle_out, ( uint8 *) DUT_Motor_Angle_out_str);               // CAN ID 1D6 CAN message box 1 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D6_2D6_Motor_Torque_out, ( uint8 *) DUT_Motor_Torque_out_str);             // CAN ID 2D6 CAN message box 2 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D6_3D6_Motor_Current_out, ( uint8 *) DUT_Motor_Current_out_str);           // CAN ID 3D6 CAN message box 3 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D6_4D6_Motor_Temp_out, ( uint8 *) DUT_Motor_Temp_out_str);                 // CAN ID 4D6 CAN message box 4 -string needs to be filled in flexray notification from DAQ mode variables
                  canTransmit(canREG2, L02_MTS_D6_5D6_Controller_Current_out, ( uint8 *) DUT_Controller_Current_out_str); // CAN ID 5D6 CAN message box 5 -string needs to be filled in flexray notification from DAQ mode variables

                  // transmit 'event' Variable data for device #6
                  if(General_Fault_state_out_flag > 0)
                  {
                    canTransmit(canREG2, L02_MTS_D6_761_General_Fault_State_out, ( uint8 *) General_Fault_state_out_str);
                  }  // End if(Fault_state_out > 0)

                  if(Fault_FET_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D6_762_FET_Temp_Fault_out, ( uint8 *) Fault_FET_temp_out_str);
                  }  // END if(Fault_FET_temp_out_flag == 1)

                  if(Fault_Motor_temp_out_flag == 1)
                  {
                    canTransmit(canREG2, L02_MTS_D6_763_Motor_Temp_Fault_out, ( uint8 *) Fault_Motor_temp_out_str);
                  }  // END if(Fault_Motor_temp_out_flag == 1)

                }  // case '6'
               break;  // break case '6'

                }  // END switch(CIB_config_data.BOARD_ID[0])


            } //end ((ign1_status > 0)&&(DAQ_mode_on_or_off == ON)&&(print_data_flag == 1))

            /*******************************************************************/
            /* if ign is ON, send out MTS data or add on DTC data if available */
       // rev07
            else if ((ign1_status == 1) && (MTS_only_print == 1))
            {
                MTS_only_print = 0;
                sprintf(return_message, "mts_data,%d,%d,%.3f,%d,%.3f,%.3f,%d\r",

                        MTS_Store_DAQ_Data_Mode_HEX_Byte, MTS_running_flag,
                        MTS_Vehicle_Speed_flt, MTS_System_State_HEX_Byte,
                        MTS_Angle_Cmd_fp_in, MTS_Torque_Cmd_fp_in,
                        MTS_Bus_Fault_State_HEX_Byte);

                if (NTC_get_print_flag == 1) {

                    NTC_get_print_flag = 0;
                    strcat(return_message, dtc1_bkgd_return_message);
                }

                //Always add cib_timer,system_msec_clock
                sprintf(temp_return_message, "cib,%lu,%d,%s,%s\r",
                        system_msec_clock, ign1_status,
                        CIB_config_data.BOARD_ID,snap_authorization_str);
                strcat(return_message, temp_return_message);

                if(Set_DAQ_List_mode_DAQ_rate < 50)
                {
                    if(buffered_idx == 0)
                    {
                        strcpy(buffered_return_message,return_message);
                        strcat(buffered_return_message,"\n"); //add \n between packets so labview can easily differientiate
                        buffered_idx++;
                    }
                    else if(buffered_idx < 4)
                    {
                        strcat(buffered_return_message,return_message);
                        strcat(buffered_return_message,"\n"); //add \n between packets so labview can easily differientiate
                        buffered_idx++;
                    }
                    else
                    {
                        strcat(buffered_return_message,return_message);
                        strcat(buffered_return_message,"\n"); //add \n between packets so labview can easily differientiate
                        strcpy(words[0], "daq");
                        transmit_str_485(buffered_return_message);
                        buffered_idx = 0;
                    }
                }
                else
                {
                    strcat(return_message,"\n");
                    strcpy(words[0], "daq");
                    transmit_str_485(return_message);
                }

            } //end else if((ign1_status == 1)&&(MTS_only_print == 1))
            /*****************************************/
            /* if ign is OFF, send out ONLY MTS data */
            else if ((ign1_status == 0) && (MTS_only_print == 1))
            {
                MTS_only_print = 0;
                sprintf(return_message, "mts_data,%d,%d,%.3f,%d,%.3f,%.3f,%d\r",

                        MTS_Store_DAQ_Data_Mode_HEX_Byte, MTS_running_flag,
                        MTS_Vehicle_Speed_flt, MTS_System_State_HEX_Byte,
                        MTS_Angle_Cmd_fp_in, MTS_Torque_Cmd_fp_in,
                        MTS_Bus_Fault_State_HEX_Byte);

                //Always add cib_timer,system_msec_clock
                sprintf(temp_return_message, "cib,%lu,%d,%s,%s\r",
                        system_msec_clock, ign1_status,
                        CIB_config_data.BOARD_ID,snap_authorization_str);
                strcat(return_message, temp_return_message);

                //debug copy whole thing 5 times total
                //memcpy(&temp_return_message,&return_message,strlen(return_message));
                //strcat(return_message,temp_return_message);
                //strcat(return_message,temp_return_message);
                //strcat(return_message,temp_return_message);
                //strcat(return_message,temp_return_message);

                if(Set_DAQ_List_mode_DAQ_rate < 50)
                {
                    if(buffered_idx == 0)
                    {
                        strcpy(buffered_return_message,return_message);
                        strcat(buffered_return_message,"\n"); //add \n between packets so labview can easily differientiate
                        buffered_idx++;
                    }
                    else if(buffered_idx < 4)
                    {
                        strcat(buffered_return_message,return_message);
                        strcat(buffered_return_message,"\n"); //add \n between packets so labview can easily differientiate
                        buffered_idx++;
                    }
                    else
                    {
                        strcat(buffered_return_message,return_message);
                        strcat(buffered_return_message,"\n"); //add \n between packets so labview can easily differientiate
                        strcpy(words[0], "daq");
                        transmit_str_485(buffered_return_message);
                        buffered_idx = 0;
                    }
                }
                else
                {
                    strcat(return_message,"\n");
                    strcpy(words[0], "daq");
                    transmit_str_485(return_message);
                }

            } //end else if((ign1_status == 0)&&(MTS_only_print == 1))

            temp_clock_grab_ending = system_msec_clock;
        } //end if(enable_data_stream_flag == 1)


    // Standard Microcore code
        // Debug  -- added routine to use MicroCore1 User switch to simulate Yellow B_CIB switch, for SNAP functionality
        //  The start address of the primary system module frame is FFFF FF00h
        //  SYSPC1-9 registers,controls the function of the ECLK Pin in GIO Mode
        //      systemPORT points to SYSPC4 which contains the logic state of ECLK Pin

                het_test2 = gioGetBit(systemPORT, 0);
// ECLK port pin is pulled up, so 0 = USER_BUTTON1 (MicroCore)  button pushed
                if (het_test2 == 0)
                {

                    system_msec_clock_temp = system_msec_clock + 5000;   // wait debounce switch
                    while(system_msec_clock < system_msec_clock_temp);

                    SW1_is_snapping_snapped1_snapped2_reset_none = SNAPPING;
                    SNAP_timeout_clock = system_msec_clock + 10000;     // set timeout to 10 seconds into future
                    // set gioA(bit0=1)->Lantastic LAN CP1=1, network broadcast query of port status will show a high on CP1
                    // RTI notification will monitor for SNAP feature timeout and reset gioA(bit0=0).
                    gioSetBit(gioPORTA, 5, 1 ); // set Lantronix port[0], so UDP:30704 MONITOR command 13h00h00h00h00h will send a "1" for this port
                        // may want too use a different Lantronix port for identification of SNAP, because GIOA[5] is the only interruptible LAN pin assigned to TMS570LS31
                        //  May mean code change in GIOA notification code to identify LAN port pin is high
                }
/* OLD B_Board
        // Debug  -- added routine to use B_Board switch to simulate Yellow B_CIB switch, for SNAP and RESET functionality
                het_test2 = spiREG5->PCDIN;
                het_test3 = het_test2 & 0x00060000;
                if (het_test3 != 0x00060000)
                {

                    SW1_is_snapping_snapped1_snapped2_reset_none = SNAPPING;
                    SNAP_timeout_clock = system_msec_clock + 10000;     // set timeout to 10 seconds into future
                    // set gioA(bit0=1)->Lantastic LAN CP1=1, network broadcast query of port status will show a high on CP1
                    // RTI notification will monitor for SNAP feature timeout and reset gioA(bit0=0).
                    gioSetBit(gioPORTA, 0, 1 ); // set Lantronix port[0], so UDP:30704 MONITOR command 13h00h00h00h00h will send a "1" for this port
                }
*/
/* OLD B_Board
        // Debug  -- added routine to software reset by using Bulgarian Board switches
        het_test2 = spiREG5->PCDIN;
        het_test3 = het_test2 & 0x00060000;
        if (het_test3 != 0x00060000)
        {
            gioSetPort(gioPORTA, ((gioGetPort(gioPORTA) & 0x0F)+0xF0)); // turn on LED[4,5,6,7]
            for(loop_cnt_b = 0; loop_cnt_b < 60000000 ; loop_cnt_b++);      // delay loop to see LEDs on before softReset

            SW1_is_snapping_snapped1_snapped2_reset_none = RESET;
            // push software reset -- System Exception Control Register (SYSECR)
            //SYSECR: Write 0 to bit 14.
            //SYSECR: Write 1 to bit 15

            systemREG1->SYSECR = systemREG1->SYSECR | 0x8000; //1000 0000 0000 0000
        }
        // end Debug  -- software reset switch
*/
             // rev06
                if((call_start_daq_after_this_command_flag == YES)&&(ign1_status>0))
                {
                    call_start_daq_after_this_command_flag = 0;
                    sprintf(command_str,"start_daq_mode n/a %d",Set_DAQ_List_mode_DAQ_rate);
                    flag_to_process = 1;
                }
                else if(MTS_System_State_change_flag == YES)
                {
                    if(MTS_System_State_HEX_Byte_old == 0x02) //MTS tells CIB to p_on
                    {
                        MTS_System_State_change_flag = OFF;
                        strcpy(command_str,"p_on");
                        flag_to_process = 1;
                    }
                    else if(MTS_System_State_HEX_Byte_old == 0x03) //MTS tells CIB to p_on_warm
                    {
                        MTS_System_State_change_flag = OFF;
                        strcpy(command_str,"p_on_warm");
                        flag_to_process = 1;
                    }
                    else if (MTS_System_State_HEX_Byte_old == 0x00) //MTS tells CIB to p_off
                    {
                        MTS_System_State_change_flag = OFF;
                        strcpy(command_str,"p_off");
                        flag_to_process = 1;
                    }
                }

        if (flag_to_process > 0)
            {

        // Debug says we received a serial line /cr, this sciSend to port1 will echo to the USB on the B_Board, or Terminal in CCS
            strcpy(sbuf_tx_main,"REC ");
            strcat(sbuf_tx_main,command_str);
            strcat(sbuf_tx_main,"\r\n");
            sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
            // debug -- end of echo to SCI1

            flag_to_process = 0;
            memset(words[0],0,225); /* clear words for message processing */
            loop_cnt_a = 0;
            words_ptr = strtok(command_str,sepchars);
            while (words_ptr != NULL)
            {
                strcpy(words[loop_cnt_a],words_ptr);
                loop_cnt_a++;
                words_ptr = strtok(NULL,sepchars);
            }
            memset(command_str,0,255);   /* clears command buffer for next message */
            eval_command_string();  /* call to function, done here manually. */
            memset(words[0],0,225); /* clear words for message proccessing */

            mp=0;

            }
        else
            {
            }

// auto recover from 'BUSSOFF' error,  not sure if neccesary here. In TMS570, canErrorNotification() should handle it OK
//          if canEnableErrorNotification() is called.
        goto Z_lable;
                    can1_stat_temp = canREG1->ES; // read the can status register and assign
                                                  //to temp var for checking bussoff bit
        //          gioGetBit(gioPORT_t *port, uint32 bit)

                    // Old CIB recovery
                    if(checkbit(can1_stat_temp,7))  /* buss off */
                    {

                        bus1_off_state = 1; //set bussoff flag to one
                                      // it is cleared after a dumperr so we no there was
                                      // a bussoff somewhere before this dump
                        clrbit(canREG1->CTL,0); // clr software init to start recovery  TMS570
                        //              gioSetBit(canREG1->CTL, 0, 0 );

//                      clrbit(CAN1.can_con,0); // clr software init to start recovery

                        system_msec_clock_temp = system_msec_clock + 100;   // wait 100mS for bus to restart
                        while(system_msec_clock < system_msec_clock_temp);

                        can1_request_index = 2999;  // set index to hit case 2999 (default)in isr, do nothing
                        canTransmit(canREG1, CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);

                        system_msec_clock_temp = system_msec_clock + 100;   // wait 100mS to allow valid speed message before TOC enable
                        while(system_msec_clock < system_msec_clock_temp);


                    }     // end if buss off reset

                    /* ------------  CAN BUS 2  TMS570 version */
                    can2_stat_temp = canREG2->ES; // read the can status register and assign
                                                  //to temp var for checking bussoff bit

                    if(checkbit(can2_stat_temp,7))  /* buss off */
                    {

                        bus2_off_state = 1; //set bussoff flag to one
                                      // it is cleared after a dumperr so we no there was
                                      // a bussoff somewhere before this dump
                        clrbit(canREG2->CTL,0); // clr software init to start recovery  TMS570
        //              gioSetBit(canREG1->CTL, 0, 0 );

                        system_msec_clock_temp = system_msec_clock + 100;   // wait 100mS for bus to restart
                        while(system_msec_clock < system_msec_clock_temp);

                    }     // end if buss off reset

        //  ********* end 'BUSSOFF auto recover

        Z_lable:


/* ------------------------  M A I N  TOC CAN programmatic writes       ---------------- */

        if(ign1_status == NORMAL)
//      if(ign_on_flag == TRUE)     // flag set in eval_command
        {

//  *******************  Ensure Tester Present is not sent during Manufacturing Service call for new Torque  **********
            if((ucurr_flag == 1) || (hcurr_write_interval_data == 1))       // flag set in eval_command, user set new current
            {

                set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.



                // special for FORD  - After switching torque, wait for new value to stabilize, then capture motor and
                //   handwheel torque for dump_err in lue of hcurr and capture in notification

                //  New B_CIB code 22MAR18
         /******  FORD is unique,  hcurr values are only set on demand by a torque command, some may or may not be available at time of dumperr
          *         so a flag is set at time of request so parse() will not write invalid values over valid values.
          */

                switch(target_product)
                {
                    case TARGET_CD391_ADAS:
                    case TARGET_FORD_T3_T6:

                    {
                        // pause for 2 seconds and then
                        // go out and get motor and handwheel torque

                        system_msec_clock_temp = system_msec_clock + 2000;  // wait 2 Sec
                        while(system_msec_clock < system_msec_clock_temp);

                        switch(torque_value_case_index)
                        {
                        // store in low 0.0 .1 and .5
                        case pos_0nm:
                        case pos_p1nm:
                        case neg_p1nm:
                        case pos_p5nm:
                        case neg_p5nm:
                        {
                            FORD_hcurr_low_value_is_set  = TRUE;

                            switch(target_product)
                            {
                            case TARGET_CD391_ADAS:
                                can1_request_index = 2000; // CAN isr case for storing Qax readings
                                canTransmit(canREG1, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_MtrCurrQax_str);

                                can2_request_index = 2000; // CAN isr case for storing Qax readings
                                canTransmit(canREG2, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_MtrCurrQax_str);
                            break;
                            case TARGET_FORD_T3_T6:
                                can1_request_index = 2000; // CAN isr case for storing Qax readings
                                canTransmit(canREG1, FORD_T3_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_T3_ECU1_MtrCurrQax_str);

                                can2_request_index = 2000; // CAN isr case for storing Qax readings
                                canTransmit(canREG1, FORD_T3_ECU2_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_T3_ECU2_MtrCurrQax_str);
                            break;

                            }
                        }
                        break;

                // store in  med 1.0 1.5 and 2.0
                        case pos_1p00nm:
                        case neg_1p00nm:
                        case pos_1p50nm:
                        case neg_1p50nm:
                        case pos_2p00nm:
                        case neg_2p00nm:
                        {
                            FORD_hcurr_med_value_is_set  = TRUE;

                            switch(target_product)
                            {
                            case TARGET_CD391_ADAS:
                                can1_request_index = 2010; // CAN isr case for storing Qax readings
                                canTransmit(canREG1, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_MtrCurrQax_str);

                                can2_request_index = 2010; // CAN isr case for storing Qax readings
                                canTransmit(canREG2, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_MtrCurrQax_str);
                            break;
                            case TARGET_FORD_T3_T6:
                                can1_request_index = 2010; // CAN isr case for storing Qax readings
                                canTransmit(canREG1, FORD_T3_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_T3_ECU1_MtrCurrQax_str);

                                can2_request_index = 2010; // CAN isr case for storing Qax readings
                                canTransmit(canREG1, FORD_T3_ECU2_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_T3_ECU2_MtrCurrQax_str);
                            break;

                            }
                        }
                        break;

                // store in  high 2.5 3.0 3.5 4.0.and 6.0nm
                        case pos_2p50nm:
                        case neg_2p50nm:
                        case pos_3p00nm:
                        case neg_3p00nm:
                        case pos_3p50nm:
                        case neg_3p50nm:
                        case pos_4p00nm:
                        case neg_4p00nm:
                        case pos_6p00nm:
                        case neg_6p00nm:
                        {
                            FORD_hcurr_high_value_is_set = TRUE;

                            switch(target_product)
                            {
                            case TARGET_CD391_ADAS:
                                can1_request_index = 2020; // CAN isr case for storing Qax readings
                                canTransmit(canREG1, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_MtrCurrQax_str);

                                can2_request_index = 2020; // CAN isr case for storing Qax readings
                                canTransmit(canREG2, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_MtrCurrQax_str);
                            break;
                            case TARGET_FORD_T3_T6:
                                can1_request_index = 2020; // CAN isr case for storing Qax readings
                                canTransmit(canREG1, FORD_T3_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_T3_ECU1_MtrCurrQax_str);

                                can2_request_index = 2020; // CAN isr case for storing Qax readings
                                canTransmit(canREG1, FORD_T3_ECU2_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_FORD_T3_ECU2_MtrCurrQax_str);
                            break;

                            }
                        }
                        break;

                        }   // end switch(torque_value_case_index) for high med low torque
                    }   // end case: TARGET_CD391_ADAS
                }   // end switch(target_product)

//  ***********************  Write desired Torque  END  *********************

                ucurr_flag = CLR;
                hcurr_write_interval_data = CLR;
            }   //if(ucurr_flag or hcurr_write_interval_data == 1)

/*  high_torque_timer_flag and high_torque_timer_counter , not used anymore, just here for placeholder  */
            if((high_torque_timer_flag == 1) && (high_torque_timer_counter < 1))  // flag is set for 10sec and expired
            {
                    // flag set in eval_command if asking for high currents (protection), timer count down in epa4
                    // UNUSED NOW left this code here just in case it's needed again

                   // NEED TO ADD manufacturing service torque command here like--  " memcpy(&CAN1.Obj[8].Dat.Byte,&ms_write_torque_value_pos_0nm,8) "

                    high_torque_timer_flag = CLR;

            }   // if((high_torque_timer_flag == 1) && (high_torque_timer_counter < 1)


        }   // if(ign1_status == NORMAL  ---    was if(ign_on_flag == TRUE)



}       // End of while(1) loop

/* USER CODE END */

    return 0;
}


/* USER CODE BEGIN (4) */

void eval_command_string(void)
{
/* test for command in command set, if found, break. case_select will = command #.  If not found switch will default */
/* and "command syntax error" will be sent unless in rs485 mode in which case nothing is returned. */


    for( case_select = 0; case_select < NUM_OF_COMMANDS; case_select++)
    {
        if(((test = strcmp(words[0],commands[case_select])) == 0))
        {
            break;
        }
    }

    switch (case_select)

    {
    case 0: /*dumperr, CIB ClassII format, then clear  */
    {
        if(trig_flag==0)
         {
          trig();
          dump();
         }

         else

         {
          dump();  // trig already done (flag=1,2,3) so just do dump
         }


        break;
    }

    case 1: /* p_on, start power mode on, normal sequence */
    {
        if(ign1_status != NORMAL)   // only perform init action if current state is ign_off  or warm init
//      if(ign_on_flag != ON)   // only perform init action if current state is ign_off  or warm init

        {

            // On i2C sensor products hold off Response to SENT trigger until i2C has been initialized @ 135mS  such as C1XX ect.
            //  Notification timer will reload HET registers to respond on next trigger
            switch (target_product)
            {
            case TARGET_T1XX:
            case TARGET_BYD_SA2FL:
            case TARGET_GWM_A0607:
            case TARGET_S550DIGITAL:
            case TARGET_FCA_ADAS:
            case TARGET_G2KCA_ADAS:
            case TARGET_SGMW_CN200:
            case TARGET_FORD_T3_T6:
            case TARGET_RENAULT_NISSAN:
            break;

            case TARGET_C1XX:
            case TARGET_CD391_ADAS:
            case TARGET_PSA_CMP:
                hetRAM1->Instruction[0].Program  = 0x000dda00;  // causes BR01 to branch to end of program,skipping all SENT triggering and signal generation, 113mS later load to normal
                hetRAM1->Instruction[0].Control  = 0x000dc000;  // causes BR01 to branch to end of program,skipping all SENT triggering and signal generation, 113mS later load to normal

        //       hetRAM1->Instruction[0].Program  = 0x0002ba00;  // causes BR01 to run HET code normally looking for triggers and creating SENT signals
        //       hetRAM1->Instruction[0].Control  = 0x00002220;  // causes BR01 to run HET code normally looking for triggers and creating SENT signals

        //      HET_msec_countdown_cnt = 113;   // turn on HET SENT signals (113mSec) just after i2C init has completed and just before next SENT trigger
                HET_msec_countdown_cnt = 180;   // was 135mS, seeing FORD ADAS i2C starting init later, try 170mS,300mS

                // turn on HET SENT signals (10 mS for testing)(115mS = 99.99%) (135mS greater than seen) just after i2C init has completed and just before next SENT trigger

            break;
            }


            LED_msec_clock = 0;     // reset LED clock to sync all CIB USER LED flashing

            gioSetBit(hetPORT1, 14, 1); /* turn on Product Ign1, Turn on first */
            gioSetBit(hetPORT1, 15, 1); /* turn on Product Ign2, Turn on first */
            gioSetBit(hetPORT1, 31, 1); /* turn on Product Ign, Turn on here, feads Ign1 and Ign2, no buffer board in B_CIB system */

            ign1_status = WARM; // default to warm init >>> later (here) will change to NORMAL
            ign2_status = WARM; // default to warm init >>> later (here) will change to NORMAL

//          Engine_on_Signal = 0;     // default to warm init >>> E_p_on will change to RUN
//          ign_on_flag = TRUE;     /* flag to prevent dumperr invalid data dump while ign off */
//          speed_flag = 0; /* ensure periodic CAN speed(0kpH, max torque) message is sent */

            system_msec_clock_temp = system_msec_clock + 500;   // was wait 100 , wait for periodic messages to get off, FORD T3 needs
                                                                // more time before connect is recognized and responds
            while(system_msec_clock < system_msec_clock_temp);

            ucurr_flag = 0;     // this is the only time we want to push connect,TOC logic and TOC value, so CLEAR user current flag
            hcurr_flag = OFF;
            stop_T1T2switching = 1;  // stop switching for low current

            can1_request_index = 10000; // do nothing index - just connect, throw away response, allows enable TOC, set TOC and request vars
            can2_request_index = 10000; // do nothing index - just connect, throw away response, allows enable TOC, set TOC and request vars

            switch (target_product)
            {
            case TARGET_T1XX:
            case TARGET_BYD_SA2FL:
            case TARGET_C1XX:
            case TARGET_9BXX:
                canTransmit(canREG1, CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_GWM_A0607:
                canTransmit(canREG1, GWM_A0607_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);  
            break;        
            case TARGET_FCA_ADAS:
                canTransmit(canREG1, FCA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                canTransmit(canREG2, FCA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_CD391_ADAS:
                canTransmit(canREG1, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                canTransmit(canREG2, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_G2KCA_ADAS:
                canTransmit(canREG1, G2KCA_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                canTransmit(canREG1, G2KCA_ECU2_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_PSA_CMP:
                canTransmit(canREG1, PSA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_SGMW_CN200:
                canTransmit(canREG1, CN200_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_FORD_T3_T6:
                canTransmit(canREG1, FORD_T3_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                canTransmit(canREG1, FORD_T3_ECU2_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_RENAULT_NISSAN:
                canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_BMW_UKL:
                system_msec_clock_temp = system_msec_clock + 150;   // wait 100+150=250ms , wait for product to set ign
                while(system_msec_clock < system_msec_clock_temp);
                transmitFlexray(VEH_COG_MSG, VEH_COG,2);
                KLEMMEN_MSG[0][0] = 0xD0;
                transmitFlexray(KLEMMEN_MSG, KLEMMEN,2);
                transmitFlexray(DT_PT_MSG, DT_PT,2);
            break;
            case TARGET_BMW_FAAR_WE:
                system_msec_clock_temp = system_msec_clock + 150;   // wait 100+150=250ms , wait for product to set ign
                while(system_msec_clock < system_msec_clock_temp);
                transmitFlexray(VEH_COG_FAAR_WE_MSG, VEH_COG_FAAR_WE,2);
                CON_VEH_FAAR_WE_MSG[0][2] = 0xA0;
                CON_VEH_FAAR_WE_MSG[1][1] = 0x0A;
                ST_CENG_FAAR_WE_MSG[0][1] = 0x02;
                ST_CENG_FAAR_WE_MSG[1][3] = 0x01;

                //load 0KPH at p_on
                memcpy(&VEH_COG_FAAR_WE_MSG_load_kph[0], &VEH_COG_FAAR_WE_MSG_0kph, 4); //here please
                memcpy(VEH_COG_FAAR_WE_MSG[0], &VEH_COG_FAAR_WE_MSG_load_kph, 4);

                transmitFlexray(CON_VEH_FAAR_WE_MSG, CON_VEH_FAAR_WE,2);
                transmitFlexray(ST_CENG_FAAR_WE_MSG, ST_CENG_FAAR_WE,2);
                transmitFlexray(VEH_COG_FAAR_WE_MSG, VEH_COG_FAAR_WE,2);

                transmitFlexray(MFG_TX_nexteer_session_MSG, MFG_TX,3);
                transmitFlexray(XCP_FAAR_WE_TesterPresent_Rqst_MSG,MFG_TX, 3);

            break;
            }

            if(manufacturing_TOC == YES)
            {

                system_msec_clock_temp = system_msec_clock + 150;   // wait 150 , wait for torque messages to get off
                while(system_msec_clock < system_msec_clock_temp);

                // kick off for nexteer mode and start keep alive / tester message

                tester_present_timer = 3000;  // set timer for 3 seconds
                tester_present_enable_flag = 1; // enable tester present message

                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply and don't send another message.
                ECU2_XCP_reply_index = 20;

                //clear_dtcs_flag = 0; // make sure it is get DTC's  NOT clear
                ECU1_clear_DTCs_flag = 0;
                ECU2_clear_DTCs_flag = 0;

                switch (target_product)
                {
                case TARGET_T1XX:       //EA4 is different
                    canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_BYD_SA2FL:       //EA4 is different
                        canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_GWM_A0607:       //EA4 is different
                        canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_G2KCA_ADAS:     //EA4 is different
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_CD391_ADAS:
                case TARGET_C1XX:
                case TARGET_9BXX:
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_PSA_CMP:
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;
                case TARGET_SGMW_CN200:
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_FORD_T3_T6:     //EA4 is different
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_RENAULT_NISSAN:
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                    fray_request_index = 3000;   // set index to hit case 3000 (default)in isr, send connect message, ignore responce
                    ShiftFRAY();                    //send connect message
                break;

                }

                // when running TOC, need to wait 200ms before initiating TOC command after XCP session request
                system_msec_clock_temp = system_msec_clock + 200;   // wait 200
                while(system_msec_clock < system_msec_clock_temp);

            }  // end if(manufacturing_TOC == YES)

        }  //  END if(ign1_status != ON(normal)  --  if(ign_on_flag != ON(normal)


        // switch torque direction, and start product up at 0.5nm or 0.0nm of torque, set ucurr_flag flag so main loop can process
        //      this function call to set torque _value_case_index works for both Digital sensors and TOC products
        switch (target_product)
        {
        case TARGET_T1XX:
        case TARGET_BYD_SA2FL:
        case TARGET_GWM_A0607:
        case TARGET_C1XX:
        case TARGET_9BXX:
        case TARGET_FCA_ADAS:
        case TARGET_G2KCA_ADAS:
        case TARGET_PSA_CMP:
        case TARGET_SGMW_CN200:
        case TARGET_RENAULT_NISSAN:

             hcurr_change_direction_at_nm(0.5); // switch T1/T2 to 10% or 0.5nm

        break;
        case TARGET_CD391_ADAS:
        case TARGET_FORD_T3_T6:
        case TARGET_BMW_FAAR_WE:
        case TARGET_BMW_UKL:
             hcurr_change_direction_at_nm(0.0); // switch T1/T2 to 0% or 0.0nm
        break;
        }

         ucurr_flag = 1;                // flag to main loop to process new torque values

        ign1_status = NORMAL;
        ign2_status = NORMAL;

        /*L02 test only*/
        if(enable_data_stream_flag == 1)
        {
             //if DAQ rate has been set, begin DAQ mode right after p_on.
            extern unsigned int daq_period_limit;
            if(Set_DAQ_List_mode_DAQ_rate >= daq_period_limit)
            {
                system_msec_clock_temp = system_msec_clock + 500;
                while(system_msec_clock < system_msec_clock_temp);
                call_start_daq_after_this_command_flag = YES;
            }
            if(NTC_get_period >= 1000)
            {
                NTC_get_flag = ON;
            }
        }

        // fix for RTS code wanting a reply from p_on or p_off or RTS code will not operate normally

        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
            case CIB:
                strcpy(return_message,"p_on command\r");
                if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                {
                   transmit_str_485(return_message);
                }
            break;

            case WEB:
                strcpy(return_message,"p_on command\r");
                if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                {
                    transmit_str_485(return_message);
                }
            break;
        }

        break;
    }

    case 2:  /*  p_on_warm,  start power mode on, warm_init sequence */
    {
        // On i2C sensor products hold off response to SENT trigger until i2C has been initialized @ 135mS
        //  Notification timer will reload HET registers to respond on next trigger
        switch (target_product)
        {
        case TARGET_T1XX:
        case TARGET_BYD_SA2FL:
        case TARGET_GWM_A0607:
        case TARGET_S550DIGITAL:
        case TARGET_FCA_ADAS:
        case TARGET_G2KCA_ADAS:
        case TARGET_SGMW_CN200:
        case TARGET_FORD_T3_T6:
        case TARGET_RENAULT_NISSAN:
        case TARGET_BMW_FAAR_WE:
        case TARGET_BMW_UKL:

        break;

        case TARGET_C1XX:
        case TARGET_CD391_ADAS:
        case TARGET_PSA_CMP:

            hetRAM1->Instruction[0].Program  = 0x000dda00;  // causes BR01 to branch to end of program,skipping all SENT triggering and signal generation, 113mS later load to normal
            hetRAM1->Instruction[0].Control  = 0x000dc000;  // causes BR01 to branch to end of program,skipping all SENT triggering and signal generation, 113mS later load to normal

    //       hetRAM1->Instruction[0].Program  = 0x0002ba00;  // causes BR01 to run HET code normally looking for triggers and creating SENT signals
    //       hetRAM1->Instruction[0].Control  = 0x00002220;  // causes BR01 to run HET code normally looking for triggers and creating SENT signals

    //      HET_msec_countdown_cnt = 113;   // turn on HET SENT signals (113mSec) just after i2C init has completed and just before next SENT trigger
            HET_msec_countdown_cnt = 135;   // turn on HET SENT signals (10 mS for testing)(115mS = 99.99%) (135mS greater than seen) just after i2C init has completed and just before next SENT trigger

        break;
        }



        if((ign1_status != WARM) || (ign2_status != WARM))  // only perform warm_init action if current state is ign_off  or p_on (normal)
//      if(ign_on_flag != WARM) // only perform warm_init action if current state is ign_off  or p_on (normal)
        {

            LED_msec_clock = 0;     // reset LED clock to sync all CIB USER LED flashing

            gioSetBit(hetPORT1, 14, 1); /* turn on Product Ign1, Turn on first */
            gioSetBit(hetPORT1, 15, 1); /* turn on Product Ign2, Turn on first */
            gioSetBit(hetPORT1, 31, 1); /* turn on Product Ign, Turn on here, feads Ign1 and Ign2, no buffer board in B_CIB system */

            ign1_status = WARM;
            ign2_status = WARM;

//          Engine_on_Signal = 0;     // default to warm init >>> E_p_on will change to RUN
//          ign_on_flag = TRUE;     /* flag to prevent dumperr invalid data dump while ign off */
//          speed_flag = 0; /* ensure periodic CAN speed(0kpH, max torque) message is sent */

            system_msec_clock_temp = system_msec_clock + 500;   // was wait 100 , wait for periodic messages to get off, FORD T3 needs
                                                                // more time before connect is recognized and responds
            while(system_msec_clock < system_msec_clock_temp);

            ucurr_flag = 0;     // this is the only time we want to push connect,TOC logic and TOC value, so CLEAR user current flag
            hcurr_flag = OFF;


            can1_request_index = 10000; // do nothing index - just connect, throw away Response, allows enable TOC, set TOC and request vars
            can2_request_index = 10000; // do nothing index - just connect, throw away Response, allows enable TOC, set TOC and request vars

            switch (target_product)
            {
            case TARGET_T1XX:
            case TARGET_BYD_SA2FL:
            case TARGET_C1XX:
            case TARGET_9BXX:
                canTransmit(canREG1, CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_GWM_A0607:
            canTransmit(canREG1, GWM_A0607_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect); 
            break;
            case TARGET_FCA_ADAS:
                canTransmit(canREG1, FCA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                canTransmit(canREG2, FCA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_CD391_ADAS:
                canTransmit(canREG1, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                canTransmit(canREG2, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_G2KCA_ADAS:
                canTransmit(canREG1, G2KCA_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                canTransmit(canREG1, G2KCA_ECU2_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_PSA_CMP:
                canTransmit(canREG1, PSA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_SGMW_CN200:
                canTransmit(canREG1, CN200_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_FORD_T3_T6:
                canTransmit(canREG1, FORD_T3_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                canTransmit(canREG1, FORD_T3_ECU2_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_RENAULT_NISSAN:
                canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
            break;
            case TARGET_BMW_FAAR_WE:
            case TARGET_BMW_UKL:
            break;
            }


            if(manufacturing_TOC == YES)
            {

                system_msec_clock_temp = system_msec_clock + 150;   // wait 150 , wait for torque messeges to get off
                while(system_msec_clock < system_msec_clock_temp);

                // kick off for nexteer mode and start keep alive / tester message

                tester_present_timer = 3000;  // set timer for 3 seconds
                tester_present_enable_flag = 1; // enable tester present message

                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply and don't send another message.
                ECU2_XCP_reply_index = 20;

                //clear_dtcs_flag = 0; // make sure it is get DTC's  NOT clear
                ECU1_clear_DTCs_flag = 0;
                ECU2_clear_DTCs_flag = 0;

                switch (target_product)
                {
                case TARGET_T1XX:       //EA4 is different
                    canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_BYD_SA2FL:       //EA4 is different
                    canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_GWM_A0607:      //EA4 is different
                    canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_G2KCA_ADAS:     //EA4 is different
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_CD391_ADAS:
                case TARGET_C1XX:
                case TARGET_9BXX:
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;
                case TARGET_PSA_CMP:
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;
                case TARGET_SGMW_CN200:
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_FORD_T3_T6:     //EA4 is different
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;

                case TARGET_RENAULT_NISSAN:
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                break;
                }

/* ---------  Not sure of why TOC products need to open XCP session and use tester present when in warm_init... (code above) */
/* ---------     But we do alot of product flashing when connected to B_CIB and the tester present message must be disabled for flashing,  so   */

                tester_present_enable_flag = 0; // disable tester present message  for flashing
            }

            // OLD  -- Special test - Warm init mode
            gioSetBit(hetPORT1, 20, 1); // EXT2-14  Itrigger/Relay (compatibility board) same as "relay on"...trigger to voltage stand to start pulse


             /// ******* add time delay
            system_msec_clock_temp = system_msec_clock + 1250;  // wait 1.25 second > WAS 1 second > WAS 750 mS, for system to stabilize after power on
            while(system_msec_clock < system_msec_clock_temp);

// grab System State for Crank Testing when using p_on_warm, performing on CAN1 only for now, awaiting specification for test as ADAS develops
            can1_sys_state_warm_init = -1; // if no reply....variable will be -1
            can2_sys_state_warm_init = -1; // if no reply....variable will be -1

            can1_request_index = 0; // set index to hit case 0 in isr, request all including system state
            fray_request_index = 0;


            system_msec_clock_temp = system_msec_clock + 250;   // set time out to 150mS

            switch (target_product)
            {

            case TARGET_T1XX:       //EA4 is different
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != T1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
                break;
            case TARGET_BYD_SA2FL:       //EA4 is different
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != BYD_SA2FL_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
                break;
            case TARGET_GWM_A0607:       //EA4 is different
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != GWM_A0607_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
                break;
            case TARGET_C1XX:
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != C1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
                break;
            case TARGET_9BXX:
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != GM_9BXX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
            break;
            case TARGET_FCA_ADAS:
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
            break;
            case TARGET_CD391_ADAS:
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
            break;
            case TARGET_G2KCA_ADAS:     //EA4 is different
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
                break;
            case TARGET_PSA_CMP:
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != PSA_CMP_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
                break;
            case TARGET_SGMW_CN200:       //EA4 is different
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != SGMW_CN200_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
                break;
            case TARGET_FORD_T3_T6:       //EA4 is different
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
                break;
            case TARGET_RENAULT_NISSAN:       //EA4 is different
                ShiftCAN1();                    // CCP connect
                while((can1_request_index != RENAULT_NISSAN_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
                break;
            case TARGET_BMW_UKL:
                ShiftFRAY();                //send connect message
                while((fray_request_index != TARGET_BMW_UKL_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */
                break;
            case TARGET_BMW_FAAR_WE:
                ShiftFRAY();                //send connect message
                while((fray_request_index != TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at 22, last CAN reads are done, move on */
                break;

            break;

            }

            parse_can1_data();

            switch(target_product)
            {
            case TARGET_T1XX: can1_sys_state_warm_init = can_T1XX_SystemState_byt; break;
//          case TARGET_BYD_SA2FL: can1_sys_state_warm_init = can_BYD_SA2FL_SystemState_byt; break;
            case TARGET_GWM_A0607: can1_sys_state_warm_init = can_GWM_A0607_SystemState_byt; break;
            case TARGET_C1XX: can1_sys_state_warm_init = can_C1XX_SystemState_byt; break;
            case TARGET_9BXX: break;
            case TARGET_FCA_ADAS: can1_sys_state_warm_init = can1_FCA_SystemState_byt; break;
            case TARGET_CD391_ADAS: can1_sys_state_warm_init = can1_FORD_SystemState_byt; break;
            case TARGET_G2KCA_ADAS: can1_sys_state_warm_init = can1_G2KCA_SystemState_byt; break;
            case TARGET_PSA_CMP: can1_sys_state_warm_init = can1_PSA_CMP_SystemState_byt; break;
            case TARGET_SGMW_CN200: can1_sys_state_warm_init = can1_CN200_SystemState_byt; break;
            case TARGET_FORD_T3_T6: can1_sys_state_warm_init = can1_FORD_T3_ECU1_SystemState_byt; break;
            case TARGET_RENAULT_NISSAN: can1_sys_state_warm_init = can1_RENAULT_NISSAN_SystemState_byt; break;
            case TARGET_BMW_UKL:    can1_sys_state_warm_init = fray1_BMW_UKL_sys_state_byt; break;
            case TARGET_BMW_FAAR_WE:    can1_sys_state_warm_init = fray1_FAAR_WE_SysStMod_byt; break;

            }

        }  //  END if(ign_on_flag != WARM)

        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
            case CIB:
                strcpy(return_message,"p_on_warm command\r");
                if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                {
                   transmit_str_485(return_message);
                }
            break;

            case WEB:
                strcpy(return_message,"p_on_warm command\r");
                if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                {
                    transmit_str_485(return_message);
                }
            break;
        }

        break;
    }

    case 3: /* p_off, start power mode off sequence */
    {
        /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
        case CIB:
            strcpy(return_message,"p_off command\r");
            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
            {
               transmit_str_485(return_message);
            }
        break;

        case WEB:
            strcpy(return_message,"p_off command\r");
            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
            {
                transmit_str_485(return_message);
            }
        break;
        }

        DAQ_mode_on_off = 0;
        NTC_get_flag = 0;

        ign1_status = WARM;
        ign2_status = WARM;

        hcurr_flag = OFF;
        ucurr_flag = CLR;

        switch(target_product)
        {
        case TARGET_BMW_UKL:
            KLEMMEN_MSG[0][0] = 0x50;
            transmitFlexray(KLEMMEN_MSG, KLEMMEN,2);

            system_msec_clock_temp = system_msec_clock + 6000-500; // wait 6 sec (500ms from other product)
            while(system_msec_clock < system_msec_clock_temp);
        break;
        case TARGET_BMW_FAAR_WE:
            //set CTR and ST to OFF values (0xC0)
            CON_VEH_FAAR_WE_MSG[0][2] = 0x10; //was 0xC0
            CON_VEH_FAAR_WE_MSG[1][1] = 0x01; //was 0x0C

            //set DRV and STOP+MTR to OFF values
            ST_CENG_FAAR_WE_MSG[0][1] = 0x00;
            ST_CENG_FAAR_WE_MSG[1][3] = 0x04;

            //load 0KPH at p_off
            memcpy(&VEH_COG_FAAR_WE_MSG_load_kph, &VEH_COG_FAAR_WE_MSG_0kph, 4);
            memcpy(&VEH_COG_FAAR_WE_MSG[0], &VEH_COG_FAAR_WE_MSG_load_kph, 4);

            transmitFlexray(CON_VEH_FAAR_WE_MSG, CON_VEH_FAAR_WE,2);
            transmitFlexray(ST_CENG_FAAR_WE_MSG, ST_CENG_FAAR_WE,2);
            transmitFlexray(VEH_COG_FAAR_WE_MSG, VEH_COG_FAAR_WE,2);

            system_msec_clock_temp = system_msec_clock + 6000-500; // wait 6 sec (500ms from other product)
            while(system_msec_clock < system_msec_clock_temp);

            //after waiting 5.5 seconds, load "no comm" value into CTR and ST
            CON_VEH_FAAR_WE_MSG[0][2] = 0x10; //was 0x00
            CON_VEH_FAAR_WE_MSG[1][1] = 0x01; //was 0x00
            transmitFlexray(CON_VEH_FAAR_WE_MSG, CON_VEH_FAAR_WE,2);
        break;

        case TARGET_SGMW_CN200:
           p_off_continue_periodics_timer = 2000;
        break;

        default:    // all others
            system_msec_clock_temp = system_msec_clock + 500;   // wait 500 mSec, wait for engine_off message to go out before stopping periodic mess in EPA4
            while(system_msec_clock < system_msec_clock_temp);
        break;
        }

        ign1_status = OFF;
        ign2_status = OFF;

//      ign_on_flag = FALSE;        /* flag to prevent dumperr invalid data dump while ign off AND STOP periodic CAN messages */

        // OLD  -- Special test - Warm init mode
        gioSetBit(hetPORT1, 20, 0); // EXT2-14  Itrigger/Relay (compatibility board) same as "relay off" ...trigger to voltage stand to stop pulse

        gioSetBit(hetPORT1, 14, 0); /* turn off Product Ign1 */
        gioSetBit(hetPORT1, 15, 0); /* turn off Product Ign2 */
        gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */

/*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally
        if((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == 1)) // if p_on to buffer using 'E" and my address = 1
        {
                   strcpy(return_message,"p_off command\r");

            transmit_str_485(return_message);
        }   */

        break;
    }

    case 4: /* Reinitialize can chip */
    {
      /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
        case CIB:
            strcpy(return_message,"restartcan command\r");
            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
            {
               transmit_str_485(return_message);
            }
        break;

        case WEB:
            strcpy(return_message,"restartcan command\r");
            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
            {
                transmit_str_485(return_message);
            }
        break;
        }

        clrbit(canREG1->CTL,0); // clr software init to start recovery, TMS570
        bus1_off_state = 0;
        bus1_warn_state = 0;

        clrbit(canREG2->CTL,0); // clr software init to start recovery, TMS570
        bus2_off_state = 0;
        bus2_warn_state = 0;

        break;
    }

    case 5:     /* 0p00nm */
    {
       hcurr_flag = OFF;

        hcurr_change_direction_at_nm(0.0);

        ucurr_flag = 1;     // set user current flag for main to process

      /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
        case CIB:
            strcpy(return_message,"torque 0p0nm command\r");
            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
            {
               transmit_str_485(return_message);
            }
        break;

        case WEB:
            strcpy(return_message,"torque 0p0nm command\r");
            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
            {
                transmit_str_485(return_message);
            }
        break;
        }

        break;
    }

    case 6:     /* 0p10nm */
    {
       hcurr_flag = OFF;

        hcurr_change_direction_at_nm(0.1);

        ucurr_flag = 1;     // set user current flag for main to process

      /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
        case CIB:
            strcpy(return_message,"torque 0p10nm command\r");
            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
            {
               transmit_str_485(return_message);
            }
        break;

        case WEB:
            strcpy(return_message,"torque 0p10nm command\r");
            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
            {
                transmit_str_485(return_message);
            }
        break;
        }

        break;
    }

    case 7:     /* 0p50nm */
    {
       hcurr_flag = OFF;

        hcurr_change_direction_at_nm(0.5);

        ucurr_flag = 1;     // set user current flag for main to process

      /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
        case CIB:
            strcpy(return_message,"torque 0p50nm command\r");
            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
            {
               transmit_str_485(return_message);
            }
        break;

        case WEB:
            strcpy(return_message,"torque 0p50nm command\r");
            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
            {
                transmit_str_485(return_message);
            }
        break;
        }

        break;
    }

    case 8:     /* 1p00nm */
    {
        hcurr_flag = OFF;

        hcurr_change_direction_at_nm(1.0);

        ucurr_flag = 1;     // set user current flag for main to process

      /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
        case CIB:
            strcpy(return_message,"torque 1p00nm command\r");
            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
            {
               transmit_str_485(return_message);
            }
        break;

        case WEB:
            strcpy(return_message,"torque 1p00nm command\r");
            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
            {
                transmit_str_485(return_message);
            }
        break;
        }

        break;
    }

    case 9:     /* 1p50nm */
    {
        hcurr_flag = OFF;

        hcurr_change_direction_at_nm(1.5);

        ucurr_flag = 1;     // set user current flag for main to process

       /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"torque 1p50nm command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"torque 1p50nm command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 10:        /* 2p00nm */
    {
        hcurr_flag = OFF;

        hcurr_change_direction_at_nm(2.0);

        ucurr_flag = 1;     // set user current flag for main to process

       /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"torque 2p00nm command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"torque 2p00nm command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

    break;
    }

    case 11:        /* 2p50nm */
    {
        hcurr_flag = OFF;

        hcurr_change_direction_at_nm(2.5);

        ucurr_flag = 1;     // set user current flag for main to process

      /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
        case CIB:
            strcpy(return_message,"torque 2p50nm command\r");
            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
            {
               transmit_str_485(return_message);
            }
        break;

        case WEB:
            strcpy(return_message,"torque 2p50nm command\r");
            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
            {
                transmit_str_485(return_message);
            }
        break;
        }

        break;
    }

    case 12:        /* 3p00nm */
    {
        hcurr_flag = OFF;

        hcurr_change_direction_at_nm(3.0);

        ucurr_flag = 1;     // set user current flag for main to process

      /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
        case CIB:
            strcpy(return_message,"torque 3p00nm command\r");
            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
            {
               transmit_str_485(return_message);
            }
        break;

        case WEB:
            strcpy(return_message,"torque 3p00nm command\r");
            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
            {
                transmit_str_485(return_message);
            }
        break;
        }

        break;
    }

    case 13:        /* 3p50nm */
    {
        hcurr_flag = OFF;

        hcurr_change_direction_at_nm(3.5);

        ucurr_flag = 1;     // set user current flag for main to process

       /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"torque 3p50nm command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"torque 3p50nm command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 14:    /* 4p00nm */
    {
        hcurr_flag = OFF;

        hcurr_change_direction_at_nm(4.0);

        ucurr_flag = 1;     // set user current flag for main to process

       /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"torque 4p00nm command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"torque 4p00nm command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 15:    /* 6p00nm */
    {
        hcurr_flag = OFF;

        hcurr_change_direction_at_nm(6.0);

        ucurr_flag = 1;     // set user current flag for main to process

       /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"torque 6p00nm command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"torque 6p00nm command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 16:    /* empty_16 */
    {

       /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"empty_16 command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"empty_16 command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 17:    /* hcurr - preps epa4 to run profile, which will signal main to trans TOC values at intervals*/
                /*  also Qax current is read at 3 different spots during Hcurr   */
    {
        hcurr_flag = 0;  // make sure any current hcurr command is canceled, epa4 may interrupt
        hcurr_write_interval_data = NO;     // clr flag to main to write new torque data using torque_value_index_case

        hcurr_timer = 0;    // hcurr uses a count up timer, notification will inc and test in hcurr

        hcurr_flag = 1;  // flag notification to run hcurr profile

       /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"hcurr command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"hcurr command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

    break;
    }

    case 18:    /* clear_dtc's */
    {



     /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
        case CIB:
            sprintf(return_message,"clearing DTC's  CIB#%s \r",CIB_config_data.BOARD_ID);
            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
            {
               transmit_str_485(return_message);
            }
        break;

        case WEB:
            sprintf(return_message,"clearing DTC's  CIB#%s \r",CIB_config_data.BOARD_ID);
            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
            {
                transmit_str_485(return_message);
            }
        break;
        }
        //send connect message
        switch(target_product)
        {
        case TARGET_BMW_UKL:
        case TARGET_BMW_FAAR_WE:
            fray_request_index = 3000;  // set index to hit case 3000 (default)in isr, do nothing
            ShiftFRAY();
        break;

        default:    // all others
            can1_request_index = 3000;  // set index to hit case 3000 (default)in isr, do nothing
            ShiftCAN1();                    //send connect message
        break;
        }

        //CAN1 - Flex1 clear DTCs
        ECU1_XCP_reply_index = 1;
        //clear_dtcs_flag = 1; // set flag for ISR
        ECU1_clear_DTCs_flag = 1;

        switch (target_product)
        {
        case TARGET_T1XX:       //EA4 is different
                canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        case TARGET_BYD_SA2FL:       //EA4 is different
                canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        case TARGET_GWM_A0607:      //EA4 is different
        canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        case TARGET_C1XX:
        case TARGET_9BXX:
                canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        case TARGET_FCA_ADAS:
                canTransmit(canREG1, FCA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        case TARGET_CD391_ADAS:
                canTransmit(canREG1, FORD_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);   // open Nexteer session prior to XCP
        break;

        case TARGET_G2KCA_ADAS:     //EA4 is different
                canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        case TARGET_PSA_CMP:
                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);   // open Nexteer session prior to XCP
        break;

        case TARGET_SGMW_CN200:       //EA4 is different
                canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        case TARGET_FORD_T3_T6:       //EA4 is different
                canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        case TARGET_RENAULT_NISSAN:       //EA4 is different
                canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        case TARGET_BMW_UKL:
            transmitFlexray(Nexteer_session, MFG_TX,2);   // open Nexteer session prior to XCP
        break;

        case TARGET_BMW_FAAR_WE:
            transmitFlexray(MFG_TX_nexteer_session_MSG, MFG_TX,3);   // open Nexteer session prior to XCP
        break;

        }

        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        ECU1_XCP_reply_index = 0;
        ECU1_clear_DTCs_flag = 0; // done...clr flag for ISR


        //CAN2 - Flex2 clear DTCs
        ECU2_XCP_reply_index = 1;
        ECU2_clear_DTCs_flag = 1; // set flag for ISR

        switch (target_product)
        {
        case TARGET_T1XX:       // non ADAS, no CAN2, no Flex 2
        case TARGET_BYD_SA2FL:
        case TARGET_GWM_A0607:
        case TARGET_C1XX:
        case TARGET_9BXX:
        case TARGET_PSA_CMP:
        case TARGET_SGMW_CN200:
        case TARGET_RENAULT_NISSAN:
        case TARGET_BMW_UKL:
        case TARGET_BMW_FAAR_WE:

        break;


        case TARGET_FCA_ADAS:
                canTransmit(canREG2, FCA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        case TARGET_CD391_ADAS:
                canTransmit(canREG2, FORD_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);   // open Nexteer session prior to XCP
        break;

        case TARGET_G2KCA_ADAS:     //EA4 is different
                canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        case TARGET_FORD_T3_T6:       //EA4 is different
                canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
        break;

        }

        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
        while((ECU2_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        ECU2_XCP_reply_index = 0;
        ECU2_clear_DTCs_flag = 0; // done...clr flag for ISR

        break;
        }

    case 19:    /* dtoa chx valuexxxx */
    {

        sscan_cnt = 0;

        sscan_temp1 = 0;
        sscan_temp2 = 0;
        sscan_temp3 = 0;
        sscan_temp4 = 0;
        sscan_temp5 = 0;
        sscan_temp6 = 0;
        sscan_temp7 = 0;
        sscan_temp8 = 0;

        /* bug in sscan,  */
        sscan_cnt += sscanf(words[1],"%d",&sscan_temp1);
        sscan_cnt += sscanf(words[2],"%d",&sscan_temp2);
        sscan_cnt += sscanf(words[3],"%d",&sscan_temp3);
        sscan_cnt += sscanf(words[4],"%d",&sscan_temp4);
        sscan_cnt += sscanf(words[5],"%d",&sscan_temp5);
        sscan_cnt += sscanf(words[6],"%d",&sscan_temp6);
        sscan_cnt += sscanf(words[7],"%d",&sscan_temp7);
        sscan_cnt += sscanf(words[8],"%d",&sscan_temp8);

        /* 5V max (5000mV)  */
        if( sscan_temp1 > 5000) sscan_temp1 = 5000;
        if( sscan_temp2 > 5000) sscan_temp2 = 5000;
        if( sscan_temp3 > 5000) sscan_temp3 = 5000;
        if( sscan_temp4 > 5000) sscan_temp4 = 5000;
        if( sscan_temp5 > 5000) sscan_temp5 = 5000;
        if( sscan_temp6 > 5000) sscan_temp6 = 5000;
        if( sscan_temp7 > 5000) sscan_temp7 = 5000;
        if( sscan_temp8 > 5000) sscan_temp8 = 5000;

        /*  mV to DAC bit values (DAC bit full scale / mv), 0.819 for 12bitter, 13.107 for 16bitter */
        /*          12bit DAC is 4095, 16bit DAC is 65535 */
        DtoA_ch0_val = sscan_temp1 * 13.107;/* converted (mv 0 to 5000) to (12bit DAC bit val 0 to 4095)*/
        DtoA_ch1_val = sscan_temp2 * 13.107;    /* converted mv to DAC bit val */
        DtoA_ch2_val = sscan_temp3 * 13.107;    /* converted mv to DAC bit val */
        DtoA_ch3_val = sscan_temp4 * 13.107;    /* converted mv to DAC bit val */
        DtoA_ch4_val = sscan_temp5 * 13.107;    /* converted mv to DAC bit val */
        DtoA_ch5_val = sscan_temp6 * 13.107;    /* converted mv to DAC bit val */
        DtoA_ch6_val = sscan_temp7 * 13.107;    /* converted mv to DAC bit val */
        DtoA_ch7_val = sscan_temp8 * 13.107;    /* converted mv to DAC bit val */

        /* shift 4 bits for 12bit DAC, shift 8 bits for 16bit DAC */
        DtoA_array[0][1] = DtoA_ch0_val >> 8;   /* shift 8bits, high order is left */
        DtoA_array[0][2] = DtoA_ch0_val & 0x00ff;   /* clr high order bits, low order is left */

        DtoA_array[1][1] = DtoA_ch1_val >> 8;   /* shift 8bits, high order left */
        DtoA_array[1][2] = DtoA_ch1_val & 0x00ff;   /* clr high order bits, low order left */

        DtoA_array[2][1] = DtoA_ch2_val >> 8;   /* shift 8bits, high order left */
        DtoA_array[2][2] = DtoA_ch2_val & 0x00ff;   /* clr high order bits, low order left */

        DtoA_array[3][1] = DtoA_ch3_val >> 8;   /* shift 8bits, high order left */
        DtoA_array[3][2] = DtoA_ch3_val & 0x00ff;   /* clr high order bits, low order left */

        DtoA_array[4][1] = DtoA_ch4_val >> 8;   /* shift 8bits, high order left */
        DtoA_array[4][2] = DtoA_ch4_val & 0x00ff;   /* clr high order bits, low order left */

        DtoA_array[5][1] = DtoA_ch5_val >> 8;   /* shift 8bits, high order left */
        DtoA_array[5][2] = DtoA_ch5_val & 0x00ff;   /* clr high order bits, low order left */

        DtoA_array[6][1] = DtoA_ch6_val >> 8;   /* shift 8bits, high order left */
        DtoA_array[6][2] = DtoA_ch6_val & 0x00ff;   /* clr high order bits, low order left */

        DtoA_array[7][1] = DtoA_ch7_val >> 8;   /* shift 8bits, high order left */
        DtoA_array[7][2] = DtoA_ch7_val & 0x00ff;   /* clr high order bits, low order left */

        mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
        mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).
//      sent_data_calculation_from_analog();    // translate T1/T2 analog data to SENT format

       /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"dtoa_8ch command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"dtoa_8ch command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }


    case 20:    /* trig....get variables for dumperr...used to get all CIB's at once "F" address */
    {
        // for now, no response in any case
        trig_flag = 1;  // trig has been called from trig command..reset after dump

        trig();

        break;
    }

    case 21:    /* atod_print_all x(count) , printing happens in notification,  */
    {
        // for now, no response in any case

        strcpy(return_message,"atod_print_all x(count) command\r");

        sscan_cnt = 0;
        sscan_temp1 = 0;
                /* bug in sscan, Intel compiler */
        sscan_cnt += sscanf(words[1],"%d",&sscan_temp1);

//      AtoD_active_ch = 20;    /* invalid chX resets scan to start at 0ch */
        AtoD_print_count = sscan_temp1;
        AtoD_print_type = PRINT_ALL_CHANNELS;


        break;
    }

    case 22:    /* vref x   -  AtoD ticks for ref 2.5volt reading  */
    {
        sscan_cnt = 0;

        sscan_temp1 = 0;

        /* bug in sscan,  */
        sscan_cnt += sscanf(words[1],"%d",&sscan_temp1);

        ad_2_5_vref_val = sscan_temp1;
        ad_2_5_vref_flag = TRUE;

       /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"vref command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"vref command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 23:    /* dumpver command  */
    {
        /* my address? or all, if all dont print  */

      /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             sprintf(return_message,"%s  CIB#%s  \r",CIB_config_data.SOFTWARE_VERSION ,CIB_config_data.BOARD_ID);
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             sprintf(return_message,"%s  CIB#%s  \r",CIB_config_data.SOFTWARE_VERSION ,CIB_config_data.BOARD_ID);
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 24:    /* help command */
    {
        /* my address? or all, if all dont print  */

      /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(help_menu);
             }
         break;

         case WEB:
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(help_menu);
             }
         break;
         }

        break;
    }

    case 25:   /* winit (warm Init command) */
    {
        ign1_status = WARM;
        ign2_status = WARM;

       /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"winit command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"winit command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 26:    /* empty_26 */
    {
        strcpy(return_message,"empty_26 \r");

      /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"empty_26 command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"empty_26 command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 27:   /* relay_on  N2HET1[20]/Itrigger/Relay */
    {
        gioSetBit(hetPORT1, 20, 1); // EXT2-14  Itrigger/Relay (compatibility board) same as "relay on"...trigger to voltage stand to start pulse

     /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"relay_on command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"relay_on command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 28:   /* relay_off N2HET1[20]/Itrigger/Relay   */
    {
        gioSetBit(hetPORT1, 20, 0); // EXT2-14  Itrigger/Relay (compatibility board) same as "relay off"...trigger to voltage stand to end pulse

    /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"relay_off command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"relay_off command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 29:    /* empty_29 */
    {

    /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
         case CIB:
             strcpy(return_message,"empty_29 command\r");
             if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
             {
                transmit_str_485(return_message);
             }
         break;

         case WEB:
             strcpy(return_message,"empty_29 command\r");
             if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
             {
                 transmit_str_485(return_message);
             }
         break;
         }

        break;
    }

    case 30:        // "0>" prompt from Lantronix when in MONITOR MODE, what do you want me to do?
                    //   first "NC" =
                    //      second "GM" = get MAC address  example  00:20:4A:F8:72:1B
                    //      third "QU" = quit
                    //      set baud to 19200 and change to WEB MODE
    {
        switch(monitor_rec_index)
        {
        case 0:
//          system_msec_clock_temp = system_msec_clock + 600;   // wait 200
//          while(system_msec_clock < system_msec_clock_temp);

//          sciSend(sciREG1, 18, "next command = NC\r\n##");

            Monitor_delay_timer = system_msec_clock + 500;  // wait 200
            while(system_msec_clock < Monitor_delay_timer);
            monitor_rec_index = 1;      // bump for next Response from Lantronix
            sciSend(scilinREG, 3, "NC\r");

            break;

        case 1:
            memcpy(command_str_mirror, &command_str_mirror[3], 18); // delete "C\n\r from Lantastic reply and leaving "IP xxx.xxx.xxx.xxx ect
            command_str_mirror[18] = 0x00;  // truncate string after IP address
            strcpy( CIB_config_data.TCPIP, "YES "); // overwrite  Bootup string of "YES MONITOR_data_blank"
            strcat(CIB_config_data.TCPIP, command_str_mirror);  // add IP address to CIB_config_data.TCPIP

//          system_msec_clock_temp = system_msec_clock + 600;   // wait 200
//          while(system_msec_clock < system_msec_clock_temp);

//          sciSend(sciREG1, 18, "next command = GM\r\n##");

            Monitor_delay_timer = system_msec_clock + 500;  // wait 200
            while(system_msec_clock < Monitor_delay_timer);
            monitor_rec_index = 2;      // bump for next Response from Lantronix
            sciSend(scilinREG, 3, "GM\r");  //GM

            break;

        case 2:
            memcpy(command_str_mirror, &command_str_mirror[3], 17); // delete "M\n\r from Lantastic reply and leaving "IP xxx.xxx.xxx.xxx ect
            command_str_mirror[17] = 0x00;  // truncate string after MAC address
            strcat(CIB_config_data.TCPIP, " MAC "); // add "MAC" to CIB_config_data.TCPIP
            strcat(CIB_config_data.TCPIP, command_str_mirror);  // add MAC_address to CIB_config_data.TCPIP

//          system_msec_clock_temp = system_msec_clock + 600;   // wait 200
//          while(system_msec_clock < system_msec_clock_temp);

//          sciSend(sciREG1, 18, "next command = QU\r\n##");

            Monitor_delay_timer = system_msec_clock + 500;  // wait 200
            while(system_msec_clock < Monitor_delay_timer);

            monitor_rec_index = 3;      // bump for next Response from Lantronix
            sciSend(scilinREG, 3, "QU\r");

            break;

        case 3:
            monitor_rec_index = 4;      // bump done
            scilinREG->BRS = 10U;       //10U = 460800 baud //21U = 230400 //42U = 115200   // 259U = 19200 baudrate
            scilinREG_is_CIB_or_Monitor_or_WEB = WEB;

        // rev06
            sprintf(temp_return_message,"Switched scilinREG over to WEB Mode at 460800 baud scilinREG->BRS=%d\r\n",scilinREG->BRS);
            //sciSend(sciREG, 49, "Switched scilinREG over to WEB Mode at 460800 baud\r\n");
            sciSend(sciREG, strlen(temp_return_message),temp_return_message);
            // wait for (WEB Mode RESET and XXX time) for Xport to complete reset

            Monitor_delay_timer = system_msec_clock + 3000; // wait 3000mS for LAN bus to restart
            while(system_msec_clock < Monitor_delay_timer);

            sciSend(sciREG, 20,  "Starting Main Loop\r\n");


            break;

        }   // end of switch(monitor_rec_index)


        break;
    }

        case 31:    /* snap command, from RTS indicating it is sees B_CIB wanting to snap, and sending its IP as author, B_CIB counters with slot, IP and MAC address  */
                    /*  snap is complete, B_CIB will only accept "A" level commands from autherized source, flash LEDs for 3 seconds  */
        {
            SNAP_timeout_clock = system_msec_clock + 3000;      // set timout to 3 seconds into future

            SW1_is_snapping_snapped1_snapped2_reset_none = SNAPPED1;    // "SNAPPED1" is signal to notification to flash all LEDs 1,2,3,4 for 3 seconds for user to see
                                                                //  successful snap, moving to "SNAPPED2" indicates WEB personality and we can accept "A" level commands

            /* bug in sscan,  */
            sscan_cnt += sscanf(words[1],"%s",snap_authorization_str);  // the idea here is that we will use this data(RTS IP address) to match all incomming "A " level commands

//          sprintf(return_message,"YES slot# %s %s snapped_to_IP %s\r",board_id,&CIB_config_data.TCPIP[4],snap_authorization_str);

            sprintf(return_message,"YES slot# %s %s snapped_to_IP %s version %s\r",CIB_config_data.BOARD_ID,CIB_config_data.TCPIP +4,snap_authorization_str,CIB_config_data.SOFTWARE_VERSION);

            sciSend(scilinREG, strlen(return_message), return_message); // this is a TCP Response ,,report CIB info slot,IP address and MAC address to RTS(PC)

            system_msec_clock_temp = system_msec_clock + 500;   // wait 200
            while(system_msec_clock < system_msec_clock_temp);

            sciSend(sciREG, strlen(return_message), return_message);    // this is a TCP Response ,,report CIB info slot,IP address and MAC address


            // Update structure, adding snapping information
            sprintf(return_message,"%s snapped_to_IP %s version %s\r",CIB_config_data.TCPIP +4,snap_authorization_str,CIB_config_data.SOFTWARE_VERSION);
            strcpy(CIB_config_data.TCPIP, return_message);



            break;
        }

        case 32:    /* calibration LAB: cal_step1 = 0.0V */
        {
            temp_analog_config_status = CIB_analog_config;      // store user configuration

            CIB_analog_config = FULL;                           // forcing analog ISR to run all channels even if "BAIRBOARD" is selected
                                                                //      don't worry, if a BAIRBOARD is really installed, it will fail the calibration

            memcpy(&DtoA_array,&test_DtoA_load0,48);    // load DtoA values from constant
            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);  // load SPI buffer for xmit
            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).
            sent_data_calculation_from_analog();    // translate T1/T2 analog data to SENT format, do we need to set SENT for CAL?, probably don't care.

            system_msec_clock_temp = system_msec_clock + 1000;  // wait 1 sec, wait for DtoA's to stabilize
            while(system_msec_clock < system_msec_clock_temp);

            // Readback - D/A ch[0,1]
            // Readback - D/A ch[2,3]
            // Readback - D/A ch[4,5]
            // Readback - D/A ch[6,7]
            // Read of Product 5v, 2.5vRef
            // Read of vign voltage divider on B_CIB
            sprintf(return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d \r",\
                                adc1_Group1_mV[0],adc1_Group1_mV[1],\
                                adc1_Group1_mV[2],adc1_Group1_mV[3],\
                                adc1_Group1_mV[4],adc1_Group1_mV[5],\
                                adc1_Group1_mV[6],adc1_Group1_mV[7],\
                                adc1_Group1_mV[9],adc1_Group1_mV[11],\
                                dumperr_Tester1_vign);

            CIB_analog_config = temp_analog_config_status;      // restore user configuration

        /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
             switch(scilinREG_is_CIB_or_Monitor_or_WEB)
             {
             case CIB:
                 if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                 {
                    transmit_str_485(return_message);
                 }
             break;

             case WEB:
                 if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                 {
                     transmit_str_485(return_message);
                 }
             break;
             }

            break;
        }

        case 33:    /* calibration LAB: cal_step2 = 0.5V */
        {
            temp_analog_config_status = CIB_analog_config;      // store user configuration

            CIB_analog_config = FULL;                           // forcing analog ISR to run all channels even if "BAIRBOARD" is selected


            memcpy(&DtoA_array,&test_DtoA_load1,48);    // load DtoA values from constant
            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);  // load SPI buffer for xmit
            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).
            sent_data_calculation_from_analog();    // translate T1/T2 analog data to SENT format, do we need to set SENT for CAL?, probably don't care.

            system_msec_clock_temp = system_msec_clock + 1000;  // wait 1 sec, wait for DtoA's to stabilize
            while(system_msec_clock < system_msec_clock_temp);

            // Readback - D/A ch[0,1]
            // Readback - D/A ch[2,3]
            // Readback - D/A ch[4,5]
            // Readback - D/A ch[6,7]
            // Read of Product 5v, 2.5vRef
            // Read of vign voltage devider on B_CIB
            sprintf(return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d \r",\
                                adc1_Group1_mV[0],adc1_Group1_mV[1],\
                                adc1_Group1_mV[2],adc1_Group1_mV[3],\
                                adc1_Group1_mV[4],adc1_Group1_mV[5],\
                                adc1_Group1_mV[6],adc1_Group1_mV[7],\
                                adc1_Group1_mV[9],adc1_Group1_mV[11],\
                                dumperr_Tester1_vign);

            CIB_analog_config = temp_analog_config_status;      // restore user configuration

        /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
             switch(scilinREG_is_CIB_or_Monitor_or_WEB)
             {
             case CIB:
                 if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                 {
                    transmit_str_485(return_message);
                 }
             break;

             case WEB:
                 if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                 {
                     transmit_str_485(return_message);
                 }
             break;
             }

            break;
        }

        case 34:    /* calibration LAB: cal_step3 = 1.0V */
        {
            temp_analog_config_status = CIB_analog_config;      // store user configuration

            CIB_analog_config = FULL;                           // forcing analog ISR to run all channels even if "BAIRBOARD" is selected


            memcpy(&DtoA_array,&test_DtoA_load2,48);    // load DtoA values from constant
            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);  // load SPI buffer for xmit
            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).
            sent_data_calculation_from_analog();    // translate T1/T2 analog data to SENT format, do we need to set SENT for CAL?, probably don't care.


            system_msec_clock_temp = system_msec_clock + 1000;  // wait 1 sec, wait for DtoA's to stabilize
            while(system_msec_clock < system_msec_clock_temp);

            // Readback - D/A ch[0,1]
            // Readback - D/A ch[2,3]
            // Readback - D/A ch[4,5]
            // Readback - D/A ch[6,7]
            // Read of Product 5v, 2.5vRef
            // Read of vign voltage devider on B_CIB
            sprintf(return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d \r",\
                                adc1_Group1_mV[0],adc1_Group1_mV[1],\
                                adc1_Group1_mV[2],adc1_Group1_mV[3],\
                                adc1_Group1_mV[4],adc1_Group1_mV[5],\
                                adc1_Group1_mV[6],adc1_Group1_mV[7],\
                                adc1_Group1_mV[9],adc1_Group1_mV[11],\
                                dumperr_Tester1_vign);                              // Read of vign voltage devider on B_CIB

            CIB_analog_config = temp_analog_config_status;      // restore user configuration

        /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
             switch(scilinREG_is_CIB_or_Monitor_or_WEB)
             {
             case CIB:
                 if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                 {
                    transmit_str_485(return_message);
                 }
             break;

             case WEB:
                 if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                 {
                     transmit_str_485(return_message);
                 }
             break;
             }

            break;
        }

        case 35:    /* calibration LAB: cal_step4 = 2.0V */
        {
            temp_analog_config_status = CIB_analog_config;      // store user configuration

            CIB_analog_config = FULL;                           // forcing analog ISR to run all channels even if "BAIRBOARD" is selected


            memcpy(&DtoA_array,&test_DtoA_load4,48);    // load DtoA values from constant
            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);  // load SPI buffer for xmit
            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).
            sent_data_calculation_from_analog();    // translate T1/T2 analog data to SENT format, do we need to set SENT for CAL?, probably don't care.

            system_msec_clock_temp = system_msec_clock + 1000;  // wait 1 sec, wait for DtoA's to stabilize
            while(system_msec_clock < system_msec_clock_temp);

            // Readback - D/A ch[0,1]
            // Readback - D/A ch[2,3]
            // Readback - D/A ch[4,5]
            // Readback - D/A ch[6,7]
            // Read of Product 5v, 2.5vRef
            // Read of vign voltage devider on B_CIB
            sprintf(return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d \r",\
                                adc1_Group1_mV[0],adc1_Group1_mV[1],\
                                adc1_Group1_mV[2],adc1_Group1_mV[3],\
                                adc1_Group1_mV[4],adc1_Group1_mV[5],\
                                adc1_Group1_mV[6],adc1_Group1_mV[7],\
                                adc1_Group1_mV[9],adc1_Group1_mV[11],\
                                dumperr_Tester1_vign);                              // Read of vign voltage devider on B_CIB

            CIB_analog_config = temp_analog_config_status;      // restore user configuration

        /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
             switch(scilinREG_is_CIB_or_Monitor_or_WEB)
             {
             case CIB:
                 if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                 {
                    transmit_str_485(return_message);
                 }
             break;

             case WEB:
                 if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                 {
                     transmit_str_485(return_message);
                 }
             break;
             }

            break;
        }

        case 36:    /* calibration LAB: cal_step5 = 3.0V */
        {
            temp_analog_config_status = CIB_analog_config;      // store user configuration

            CIB_analog_config = FULL;                           // forcing analog ISR to run all channels even if "BAIRBOARD" is selected


            memcpy(&DtoA_array,&test_DtoA_load6,48);    // load DtoA values from constant
            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);  // load SPI buffer for xmit
            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).
            sent_data_calculation_from_analog();    // translate T1/T2 analog data to SENT format, do we need to set SENT for CAL?, probably don't care.

            system_msec_clock_temp = system_msec_clock + 1000;  // wait 1 sec, wait for DtoA's to stabilize
            while(system_msec_clock < system_msec_clock_temp);

            // Readback - D/A ch[0,1]
            // Readback - D/A ch[2,3]
            // Readback - D/A ch[4,5]
            // Readback - D/A ch[6,7]
            // Read of Product 5v, 2.5vRef
            // Read of vign voltage devider on B_CIB
            sprintf(return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d \r",\
                                adc1_Group1_mV[0],adc1_Group1_mV[1],\
                                adc1_Group1_mV[2],adc1_Group1_mV[3],\
                                adc1_Group1_mV[4],adc1_Group1_mV[5],\
                                adc1_Group1_mV[6],adc1_Group1_mV[7],\
                                adc1_Group1_mV[9],adc1_Group1_mV[11],\
                                dumperr_Tester1_vign);                              // Read of vign voltage devider on B_CIB

            CIB_analog_config = temp_analog_config_status;      // restore user configuration

        /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
             switch(scilinREG_is_CIB_or_Monitor_or_WEB)
             {
             case CIB:
                 if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                 {
                    transmit_str_485(return_message);
                 }
             break;

             case WEB:
                 if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                 {
                     transmit_str_485(return_message);
                 }
             break;
             }

            break;
        }

        case 37:    /* calibration LAB: cal_step6 = 4.0V */
        {
            temp_analog_config_status = CIB_analog_config;      // store user configuration

            CIB_analog_config = FULL;                           // forcing analog ISR to run all channels even if "BAIRBOARD" is selected


            memcpy(&DtoA_array,&test_DtoA_load8,48);    // load DtoA values from constant
            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);  // load SPI buffer for xmit
            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).
            sent_data_calculation_from_analog();    // translate T1/T2 analog data to SENT format, do we need to set SENT for CAL?, probably don't care.

            system_msec_clock_temp = system_msec_clock + 1000;  // wait 1 sec, wait for DtoA's to stabilize
            while(system_msec_clock < system_msec_clock_temp);

            // Readback - D/A ch[0,1]
            // Readback - D/A ch[2,3]
            // Readback - D/A ch[4,5]
            // Readback - D/A ch[6,7]
            // Read of Product 5v, 2.5vRef
            // Read of vign voltage devider on B_CIB
            sprintf(return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d \r",\
                                adc1_Group1_mV[0],adc1_Group1_mV[1],\
                                adc1_Group1_mV[2],adc1_Group1_mV[3],\
                                adc1_Group1_mV[4],adc1_Group1_mV[5],\
                                adc1_Group1_mV[6],adc1_Group1_mV[7],\
                                adc1_Group1_mV[9],adc1_Group1_mV[11],\
                                dumperr_Tester1_vign);                              // Read of vign voltage devider on B_CIB

            CIB_analog_config = temp_analog_config_status;      // restore user configuration

        /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
             switch(scilinREG_is_CIB_or_Monitor_or_WEB)
             {
             case CIB:
                 if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                 {
                    transmit_str_485(return_message);
                 }
             break;

             case WEB:
                 if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                 {
                     transmit_str_485(return_message);
                 }
             break;
             }

            break;
        }

        case 38:    /* calibration LAB: cal_step7 = 5.0V */
        {
            temp_analog_config_status = CIB_analog_config;      // store user configuration

            CIB_analog_config = FULL;                           // forcing analog ISR to run all channels even if "BAIRBOARD" is selected


            memcpy(&DtoA_array,&test_DtoA_load10,48);   // load DtoA values from constant
            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);  // load SPI buffer for xmit
            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).
            sent_data_calculation_from_analog();    // translate T1/T2 analog data to SENT format, do we need to set SENT for CAL?, probably don't care.

            system_msec_clock_temp = system_msec_clock + 1000;  // wait 1 sec, wait for DtoA's to stabilize
            while(system_msec_clock < system_msec_clock_temp);

            // Readback - D/A ch[0,1]
            // Readback - D/A ch[2,3]
            // Readback - D/A ch[4,5]
            // Readback - D/A ch[6,7]
            // Read of Product 5v, 2.5vRef
            // Read of vign voltage devider on B_CIB
            sprintf(return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d \r",\
                                adc1_Group1_mV[0],adc1_Group1_mV[1],\
                                adc1_Group1_mV[2],adc1_Group1_mV[3],\
                                adc1_Group1_mV[4],adc1_Group1_mV[5],\
                                adc1_Group1_mV[6],adc1_Group1_mV[7],\
                                adc1_Group1_mV[9],adc1_Group1_mV[11],\
                                dumperr_Tester1_vign);                              // Read of vign voltage devider on B_CIB

            CIB_analog_config = temp_analog_config_status;      // restore user configuration

        /*      // fix for RTS code wanting a reply from p_on or p_off or RTS will not operate normally*/
             switch(scilinREG_is_CIB_or_Monitor_or_WEB)
             {
             case CIB:
                 if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                 {
                    transmit_str_485(return_message);
                 }
             break;

             case WEB:
                 if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                 {
                     transmit_str_485(return_message);
                 }
             break;
             }

            break;
        }

        case 39:    /* p1_on, for ADAS ignition #1, start power mode on, normal sequence */
        {


            if(ign1_status != NORMAL)   // only perform init action if current state is ign_off  or warm init
    //      if(ign_on_flag != ON)   // only perform init action if current state is ign_off  or warm init

            {

                // On i2C sensor products hold off Response to SENT trigger until i2C has been initialized @ 135mS
                //  notifocation timer will reload HET registers to respond on next trigger
                switch (target_product)
                {
                case TARGET_T1XX:
                case TARGET_BYD_SA2FL:
                case TARGET_GWM_A0607:
                case TARGET_S550DIGITAL:
                case TARGET_FCA_ADAS:
                case TARGET_G2KCA_ADAS:
                case TARGET_SGMW_CN200:
                case TARGET_FORD_T3_T6:
                case TARGET_RENAULT_NISSAN:
                break;

                case TARGET_C1XX:
                case TARGET_CD391_ADAS:
                case TARGET_PSA_CMP:
                    hetRAM1->Instruction[0].Program  = 0x000dda00;  // causes BR01 to branch to end of program,skipping all SENT triggering and signal generation, 113mS later load to normal
                    hetRAM1->Instruction[0].Control  = 0x000dc000;  // causes BR01 to branch to end of program,skipping all SENT triggering and signal generation, 113mS later load to normal

            //       hetRAM1->Instruction[0].Program  = 0x0002ba00;  // causes BR01 to run HET code normally looking for triggers and creating SENT signals
            //       hetRAM1->Instruction[0].Control  = 0x00002220;  // causes BR01 to run HET code normally looking for triggers and creating SENT signals

            //      HET_msec_countdown_cnt = 113;   // turn on HET SENT signals (113mSec) just after i2C init has completed and just before next SENT trigger
                    HET_msec_countdown_cnt = 180;   // was 135mS, seeing FORD ADAS i2C starting init later, try 170mS,300mS

                    // turn on HET SENT signals (10 mS for testing)(115mS = 99.99%) (135mS greater than seen) just after i2C init has completed and just before next SENT trigger

                break;
                }


                LED_msec_clock = 0;     // reset LED clock to sync all CIB USER LED flashing

                switch (target_product)
                {
                case TARGET_T1XX:
                case TARGET_BYD_SA2FL:
                case TARGET_GWM_A0607:
                case TARGET_C1XX:
                case TARGET_9BXX:
                case TARGET_FCA_ADAS:
                case TARGET_CD391_ADAS:
                case TARGET_G2KCA_ADAS:
                case TARGET_SGMW_CN200:
                case TARGET_FORD_T3_T6:
                case TARGET_RENAULT_NISSAN:

                    gioSetBit(hetPORT1, 15, 1); /* turn on Product Ign1, Turn on first */
                break;

                case TARGET_PSA_CMP:
                    gioSetBit(hetPORT1, 14, 1); /* turn on Product Ign1, Turn on first (cable miswiring)*/
                break;
                }

//              gioSetBit(hetPORT1, 15, 1); /* turn on Product Ign1, Turn on first */
                gioSetBit(hetPORT1, 31, 1); /* turn on Product Ign, Turn on here, no buffer board in B_CIB system */

                ign1_status = WARM; // default to warm init >>> later (here) will change to NORMAL
                ign2_status = OFF;  // default to OFF

                system_msec_clock_temp = system_msec_clock + 100;   // wait 100 , wait for periodic messeges to get off
                while(system_msec_clock < system_msec_clock_temp);

                ucurr_flag = 0;     // this is the only time we want to push connect,TOC logic and TOC value, so CLEAR user current flag
                hcurr_flag = OFF;
                stop_T1T2switching = 1;  // stop switching for low current

                can1_request_index = 10000; // do nothing index - just connect, throw away Response, allows enable TOC, set TOC and request vars
                can2_request_index = 10000; // do nothing index - just connect, throw away Response, allows enable TOC, set TOC and request vars

                switch (target_product)
                {
                case TARGET_T1XX:
                case TARGET_BYD_SA2FL:
                case TARGET_C1XX:
                case TARGET_9BXX:

                    canTransmit(canREG1, CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;
                case TARGET_GWM_A0607:
                canTransmit(canREG1, GWM_A0607_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);  
                break;
                case TARGET_FCA_ADAS:
                    canTransmit(canREG1, FCA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;
                case TARGET_CD391_ADAS:
                    canTransmit(canREG1, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;
                case TARGET_G2KCA_ADAS:
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;
                case TARGET_PSA_CMP:
                    canTransmit(canREG1, PSA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;
                case TARGET_SGMW_CN200:
                    canTransmit(canREG1, CN200_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;
                case TARGET_FORD_T3_T6:
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;

                case TARGET_RENAULT_NISSAN:
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;

                }

                if(manufacturing_TOC == YES)
                {

                    system_msec_clock_temp = system_msec_clock + 150;   // wait 150 , wait for torque messeges to get off
                    while(system_msec_clock < system_msec_clock_temp);

                    // kick off for nexteer mode and start keep alive / tester message

                    tester_present_timer = 3000;  // set timer for 3 seconds
                    tester_present_enable_flag = 1; // enable tester present message

                    ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply and don't send another message.
                    ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                    switch (target_product)
                    {
                    case TARGET_T1XX:       //EA4 is different
                        canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    break;

                    case TARGET_BYD_SA2FL:       //EA4 is different
                        canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    break;

                    case TARGET_GWM_A0607:      //EA4 is different
                    canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    break;

                    case TARGET_G2KCA_ADAS:     //EA4 is different
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    break;

                    case TARGET_CD391_ADAS:
                    case TARGET_C1XX:
                    case TARGET_9BXX:
                        canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    break;
                    case TARGET_PSA_CMP:
                        canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                    break;

                    case TARGET_SGMW_CN200:
                        canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    break;
                    case TARGET_FORD_T3_T6:     //EA4 is different
                        canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    break;

                    case TARGET_RENAULT_NISSAN:
                        canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                    break;

                    }

                    // when running TOC, need to wait 200ms before initiating TOC command after XCP session request
                    system_msec_clock_temp = system_msec_clock + 200;   // wait 200
                    while(system_msec_clock < system_msec_clock_temp);

                }  // end if(manufacturing_TOC == YES)

            }  //  END if(ign1_status != ON(normal)  --  if(ign_on_flag != ON(normal)


            // switch torque direction, and start product up at 0.5nm or 0.0nm of torque, set ucurr_flag flag so main loop can process
            //      this function call to set torque _value_case_index works for both Digital sensors and TOC products
            switch (target_product)
            {
            case TARGET_T1XX:
            case TARGET_BYD_SA2FL:
            case TARGET_GWM_A0607:
            case TARGET_C1XX:
            case TARGET_9BXX:
            case TARGET_FCA_ADAS:
            case TARGET_G2KCA_ADAS:
            case TARGET_PSA_CMP:
            case TARGET_SGMW_CN200:
            case TARGET_RENAULT_NISSAN:

                 hcurr_change_direction_at_nm(0.5); // switch T1/T2 to 10% or 0.5nm

            break;
            case TARGET_CD391_ADAS:
            case TARGET_FORD_T3_T6:
                 hcurr_change_direction_at_nm(0.0); // switch T1/T2 to 0% or 0.0nm
            break;
            }
             ucurr_flag = 1;                // flag to main loop to process new torque values

            ign1_status = NORMAL;
            ign2_status = OFF;

    //      Engine_on_Signal = 1; // set to RUN mode


         // fix for RTS code wanting a reply from p_on or p_off or RTS code will not operate normally

         switch(scilinREG_is_CIB_or_Monitor_or_WEB)
         {
             case CIB:
                 strcpy(return_message,"p1_on command\r");
                 if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                 {
                    transmit_str_485(return_message);
                 }
             break;

             case WEB:
                 strcpy(return_message,"p1_on command\r");
                 if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                 {
                     transmit_str_485(return_message);
                 }
             break;
         }

            break;
        }

        case 40:    /* p2_on, for ADAS ignition #2, start power mode on, normal sequence */
        {


            if(ign2_status != NORMAL)   // only perform init action if current state is ign_off  or warm init
    //      if(ign_on_flag != ON)   // only perform init action if current state is ign_off  or warm init

            {

                // On i2C sensor products hold off Response to SENT trigger until i2C has been initialized @ 135mS
                //  notifocation timer will reload HET registers to respond on next trigger
                switch (target_product)
                {
                case TARGET_T1XX:
                case TARGET_BYD_SA2FL:
                case TARGET_GWM_A0607:
                case TARGET_S550DIGITAL:
                case TARGET_FCA_ADAS:
                case TARGET_G2KCA_ADAS:
                case TARGET_PSA_CMP:
                case TARGET_SGMW_CN200:
                case TARGET_FORD_T3_T6:
                case TARGET_RENAULT_NISSAN:

                break;

                case TARGET_C1XX:
                case TARGET_CD391_ADAS:
                    hetRAM1->Instruction[0].Program  = 0x000dda00;  // causes BR01 to branch to end of program,skipping all SENT triggering and signal generation, 113mS later load to normal
                    hetRAM1->Instruction[0].Control  = 0x000dc000;  // causes BR01 to branch to end of program,skipping all SENT triggering and signal generation, 113mS later load to normal

            //       hetRAM1->Instruction[0].Program  = 0x0002ba00;  // causes BR01 to run HET code normally looking for triggers and creating SENT signals
            //       hetRAM1->Instruction[0].Control  = 0x00002220;  // causes BR01 to run HET code normally looking for triggers and creating SENT signals

            //      HET_msec_countdown_cnt = 113;   // turn on HET SENT signals (113mSec) just after i2C init has completed and just before next SENT trigger
                    HET_msec_countdown_cnt = 180;   // was 135mS, seeing FORD ADAS i2C starting init later, try 170mS,300mS

                    // turn on HET SENT signals (10 mS for testing)(115mS = 99.99%) (135mS greater than seen) just after i2C init has completed and just before next SENT trigger

                break;
                }


                LED_msec_clock = 0;     // reset LED clock to sync all CIB USER LED flashing

                switch (target_product)
                {
                case TARGET_T1XX:
                case TARGET_BYD_SA2FL:
                case TARGET_GWM_A0607:
                case TARGET_C1XX:
                case TARGET_9BXX:
                case TARGET_FCA_ADAS:
                case TARGET_CD391_ADAS:
                case TARGET_PSA_CMP:
                case TARGET_G2KCA_ADAS:
                case TARGET_SGMW_CN200:
                case TARGET_FORD_T3_T6:
                case TARGET_RENAULT_NISSAN:

                    gioSetBit(hetPORT1, 14, 1); /* turn on Product Ign2, Turn on first */
                break;
//
//                    gioSetBit(hetPORT1, 15, 1); /* turn on Product Ign2, Turn on first */
//                break;
                }

//              gioSetBit(hetPORT1, 14, 1); /* turn on Product Ign2, Turn on first */
                gioSetBit(hetPORT1, 31, 1); /* turn on Product Ign, Turn on here, no buffer board in B_CIB system */

                ign1_status = OFF;  // default to OFF
                ign2_status = WARM; // default to warm init >>> later (here) will change to NORMAL

    //          Engine_on_Signal = 0;     // default to warm init >>> E_p_on will change to RUN
    //          ign_on_flag = TRUE;     /* flag to prevent dumperr invalid data dump while ign off */
    //          speed_flag = 0; /* ensure periodic CAN speed(0kpH, max torque) message is sent */

                system_msec_clock_temp = system_msec_clock + 100;   // wait 100 , wait for periodic messeges to get off
                while(system_msec_clock < system_msec_clock_temp);

                ucurr_flag = 0;     // this is the only time we want to push connect,TOC logic and TOC value, so CLEAR user current flag
                hcurr_flag = OFF;
                stop_T1T2switching = 1;  // stop switching for low current

                can1_request_index = 10000; // do nothing index - just connect, throw away Response, allows enable TOC, set TOC and request vars
                can2_request_index = 10000; // do nothing index - just connect, throw away Response, allows enable TOC, set TOC and request vars

                switch (target_product)
                {
                case TARGET_T1XX:
                case TARGET_BYD_SA2FL:
                case TARGET_GWM_A0607:
                case TARGET_C1XX:
                case TARGET_9BXX:
                case TARGET_PSA_CMP:
                case TARGET_SGMW_CN200:
                case TARGET_RENAULT_NISSAN:

                break;
                case TARGET_FCA_ADAS:
                    canTransmit(canREG2, FCA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;
                case TARGET_CD391_ADAS:
                    canTransmit(canREG2, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;
                case TARGET_G2KCA_ADAS:
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;
                case TARGET_FORD_T3_T6:
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
                break;
                }

                if(manufacturing_TOC == YES)
                {

                    system_msec_clock_temp = system_msec_clock + 150;   // wait 150 , wait for torque messeges to get off
                    while(system_msec_clock < system_msec_clock_temp);

                    // kick off for nexteer mode and start keep alive / tester message

                    tester_present_timer = 3000;  // set timer for 3 seconds
                    tester_present_enable_flag = 1; // enable tester present message

                    ECU2_XCP_reply_index = 20; // Do nothing index- just receive reply and don't send another message.
                    ECU2_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                    switch (target_product)
                    {
                    case TARGET_T1XX:
                    case TARGET_BYD_SA2FL:
                    case TARGET_GWM_A0607:
                    case TARGET_PSA_CMP:
                    case TARGET_SGMW_CN200:
                    case TARGET_RENAULT_NISSAN:

                    break;

                    case TARGET_G2KCA_ADAS:     //EA4 is different
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    break;

                    case TARGET_CD391_ADAS:
                    case TARGET_C1XX:
                    case TARGET_9BXX:
                        canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    break;
                    case TARGET_FORD_T3_T6:     //EA4 is different
                        canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
                    break;

                    }

                    // when running TOC, need to wait 200ms before initiating TOC command after XCP session request
                    system_msec_clock_temp = system_msec_clock + 200;   // wait 200
                    while(system_msec_clock < system_msec_clock_temp);

                }  // end if(manufacturing_TOC == YES)

            }  //  END if(ign1_status != ON(normal)  --  if(ign_on_flag != ON(normal)


            // switch torque direction, and start product up at 0.5nm or 0.0nm of torque, set ucurr_flag flag so main loop can process
            //      this function call to set torque _value_case_index works for both Digital sensors and TOC products
            switch (target_product)
            {
            case TARGET_T1XX:
            case TARGET_BYD_SA2FL:
            case TARGET_GWM_A0607:
            case TARGET_C1XX:
            case TARGET_9BXX:
            case TARGET_FCA_ADAS:
            case TARGET_G2KCA_ADAS:
            case TARGET_PSA_CMP:
            case TARGET_SGMW_CN200:
            case TARGET_RENAULT_NISSAN:

                 hcurr_change_direction_at_nm(0.5); // switch T1/T2 to 10% or 0.5nm

            break;
            case TARGET_CD391_ADAS:
            case TARGET_FORD_T3_T6:
                 hcurr_change_direction_at_nm(0.0); // switch T1/T2 to 0% or 0.0nm
            break;
            }
             ucurr_flag = 1;                // flag to main loop to process new torque values

            ign1_status = OFF;
            ign2_status = NORMAL;

    //      Engine_on_Signal = 1; // set to RUN mode


            // fix for RTS code wanting a reply from p_on or p_off or RTS code will not operate normally

            switch(scilinREG_is_CIB_or_Monitor_or_WEB)
            {
                case CIB:
                    strcpy(return_message,"p2_on command\r");
                    if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                    {
                       transmit_str_485(return_message);
                    }
                break;

                case WEB:
                    strcpy(return_message,"p2_on command\r");
                    if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                    {
                        transmit_str_485(return_message);
                    }
                break;
            }

            break;
        }

        case 41:    /* ign_on , used for debug or special product programming */
        {
            gioSetBit(hetPORT1, 14, 1); /* turn on Product Ign1, Turn on first */
            gioSetBit(hetPORT1, 15, 1); /* turn on Product Ign2, Turn on first */
            gioSetBit(hetPORT1, 31, 1); /* turn on Product Ign, Turn on here, feads Ign1 and Ign2, no buffer board in B_CIB system */

            // fix for RTS code wanting a reply from p_on or p_off or RTS code will not operate normally

            switch(scilinREG_is_CIB_or_Monitor_or_WEB)
            {
                case CIB:
                    strcpy(return_message,"ign_on command\r");
                    if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                    {
                       transmit_str_485(return_message);
                    }
                break;

                case WEB:
                    strcpy(return_message,"ign_on command\r");
                    if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                    {
                        transmit_str_485(return_message);
                    }
                break;
            }

            break;
        }

        case 42:    /* get_sys_state, used for flexray debug instead of dump_err */
        {
            ECU1_XCP_reply_index = 11;

            transmitFlexray(MFG_TX_nexteer_session_MSG, MFG_TX,3);

            system_msec_clock_temp = system_msec_clock + 250;   // set time out to 250mS
            while((ECU1_XCP_reply_index != 13) && (system_msec_clock < system_msec_clock_temp));

            sprintf(return_message,"MFG Sys State = %d\r",system_state_MFG);

           switch(scilinREG_is_CIB_or_Monitor_or_WEB)
            {
                case CIB:
                    if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                    {
                       transmit_str_485(return_message);
                    }
                break;

                case WEB:
                    if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                    {
                        transmit_str_485(return_message);
                    }
                break;
            }

            break;
        }

        case 43: /* set_header_variables */
        {
            // Not in use Yet

              //1) Send response
              //2) Set flag so next received bytes up to \r are stored in read_variables_buf (handled in variable_input.c and notification.c)
              //3) Labview will send string...
              //4) After \r received, parse_variable_input() is called

              //if(debug_flag3 == ON)
              //{
              //  parse_variable_input();
              //  if(comm_is_CAN_or_FRAY == FRAY)
              //  {
                      //init_variable_input_fray();
              //  }
              //  sprintf(return_message,"set_header_variables command,%d\r",comm_is_CAN_or_FRAY);
              //}
              //else
              //{
            read_variables_flag = 1; //flag in scinotification to indicate next string sent is variable information

            strcpy(return_message,"set_header_variables command\r");

              switch(scilinREG_is_CIB_or_Monitor_or_WEB)
              {
                  case CIB:
                      if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                      {
                         transmit_str_485(return_message);
                      }
                  break;

                  case WEB:
                      if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                      {
                          transmit_str_485(return_message);
                      }
                  break;
              }

              //}
              break;
        }

        case 44: /* get_header_variables */
        {
            switch (target_product)
                   {
                        case TARGET_BMW_UKL:
                            {
                                // rev06
                                if(number_of_DAQ_variables > 0)
                                {
                                    //send daq_header,x0,x1,x2...\r string for "header file" logging info.
                                    sprintf(return_message,"daq_header,%s",variable_info[0].name);
                                    int jj;
                                    for(jj=1;jj<number_of_DAQ_variables;jj++)
                                    {
                                        sprintf(temp_return_message,",%s",variable_info[jj].name);
                                        strcat(return_message,temp_return_message);
                                    }
                                    strcat(return_message,"\r");

                                    //send mts_data,y0,y1,y2...\r string for "header file" logging info.
                                    if(MTS_available_flag == 1)
                                    {
                                        // rev07
                                        //Just gonna build the string we will use for L02 since Don has already defined the variables. Most may carry over for MTS applications.
                                        strcpy(temp_return_message,
                                               "mts_header,MTS_running_flag,MTS_Store_DAQ_Data_Mode_HEX_Byte,MTS_Vehicle_Speed_flt,MTS_System_State_HEX_Byte,MTS_Angle_Cmd_fp_in,MTS_Torque_Cmd_fp_in,MTS_Bus_Fault_State_HEX_Byte\r");

                                    }

                                    strcat(return_message, temp_return_message);

                                    strcpy(temp_return_message,
                                           "ntc_header,ntc1,ntc2,ntc3,ntc3,ntc4,ntc5,ntc6,ntc7,ntc8,ntc9,ntc10,ntc11,ntc12,ntc13,ntc14,ntc15\r");

                                    strcat(return_message, temp_return_message);

                                    strcpy(temp_return_message,
                                           "cib_header,system_msec_clock,ign1_status,CIB_address,IP_address\r");

                                    strcat(return_message, temp_return_message);

                                    switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                                    {
                                        case CIB:
                                            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                                            {
                                                transmit_str_485(return_message);
                                            }
                                            break;

                                        case WEB:
                                            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                                            {
                                                transmit_str_485(return_message);
                                            }
                                            break;
                                    }
                                }

                                break;
                            }
                        case TARGET_GWM_A0607:
                        {
                            // rev06

                            //send daq_header,x0,x1,x2...\r string for "header file" logging info.
                            sprintf(temp_return_message,"");
                            sprintf(return_message,"");

                            strcpy(temp_return_message,
                                   "CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,fault1_cnt,fault2_cnt,trig_flag,0,N/A,1,can1_sys_state_warm_init,2,can1_request_index:dump_cnt:CIB_reset_flag:ign1_status,3,dumperr_Tester1_vign,");
                            strcat(return_message,temp_return_message);

                            strcpy(temp_return_message,
                                   "4,dumperr_Product1_3volt,5,dumperr_Product1_5volt,6,value_sent5_ChA_T1_cnt,7,value_sent6_ChA_T2_cnt,");
                            strcat(return_message,temp_return_message);

                            strcpy(temp_return_message,
                                   "8,value_sent7_ChB_T1_cnt,9,value_sent8_ChB_T2_cnt,10,value_sent1_Adr0_ChA0_Pos_cnt,11,value_sent2_Adr0_ChB0_Pos_cnt,");
                            strcat(return_message,temp_return_message);

                            strcpy(temp_return_message,
                                   "12,value_sent3_Adr1_ChA1_Pos_cnt,13,value_sent4_Adr1_ChB1_Pos_cnt,14,can_GWM_A0607_SystemState_byt,");
                            strcat(return_message,temp_return_message);

                            strcpy(temp_return_message,
                                   "15,can_GWM_A0607_MotCurrQax_fp,16,can_GWM_A0607_HwTq0Meas_HwTq4_fp,17,can_GWM_A0607_HwTq1Meas_HwTq5_fp,18,can_GWM_A0607_MotHwPosn_fp,19,can_GWM_A0607_BattVltg_fp,20,can_GWM_A0607_MotTq_fp,21,can_GWM_A0607_HwTrq_fp,");
                            strcat(return_message,temp_return_message);

                            strcpy(temp_return_message,
                                   "22,can_GWM_A0607_MotMagTestim_fp,23,can_GWM_A0607_ECUTFilt_fp,24,N/A,25,N/A,26,N/A,27,N/A,28,N/A,29,N/A,");
                            strcat(return_message,temp_return_message);

                            strcpy(temp_return_message,
                                   "30,N/A,31,N/A,32,N/A,33,N/A,34,N/A,35,N/A,36,N/A,37,N/A,38,N/A,");
                            strcat(return_message,temp_return_message);

                            strcpy(temp_return_message,
                                   "39,N/A,40,N/A,41,can_GWM_A0607_MotCurrQax1_fp,42,can_GWM_A0607_MotCurrQax2_fp,43,can_GWM_A0607_MotCurrQax3_fp,44,can_GWM_A0607_HwTqArbn_HwTq1_fp,45,can_GWM_A0607_HwTqArbn_HwTq2_fp,46,can_GWM_A0607_HwTqArbn_HwTq3_fp,");
                            strcat(return_message,temp_return_message);

                            strcpy(temp_return_message,
                                   "47,DTC1,48,DTC2,49,DTC3,50,DTC4,51,DTC5,52,DTC6,53,DTC7,54,DTC8,55,DTC9,56,DTC10,57,DTC11,58,DTC12,59,DTC13,60,DTC14,61,DTC15\r");

                            strcat(return_message, temp_return_message);

                            switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                                {
                                    case CIB:
                                        if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                                            {
                                                transmit_str_485(return_message);
                                            }
                                        break;

                                    case WEB:
                                        if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                                            {
                                                transmit_str_485(return_message);
                                            }
                                        break;
                                }


                            break;
                        }
                   }
            break;
        }

        case 45: /* start_daq_mode #daq/xcp_fast_rate #msperiod */
        {
            /*Command: start_daq_mode
             * 1) Check if words[1] = daq or xcp_fast_rate
             * 2) Check if #msperiod is < limits for daq and xcp_fast_rate, send error message if below limit
             * 3) Set flags to begin appropriate modes
             *      a) If daq mode, check if CAN or FRAY, kick off comms for appropriate format
             *      b) If xcp_fast_rate mode, check if CAN or FRAY, set dumperr flags to do nothing values
             * 4) Send response
             *
             */
            Set_DAQ_List_mode_DAQ_rate = atoi(words[2]); //re-use Set_DAQ_List_mode_DAQ_rate variable to check if DAQ mode limit is OK
            XCP_fast_rate_period = atoi(words[2]);      //re-use XCP_fast_rate_period variable to check if DAQ mode limit is OK
                                                        //use atoi() = ascii to integer
            extern unsigned int daq_period_limit;
            extern unsigned int xcp_fast_rate_period_limit;
            extern unsigned int DAQ_slow_or_standard;

                if((strcmp(words[1],"daq") == 0) || (DAQ_slow_or_standard == 1))
                {
                    if(Set_DAQ_List_mode_DAQ_rate <= daq_period_limit) //code to set some limit in the future, return error if not reaching limit.
                    {
                        sprintf(return_message,"Error, period is below limit of %d,%s,%s\r",daq_period_limit,words[1],words[2]);
                    }
                    else
                    {
                        DAQ_mode_on_off = ON;
                        DAQ_mode_step_cntr = 2000;
                        XCP_fast_rate_active_flag = OFF;

                        if (comm_is_CAN_or_FRAY == CAN)
                        {
                            init_DAQ_mode_CAN();
                            canTransmit(canREG1,CAN_XCP_DAQ_TX, (uint8 *) ccp_request_connect);
                        }
                        else if (comm_is_CAN_or_FRAY == FRAY)
                        {
                            init_DAQ_mode_fray();
                            transmitFlexray(XCP_TX_request_connect_MSG,XCP_TX, 2);
                        }
                        sprintf(return_message,"start_daq_mode command,%s,%s\r",words[1],words[2]);
                    }
                }
                else if((strcmp(words[1],"xcp_fast_rate") == 0) || (DAQ_slow_or_standard == 0))
                {
                    if(XCP_fast_rate_period <= xcp_fast_rate_period_limit) //code to set some limit in the future, return error if not reaching limit.
                    {
                        sprintf(return_message,"Error, period is below limit of %d,%s,%s\r",xcp_fast_rate_period_limit,words[1],words[2]);
                    }
                    else
                    {
                        init_XCP_fast_rate();

                        if (comm_is_CAN_or_FRAY == CAN)
                        {
                            ECU1_XCP_reply_index = 10000;  // do nothing case for CAN DAQ interrupt sequence
                            ECU2_XCP_reply_index = 10000;  // do nothing case for CAN DAQ interrupt sequence
                        }
                        else if (comm_is_CAN_or_FRAY == FRAY)
                        {
                            fray_request_index = 100000; // do nothing case for FRAY DAQ interrupt sequence
                        }

                        DAQ_mode_on_off = OFF;
                        DAQ_mode_step_cntr = 10000; //do nothing case
                        XCP_fast_rate_active_flag = ON;

                        sprintf(return_message,"start_daq_mode command,%s,%s\r",words[1],words[2]);
                    }
                }

                switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                {
                    case CIB:
                        if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                        {
                           transmit_str_485(return_message);
                        }
                    break;

                    case WEB:
                        if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                        {
                            transmit_str_485(return_message);
                        }
                    break;
                }

            break;
        }

        case 46: /* stop_daq_mode */
        {
                 XCP_fast_rate_active_flag = OFF;
                 DAQ_mode_on_off = OFF;
                 DAQ_mode_step_cntr = 10000; //do nothing case
                 NTC_get_flag = OFF;

                 if (comm_is_CAN_or_FRAY == CAN)
                 {
                     canTransmit(canREG1,CAN_XCP_DAQ_TX, (uint8 *) XCP_Stop_all_selcted_DAQs_CAN);
                 }
                 else if (comm_is_CAN_or_FRAY == FRAY)
                 {
                     transmitFlexray(XCP_Stop_all_selcted_DAQs_fray,XCP_TX, 2);
                 }

                 strcpy(return_message,"stop_daq_mode command\r");

                 switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                 {
                     case CIB:
                         if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                         {
                            transmit_str_485(return_message);
                         }
                     break;

                     case WEB:
                         if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                         {
                             transmit_str_485(return_message);
                         }
                     break;
                 }
             break;
        }

        case 47: /* get_daq_mode */
        {
                   if(XCP_fast_rate_active_flag == YES)
                   {
                        sprintf(return_message,"get_daq_mode command,%s,%d\r","xcp_fast_rate",XCP_fast_rate_period);
                   }
                   else if(DAQ_mode_on_off == ON)
                   {
                        sprintf(return_message,"get_daq_mode command,%s,%d\r","daq",Set_DAQ_List_mode_DAQ_rate);
                   }
                   else
                   {
                       strcpy(return_message,"Error no DAQ modes active\r");
                   }

                   switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                   {
                       case CIB:
                           if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                           {
                              transmit_str_485(return_message);
                           }
                       break;

                       case WEB:
                           if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                           {
                               transmit_str_485(return_message);
                           }
                       break;
                   }

               break;
        }

        case 48: /* set_config */
               //1) Send response with hex switch setting
               //2) Set flag so next received bytes up to \r are stored in read_variables_buf (handled in variable_input.c and notification.c)
               //3) Labview will send string...
               //4) After \r received, parse_config_input() is called
        {
                   sprintf(return_message,"%s\r",CIB_config_data.BOARD_ID[0]);

                   read_variables_flag = 1; //flag in scinotification to indicate next string sent is variable information

                   switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                   {
                       case CIB:
                           if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                           {
                              transmit_str_485(return_message);
                           }
                       break;

                       case WEB:
                           if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                           {
                               transmit_str_485(return_message);
                           }
                       break;
                   }
                   system_msec_clock_temp = system_msec_clock + 3000;
                   while((read_variables_flag != 0) && (system_msec_clock < system_msec_clock_temp));

                   //need to send a response
                   if(read_variables_flag == 0)
                   {
                       strcpy(return_message,"true\r");

                       switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                       {
                           case CIB:
                               if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                               {
                                  transmit_str_485(return_message);
                               }
                           break;

                           case WEB:
                               if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                               {
                                   transmit_str_485(return_message);
                               }
                           break;
                       }
                   }
                   else
                   {
                       read_variables_flag = 0;
                   }

               break;
        }

        case 49: /* get_config */
        {
            //will use FEE here eventually. For now, stored_variables are copied just in RAM after being received, before parsing

                get_config();

            break;
        }

        case 50: /* enable_data_stream */
        {
            if(enable_data_stream_flag != ON)
            {
                strcpy(return_message,"enabled\r");

                switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                {
                    case CIB:
                        if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                        {
                           transmit_str_485(return_message);
                        }
                    break;

                    case WEB:
                        if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                        {
                            transmit_str_485(return_message);
                        }
                    break;
                }
                //wait for return string to finish before potentially kicking off DAQ mode. Potential for comm overwrite.
                while((scilinREG->FLR & TX_EMPTY) == 0x800);
                while((scilinREG->FLR & TX_EMPTY) != 0x800);

                enable_data_stream_flag = ON;

                //NOTE: Currently possible to start daq mode with no valid variables/addresses if defaults in main() are removed.
                if(ign1_status > 0) //if config is set up while ignition is ON
                {
                    extern unsigned int DAQ_slow_or_standard;
                    if(DAQ_slow_or_standard == 1)
                    {
                        call_start_daq_after_this_command_flag = YES; //utilize this flag to call start_daq
                    }
                    else if(DAQ_slow_or_standard == 0)
                    {

                    }

                    if(NTC_get_period >= 1000)
                    {
                        NTC_get_flag = ON;
                    }
                }
            }
            else
            {
                strcpy(return_message,"already enabled\r");

                switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                {
                    case CIB:
                        if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                        {
                           transmit_str_485(return_message);
                        }
                    break;

                    case WEB:
                        if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                        {
                            transmit_str_485(return_message);
                        }
                    break;
                }
            }

            break;
        }

        case 51: /* disable_data_stream */
        {
            enable_data_stream_flag = OFF;

            strcpy(return_message,"disabled\r");

            switch(scilinREG_is_CIB_or_Monitor_or_WEB)
            {
                case CIB:
                    if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                    {
                       transmit_str_485(return_message);
                    }
                break;

                case WEB:
                    if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                    {
                        transmit_str_485(return_message);
                    }
                break;
            }

            /* Stop DAQ mode */
            XCP_fast_rate_active_flag = OFF;
            DAQ_mode_on_off = OFF;
            DAQ_mode_step_cntr = 10000; //do nothing case
            NTC_get_flag = OFF;

            if (comm_is_CAN_or_FRAY == CAN)
            {
                canTransmit(canREG1,CAN_XCP_DAQ_TX, (uint8 *) XCP_Stop_all_selcted_DAQs_CAN);
            }
            else if (comm_is_CAN_or_FRAY == FRAY)
            {
                transmitFlexray(XCP_Stop_all_selcted_DAQs_fray,XCP_TX, 2);
            }

            break;
        }

        case 52: /* start_ntc_mode #msperiod*/
        {
                NTC_get_period = atoi(words[1]);

                NTC_get_flag = 1;

                strcpy(return_message,"start_ntc_mode command\r");

                switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                {
                    case CIB:
                        if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                        {
                           transmit_str_485(return_message);
                        }
                    break;

                    case WEB:
                        if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                        {
                            transmit_str_485(return_message);
                        }
                    break;
                }

            break;
        }

        case 53: /* stop_ntc_mode */
        {
                NTC_get_flag = 0;

                strcpy(return_message,"stop_ntc_mode command\r");

                switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                {
                    case CIB:
                        if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                        {
                           transmit_str_485(return_message);
                        }
                    break;

                    case WEB:
                        if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                        {
                            transmit_str_485(return_message);
                        }
                    break;
                }

            break;
        }

        case 54: /* get_product_software */
        {

                ECU1_XCP_reply_index = 21;
                transmitFlexray(MFG_TX_nexteer_session_MSG, MFG_TX,3);

                system_msec_clock_temp = system_msec_clock + 500;   // set time out to 250mS
                while((ECU1_XCP_reply_index != 24) && (system_msec_clock < system_msec_clock_temp));

                sprintf(return_message,"%s,%s\r",software_version_MFG,software_rev_MFG);

                switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                {
                    case CIB:
                        if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                        {
                           transmit_str_485(return_message);
                        }
                    break;

                    case WEB:
                        if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                        {
                            transmit_str_485(return_message);
                        }
                    break;
                }

            break;
        }

        case 55:    /* empty_55 */
        {
            strcpy(return_message,"empty_55\r");

            switch(scilinREG_is_CIB_or_Monitor_or_WEB)
            {
                case CIB:
                    if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                    {
                       transmit_str_485(return_message);
                    }
                break;

                case WEB:
                    if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                    {
                        transmit_str_485(return_message);
                    }
                break;
            }

            break;
        }

    case 56:    /* cal command */
    {
        switch (target_product)
        {


        case TARGET_T1XX:
        {
//  T 1 X X   F U N C T I O N A L S ------------------------------

        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

// ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

// -------------------------------------------      ign1_status = WARM;
//      Engine_on_Signal = 0;   // put product in warm init No current output
        ign1_status = WARM;

        system_msec_clock_temp = system_msec_clock + 7000;  // wait 7 Sec, wait for temp sensor to acclimate
        while(system_msec_clock < system_msec_clock_temp);


// ------------------------------------------------------------- Step 2 - Clr DTCs \/
        // ************ CLEAR DTC's ******************

        tester_present_timer = 3000;  // set timer for 3 seconds

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);


        ECU1_XCP_reply_index = 1;

        ECU1_clear_DTCs_flag = 1; // set flag for ISR


        canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        ECU1_XCP_reply_index = 0;
        ECU1_clear_DTCs_flag = 0; // done...clr flag for ISR

        // ************ END clear DTC's ******************


// ------------------------------------------------------------- Step 3 - Request/store one time perimetrics \/
        // set up torque value, not going back to main so initiate all steps here

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

// if we were to use sent_data_calculation_from_torque() call funct with torque as parameter   // zero nm torque
//  OR
//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
//  OR
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message


        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != T1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

// New B-CIB using floats for storage and printing
        cal_T1XX_BattVltg_fp = can_T1XX_BattVltg_fp;                    //  1   Batt Volt
        cal_T1XX_BattVltgSwd1_fp = can_T1XX_BattVltgSwd1_fp;            //  2   Sensor 5Volt
        cal_T1XX_BattVltgSwd2_fp = can_T1XX_BattVltgSwd2_fp;            //  3   Sensor 3Volt
        cal_T1XX_EcuTFild_fp = can_T1XX_EcuTFild_fp;                    //  4   Prod Temp
        cal_T1XX_HwTqArbn_HwTq_fp = can_T1XX_MotWidgT_fp;               //  5   motor winding temp
        cal_T1XX_HwTqArbn_HwTqChA_fp = can_T1XX_HwTqArbn_HwTqChA_fp;    //  6   channel a trq
        cal_T1XX_HwTqArbn_HwTqChB_fp = can_T1XX_HwTqArbn_HwTqChB_fp;    //  7   channel b trq
        cal_T1XX_HwTqArbn_HwTq_fp = can_T1XX_HwTqArbn_HwTq_fp;      //  8   HW Tq total
        cal_T1XX_HwTq0Meas_HwTq0_fp = can_T1XX_HwTq0Meas_HwTq0_fp;  //  9   HwTq 0
        cal_T1XX_HwTq1Meas_HwTq1_fp = can_T1XX_HwTq1Meas_HwTq1_fp;  //  10   HwTq 1
        cal_T1XX_HwTq2Meas_HwTq2_fp = can_T1XX_HwTq2Meas_HwTq2_fp;  //  11   HwTq 2
        cal_T1XX_HwTq3Meas_HwTq3_fp = can_T1XX_HwTq3Meas_HwTq3_fp;  //  12   HwTq 3
        cal_T1XX_HwAgArbn_HwAg_fp = can_T1XX_HwAgArbn_HwAg_fp;      //  13   Handwheel Angle
        cal_T1XX_HwAg0_fp = can_T1XX_HwAg0_fp;                      //  14   10 tooth
        cal_T1XX_HwAg1_fp = can_T1XX_HwAg1_fp;                      //  15   11 tooth
        cal_T1XX_MotTq_fp = can_T1XX_MotTq_fp;                      //  16   Motor Torque
        cal_T1XX_MotCurrQax_fp = can_T1XX_MotCurrQax_fp;                //  17   Motor Current Measurement

// ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perimetrics -- sent_data_array_pos_0nm \r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        system_msec_clock_temp = system_msec_clock + 500;   // wait 500  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);



//// Old CIB using hex strings for floats
//      strcpy(cal_BattVltg_str,can_BattVltg_str);                  //  16
//      strcpy(cal_BattVltgSwd1_str,can_BattVltgSwd1_str);          //  17
//      strcpy(cal_BattVltgSwd2_str,can_BattVltgSwd2_str);          //  18
//      strcpy(cal_EcuTFild_str,can_EcuTFild_str);                  //  7
//      strcpy(cal_HwTqArbn_HwTq_str,can_HwTqArbn_HwTq_str);        //  11
//      strcpy(cal_HwTqArbn_HwTqChA_str,can_HwTqArbn_HwTqChA_str);  //  13
//      strcpy(cal_HwTqArbn_HwTqChB_str,can_HwTqArbn_HwTqChB_str);  //  14
//      cal_MotTqWhl_cnt = can_MotTqWhl_cnt;                        //  12
//      strcpy(cal_HwTq0Meas_HwTq0_str,can_HwTq0Meas_HwTq0_str);    //  3
//      strcpy(cal_HwTq0Meas_HwTq1_str,can_HwTq0Meas_HwTq1_str);    //  4
//      strcpy(cal_HwTq0Meas_HwTq2_str,can_HwTq0Meas_HwTq2_str);    //  5
//      strcpy(cal_HwTq0Meas_HwTq3_str,can_HwTq0Meas_HwTq3_str);    //  6
//      strcpy(cal_HwAgArbn_HwAg_str,can_HwAgArbn_HwAg_str);        //  8
//      strcpy(cal_HwAg0_str,can_HwAg0_str);                        //  9
//      strcpy(cal_HwAg1_str,can_HwAg1_str);                        //  10
//      cal_MotTq_cnt = can_MotTq_cnt;                              //  27
//      strcpy(cal_MotCurrQax_str,can_MotCurrQax_str);              //  2
//

// ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
      // 0.10nm torque in positive direction for low value functional.

        ign1_status = NORMAL;
//      Engine_on_Signal = 1;   // put in run mode to output current.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm);
        torque_value_case_index = pos_p1nm;   // pos .1nm torque
        sent_data_calculation_from_table(sent_data_array_pos_p1nm); // calc and stuff edge times into sent_edge_event_time[][]

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);


        cal_T1XX_MotCurrQax_low_pos_fp = 0.0;
        cal_T1XX_HwTqArbn_HwTq_low_pos_fp = 0.0;
        cal_T1XX_MotTq_low_pos_fp = 0.0;

for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != T1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

////        strcpy(cal_MotCurrQax_low_pos_fp,can_MotCurrQax_fp);
////        strcpy(cal_HwTqArbn_HwTq_low_pos_fp,can_HwTqArbn_HwTq_fp);

//      cal_MotCurrQax_low_pos_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_low_pos_fp = can_HwTqArbn_HwTq_fp;

        cal_T1XX_MotCurrQax_low_pos_fp += can_T1XX_MotCurrQax_fp;
        cal_T1XX_HwTqArbn_HwTq_low_pos_fp += can_T1XX_HwTqArbn_HwTq_fp;
        cal_T1XX_MotTq_low_pos_fp += can_T1XX_MotTq_fp;

        }

//      cal_MotCurrQax_low_pos_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_low_pos_fp = can_HwTqArbn_HwTq_fp;

        cal_T1XX_MotCurrQax_low_pos_fp = cal_T1XX_MotCurrQax_low_pos_fp / 10.0;
        cal_T1XX_HwTqArbn_HwTq_low_pos_fp = cal_T1XX_HwTqArbn_HwTq_low_pos_fp / 10.0;
        cal_T1XX_MotTq_low_pos_fp = cal_T1XX_MotTq_low_pos_fp / 10.0;

// ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p1nm \r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);

// ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
      // 0.10nm torque in negative direction for low value functional.


        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm);
        torque_value_case_index = neg_p1nm;   // neg .1nm torque
        sent_data_calculation_from_table(sent_data_array_neg_p1nm); // calc and stuff edge times into sent_edge_event_time[][]

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        cal_T1XX_MotCurrQax_low_neg_fp = 0.0;
        cal_T1XX_HwTqArbn_HwTq_low_neg_fp = 0.0;
        cal_T1XX_MotTq_low_neg_fp = 0.0;

for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != T1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

////        strcpy(cal_MotCurrQax_low_neg_fp,can_MotCurrQax_fp);
////        strcpy(cal_HwTqArbn_HwTq_low_neg_fp,can_HwTqArbn_HwTq_fp);

//      cal_MotCurrQax_low_neg_fp = cal_MotCurrQax_low_neg_fp;
//      cal_HwTqArbn_HwTq_low_neg_fp = can_HwTqArbn_HwTq_fp;

        cal_T1XX_MotCurrQax_low_neg_fp += can_T1XX_MotCurrQax_fp;
        cal_T1XX_HwTqArbn_HwTq_low_neg_fp += can_T1XX_HwTqArbn_HwTq_fp;
        cal_T1XX_MotTq_low_neg_fp += can_T1XX_MotTq_fp;

        }


//      cal_MotCurrQax_low_neg_fp = cal_MotCurrQax_low_neg_fp;
//      cal_HwTqArbn_HwTq_low_neg_fp = can_HwTqArbn_HwTq_fp;

        cal_T1XX_MotCurrQax_low_neg_fp = cal_T1XX_MotCurrQax_low_neg_fp / 10.0;
        cal_T1XX_HwTqArbn_HwTq_low_neg_fp = cal_T1XX_HwTqArbn_HwTq_fp / 10.0;
        cal_T1XX_MotTq_low_neg_fp = cal_T1XX_MotTq_low_neg_fp / 10.0;


// ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p1nm \r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);


// ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/

      // 2.00nm torque in positive direction for med value functional.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);
        torque_value_case_index = pos_2p00nm;   // pos 2.0nm torque
        sent_data_calculation_from_table(sent_data_array_pos_2p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        cal_T1XX_MotCurrQax_med_pos_fp = 0.0;
        cal_T1XX_HwTqArbn_HwTq_med_pos_fp = 0.0;
        cal_T1XX_MotTq_med_pos_fp = 0.0;

for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != T1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

////        strcpy(cal_MotCurrQax_med_pos_fp,can_MotCurrQax_fp);
////        strcpy(cal_HwTqArbn_HwTq_med_pos_fp,can_HwTqArbn_HwTq_fp);

//      cal_MotCurrQax_med_pos_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_med_pos_fp = can_HwTqArbn_HwTq_fp;

        cal_T1XX_MotCurrQax_med_pos_fp += can_T1XX_MotCurrQax_fp;
        cal_T1XX_HwTqArbn_HwTq_med_pos_fp += can_T1XX_HwTqArbn_HwTq_fp;
        cal_T1XX_MotTq_med_pos_fp += can_T1XX_MotTq_fp;

        }

//      cal_MotCurrQax_med_pos_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_med_pos_fp = can_HwTqArbn_HwTq_fp;

        cal_T1XX_MotCurrQax_med_pos_fp = cal_T1XX_MotCurrQax_med_pos_fp / 10.0;
        cal_T1XX_HwTqArbn_HwTq_med_pos_fp = cal_T1XX_HwTqArbn_HwTq_med_pos_fp / 10.0;
        cal_T1XX_MotTq_med_pos_fp = cal_T1XX_MotTq_med_pos_fp / 10.0;

// ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_2p00nm\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);

// ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/

      // 2.00nm torque in negative direction for med value functional.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);
        torque_value_case_index = neg_2p00nm;   // neg 2.0nm torque
        sent_data_calculation_from_table(sent_data_array_neg_2p00nm);    // calc and stuff edge times into sent_edge_event_time[][]

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        cal_T1XX_MotCurrQax_med_neg_fp = 0.0;
        cal_T1XX_HwTqArbn_HwTq_med_neg_fp = 0.0;
        cal_T1XX_MotTq_med_neg_fp = 0.0;


for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {
        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != T1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

////        strcpy(cal_MotCurrQax_med_neg_str,can_MotCurrQax_str);
////        strcpy(cal_HwTqArbn_HwTq_med_neg_str,can_HwTqArbn_HwTq_str);

//      cal_MotCurrQax_med_neg_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_med_neg_fp = can_HwTqArbn_HwTq_fp;
        cal_T1XX_MotCurrQax_med_neg_fp += can_T1XX_MotCurrQax_fp;
        cal_T1XX_HwTqArbn_HwTq_med_neg_fp += can_T1XX_HwTqArbn_HwTq_fp;
        cal_T1XX_MotTq_med_neg_fp += can_T1XX_MotTq_fp;

        }
//      cal_MotCurrQax_med_neg_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_med_neg_fp = can_HwTqArbn_HwTq_fp;

        cal_T1XX_MotCurrQax_med_neg_fp = cal_T1XX_MotCurrQax_med_neg_fp / 10.0;
        cal_T1XX_HwTqArbn_HwTq_med_neg_fp = cal_T1XX_HwTqArbn_HwTq_med_neg_fp / 10.0;
        cal_T1XX_MotTq_med_neg_fp = cal_T1XX_MotTq_med_neg_fp / 10.0;

// ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_2p00nm\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);

// ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/

      // 4.00nm torque in positive direction only high value functional.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);
        torque_value_case_index = pos_4p00nm;   // pos 4.0nm torque
        sent_data_calculation_from_table(sent_data_array_pos_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        cal_T1XX_MotCurrQax_high_pos_fp = 0.0;
        cal_T1XX_HwTqArbn_HwTq_high_pos_fp = 0.0;
        cal_T1XX_MotTq_high_pos_fp = 0.0;

for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != T1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();


////        strcpy(cal_MotCurrQax_high_pos_str,can_MotCurrQax_str);
////        strcpy(cal_HwTqArbn_HwTq_high_pos_str,can_HwTqArbn_HwTq_str);

//      cal_MotCurrQax_high_pos_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_high_pos_fp = can_HwTqArbn_HwTq_fp;

        cal_T1XX_MotCurrQax_high_pos_fp += can_T1XX_MotCurrQax_fp;
        cal_T1XX_HwTqArbn_HwTq_high_pos_fp += can_T1XX_HwTqArbn_HwTq_fp;
        cal_T1XX_MotTq_high_pos_fp += can_T1XX_MotTq_fp;

        }

        cal_T1XX_MotCurrQax_high_pos_fp = cal_T1XX_MotCurrQax_high_pos_fp / 10.0;
        cal_T1XX_HwTqArbn_HwTq_high_pos_fp = cal_T1XX_HwTqArbn_HwTq_high_pos_fp / 10.0;
        cal_T1XX_MotTq_high_pos_fp = cal_T1XX_MotTq_high_pos_fp / 10.0;

// ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_4p00nm\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);

// ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/

      // 4.00nm torque in negative direction only high value functional.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);
        torque_value_case_index = neg_4p00nm;   // neg 4.0nm torque
        sent_data_calculation_from_table(sent_data_array_neg_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        cal_T1XX_MotCurrQax_high_neg_fp = 0.0;
        cal_T1XX_HwTqArbn_HwTq_high_neg_fp = 0.0;
        cal_T1XX_MotTq_high_neg_fp = 0.0;

for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != T1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

////        strcpy(cal_MotCurrQax_high_neg_str,can_MotCurrQax_str);
////        strcpy(cal_HwTqArbn_HwTq_high_neg_str,can_HwTqArbn_HwTq_str);

//      cal_MotCurrQax_high_neg_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_high_neg_fp = can_HwTqArbn_HwTq_fp;


        cal_T1XX_MotCurrQax_high_neg_fp += can_T1XX_MotCurrQax_fp;
        cal_T1XX_HwTqArbn_HwTq_high_neg_fp += can_T1XX_HwTqArbn_HwTq_fp;
        cal_T1XX_MotTq_high_neg_fp += can_T1XX_MotTq_fp;

        }

//      cal_MotCurrQax_high_neg_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_high_neg_fp = can_HwTqArbn_HwTq_fp;

        cal_T1XX_MotCurrQax_high_neg_fp = cal_T1XX_MotCurrQax_high_neg_fp / 10.0;
        cal_T1XX_HwTqArbn_HwTq_high_neg_fp = cal_T1XX_HwTqArbn_HwTq_high_neg_fp / 10.0;
        cal_T1XX_MotTq_high_neg_fp = cal_T1XX_MotTq_high_neg_fp / 10.0;

// ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_4p00nm\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);

// ------------------------------------------------------------- Step 10 - Done testing current return to 0 amps    \/

      // 0.00nm torque in positive direction.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message


// ------------------------------------------------------------- Step 11 - print out results \/
        /* max up to 23 parameters at a time, sprintf function max   -- Using K2xx format, temp_return_message[]    19MAR12 L.Cronk  */
        /*  69 parameters + DTCs  -- full unused with N_A_num.       */

        sprintf(return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                 cal_T1XX_BattVltg_fp, cal_T1XX_BattVltgSwd1_fp,\
                 cal_T1XX_BattVltgSwd2_fp,cal_T1XX_EcuTFild_fp,\
                 cal_T1XX_MotWidgT_fp,cal_T1XX_HwTqArbn_HwTqChA_fp,\
                 cal_T1XX_HwTqArbn_HwTqChB_fp,cal_T1XX_HwTqArbn_HwTq_fp,\
                 cal_T1XX_HwTq0Meas_HwTq0_fp,cal_T1XX_HwTq1Meas_HwTq1_fp);      //10
        /* <23 at a time */

        sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                cal_T1XX_HwTq2Meas_HwTq2_fp,cal_T1XX_HwTq3Meas_HwTq3_fp,\
                cal_T1XX_HwAgArbn_HwAg_fp,cal_T1XX_HwAg0_fp,\
                cal_T1XX_HwAg1_fp,cal_T1XX_MotTq_fp,\
                cal_T1XX_MotCurrQax_fp,cal_T1XX_MotCurrQax_low_pos_fp,\
                cal_T1XX_MotCurrQax_med_pos_fp,cal_T1XX_MotCurrQax_high_pos_fp);  //10

        strcat(return_message,temp_return_message);

        sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                cal_T1XX_MotCurrQax_low_neg_fp,cal_T1XX_MotCurrQax_med_neg_fp,\
                cal_T1XX_MotCurrQax_high_neg_fp,cal_T1XX_HwTqArbn_HwTq_low_pos_fp,\
                cal_T1XX_HwTqArbn_HwTq_med_pos_fp,cal_T1XX_HwTqArbn_HwTq_high_pos_fp,\
                cal_T1XX_HwTqArbn_HwTq_low_neg_fp,cal_T1XX_HwTqArbn_HwTq_med_neg_fp,\
                cal_T1XX_HwTqArbn_HwTq_high_neg_fp);    //9

        strcat(return_message,temp_return_message);

        sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                cal_T1XX_MotTq_low_pos_fp,cal_T1XX_MotTq_med_pos_fp,\
                cal_T1XX_MotTq_high_pos_fp,cal_T1XX_MotTq_low_neg_fp,\
                cal_T1XX_MotTq_med_neg_fp,cal_T1XX_MotTq_high_neg_fp);  //6

        strcat(return_message,temp_return_message);


/*   All Done - fill it up with  N_A_num  (69-10-10-9-6 = 34) */

        sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
        N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
        strcat(return_message,temp_return_message);

        sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
        N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
        strcat(return_message,temp_return_message);

        sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
        N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
        strcat(return_message,temp_return_message);

        sprintf(temp_return_message,"%d,%d,%d,%d,",\
        N_A_num,N_A_num,N_A_num,N_A_num);   //4
        strcat(return_message,temp_return_message);

                get_DTCs1();

                strcat(return_message,dtc1_return_message);

        strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

        strcpy(sbuf_tx_main,"\r\n");
        strcat(sbuf_tx_main,return_message);
        strcat(sbuf_tx_main,"\r\n");

                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
            case CIB:
                if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                {
                   transmit_str_485(return_message);
                }
            break;

            case WEB:
                if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                {
                    transmit_str_485(return_message);
                }
            break;
        }

// ------------------------------------------------------------- Step 12 - Clean up   DONE \/

// turn off Ign
//      clrbit(p1reg,7);    /* set Product Ign to off    29MAR12 L.Cronk */

        ign1_status = OFF;

        gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */

//      Engine_on_Signal = 0;  // end in warm init mode
//      speed_flag = 0;       // set current to 0 amps for FORD -- don't use warm init (-1)
                             // because it makes 'main' do OSV measure until speed > -1  NO OSV
        break;
        }   // end case TARGET_T1XX

        case TARGET_GWM_A0607:
        {
//  G W M A 0 6 0 7   F U N C T I O N A L S ------------------------------

        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

// ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

// -------------------------------------------      ign1_status = WARM;
//      Engine_on_Signal = 0;   // put product in warm init No current output
        //ign1_status = WARM;

        system_msec_clock_temp = system_msec_clock + 7000;  // wait 7 Sec, wait for temp sensor to acclimate
        while(system_msec_clock < system_msec_clock_temp);


// ------------------------------------------------------------- Step 2 - Clr DTCs \/
        // ************ CLEAR DTC's ******************

        tester_present_timer = 3000;  // set timer for 3 seconds

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);


        ECU1_XCP_reply_index = 1;

        ECU1_clear_DTCs_flag = 1; // set flag for ISR


        canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        ECU1_XCP_reply_index = 0;
        ECU1_clear_DTCs_flag = 0; // done...clr flag for ISR

        // ************ END clear DTC's ******************


// ------------------------------------------------------------- Step 3 - Request/store one time perimetrics \/
        // set up torque value, not going back to main so initiate all steps here

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

// if we were to use sent_data_calculation_from_torque() call funct with torque as parameter   // zero nm torque
//  OR
//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
//  OR
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message


        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != GWM_A0607_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

// New B-CIB using floats for storage and printing
        cal_GWM_A0607_BattVltg_fp = can_GWM_A0607_BattVltg_fp;                       //  1   Batt Volt
        cal_GWM_A0607_SystemState_byt = can_GWM_A0607_SystemState_byt;               //  2   System State Byte
        cal_GWM_A0607_HwTq0Meas_HwTq4_fp = can_GWM_A0607_HwTq0Meas_HwTq4_fp;         //  3   HW Torque 4
        cal_GWM_A0607_HwTq1Meas_HwTq5_fp = can_GWM_A0607_HwTq1Meas_HwTq5_fp;         //  4   HW Torque 5
        cal_GWM_A0607_MotHwPosn_fp = can_GWM_A0607_MotHwPosn_fp;                     //  5   Motor HW Position
        cal_GWM_A0607_MotTq_fp = can_GWM_A0607_MotTq_fp;                             //  6   Motor Torque
        cal_GWM_A0607_MotCurrQax_fp = can_GWM_A0607_MotCurrQax_fp;                   //  7   Motor Current QAX
        cal_GWM_A0607_HwTrq_fp = can_GWM_A0607_HwTrq_fp;                             //  8   HW Torque
        cal_GWM_A0607_MotMagTestim_fp = can_GWM_A0607_MotMagTestim_fp;               //  9   Motor Mag Temp Estimated
        cal_GWM_A0607_ECUTFilt_fp = can_GWM_A0607_ECUTFilt_fp;                       //  10  ECU Temp Filtered

// ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perimetrics -- sent_data_array_pos_0nm \r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 500;   // wait 500  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);



//// Old CIB using hex strings for floats
//      strcpy(cal_BattVltg_str,can_BattVltg_str);                  //  16
//      strcpy(cal_BattVltgSwd1_str,can_BattVltgSwd1_str);          //  17
//      strcpy(cal_BattVltgSwd2_str,can_BattVltgSwd2_str);          //  18
//      strcpy(cal_EcuTFild_str,can_EcuTFild_str);                  //  7
//      strcpy(cal_HwTqArbn_HwTq_str,can_HwTqArbn_HwTq_str);        //  11
//      strcpy(cal_HwTqArbn_HwTqChA_str,can_HwTqArbn_HwTqChA_str);  //  13
//      strcpy(cal_HwTqArbn_HwTqChB_str,can_HwTqArbn_HwTqChB_str);  //  14
//      cal_MotTqWhl_cnt = can_MotTqWhl_cnt;                        //  12
//      strcpy(cal_HwTq0Meas_HwTq0_str,can_HwTq0Meas_HwTq0_str);    //  3
//      strcpy(cal_HwTq0Meas_HwTq1_str,can_HwTq0Meas_HwTq1_str);    //  4
//      strcpy(cal_HwTq0Meas_HwTq2_str,can_HwTq0Meas_HwTq2_str);    //  5
//      strcpy(cal_HwTq0Meas_HwTq3_str,can_HwTq0Meas_HwTq3_str);    //  6
//      strcpy(cal_HwAgArbn_HwAg_str,can_HwAgArbn_HwAg_str);        //  8
//      strcpy(cal_HwAg0_str,can_HwAg0_str);                        //  9
//      strcpy(cal_HwAg1_str,can_HwAg1_str);                        //  10
//      cal_MotTq_cnt = can_MotTq_cnt;                              //  27
//      strcpy(cal_MotCurrQax_str,can_MotCurrQax_str);              //  2
//

// ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
      // 0.10nm torque in positive direction for low value functional.

        ign1_status = NORMAL;
//      Engine_on_Signal = 1;   // put in run mode to output current.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm);
        torque_value_case_index = pos_0nm;   // pos 0nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm); // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);


        cal_GWM_A0607_MotCurrQax_low_pos_fp = 0.0;
        cal_GWM_A0607_HwTqArbn_HwTq_low_pos_fp = 0.0;
        cal_GWM_A0607_MotTq_low_pos_fp = 0.0;

for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != GWM_A0607_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

////        strcpy(cal_MotCurrQax_low_pos_fp,can_MotCurrQax_fp);
////        strcpy(cal_HwTqArbn_HwTq_low_pos_fp,can_HwTqArbn_HwTq_fp);

//      cal_MotCurrQax_low_pos_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_low_pos_fp = can_HwTqArbn_HwTq_fp;

        cal_GWM_A0607_MotCurrQax_low_pos_fp += can_GWM_A0607_MotCurrQax_fp;
        cal_GWM_A0607_HwTqArbn_HwTq_low_pos_fp += can_GWM_A0607_HwTrq_fp;
        cal_GWM_A0607_MotTq_low_pos_fp += can_GWM_A0607_MotTq_fp;

        }

//      cal_MotCurrQax_low_pos_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_low_pos_fp = can_HwTqArbn_HwTq_fp;

        cal_GWM_A0607_MotCurrQax_low_pos_fp = cal_GWM_A0607_MotCurrQax_low_pos_fp / 10.0;
        cal_GWM_A0607_HwTqArbn_HwTq_low_pos_fp = cal_GWM_A0607_HwTqArbn_HwTq_low_pos_fp / 10.0;
        cal_GWM_A0607_MotTq_low_pos_fp = cal_GWM_A0607_MotTq_low_pos_fp / 10.0;

// ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p0nm \r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);

// ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
      // 00nm torque in negative direction for low value functional.


        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm);
        torque_value_case_index = pos_0nm;   // pos 0nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm); // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        cal_GWM_A0607_MotCurrQax_low_neg_fp = 0.0;
        cal_GWM_A0607_HwTqArbn_HwTq_low_neg_fp = 0.0;
        cal_GWM_A0607_MotTq_low_neg_fp = 0.0;

for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != GWM_A0607_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

////        strcpy(cal_MotCurrQax_low_neg_fp,can_MotCurrQax_fp);
////        strcpy(cal_HwTqArbn_HwTq_low_neg_fp,can_HwTqArbn_HwTq_fp);

//      cal_MotCurrQax_low_neg_fp = cal_MotCurrQax_low_neg_fp;
//      cal_HwTqArbn_HwTq_low_neg_fp = can_HwTqArbn_HwTq_fp;

        cal_GWM_A0607_MotCurrQax_low_neg_fp += can_GWM_A0607_MotCurrQax_fp;
        cal_GWM_A0607_HwTqArbn_HwTq_low_neg_fp += can_GWM_A0607_HwTrq_fp;
        cal_GWM_A0607_MotTq_low_neg_fp += can_GWM_A0607_MotTq_fp;

        }


//      cal_MotCurrQax_low_neg_fp = cal_MotCurrQax_low_neg_fp;
//      cal_HwTqArbn_HwTq_low_neg_fp = can_HwTqArbn_HwTq_fp;

        cal_GWM_A0607_MotCurrQax_low_neg_fp = cal_GWM_A0607_MotCurrQax_low_neg_fp / 10.0;
        cal_GWM_A0607_HwTqArbn_HwTq_low_neg_fp = cal_GWM_A0607_HwTrq_fp / 10.0;
        cal_GWM_A0607_MotTq_low_neg_fp = cal_GWM_A0607_MotTq_low_neg_fp / 10.0;


// ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p0nm \r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);


// ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/

      // 1.00nm torque in positive direction for med value functional.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm);
        torque_value_case_index = pos_1p00nm;   // pos 1.00nm torque
        sent_data_calculation_from_table(sent_data_array_pos_1p00nm);   // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        cal_GWM_A0607_MotCurrQax_med_pos_fp = 0.0;
        cal_GWM_A0607_HwTqArbn_HwTq_med_pos_fp = 0.0;
        cal_GWM_A0607_MotTq_med_pos_fp = 0.0;

for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != GWM_A0607_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

////        strcpy(cal_MotCurrQax_med_pos_fp,can_MotCurrQax_fp);
////        strcpy(cal_HwTqArbn_HwTq_med_pos_fp,can_HwTqArbn_HwTq_fp);

//      cal_MotCurrQax_med_pos_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_med_pos_fp = can_HwTqArbn_HwTq_fp;

        cal_GWM_A0607_MotCurrQax_med_pos_fp += can_GWM_A0607_MotCurrQax_fp;
        cal_GWM_A0607_HwTqArbn_HwTq_med_pos_fp += can_GWM_A0607_HwTrq_fp;
        cal_GWM_A0607_MotTq_med_pos_fp += can_GWM_A0607_MotTq_fp;

        }

//      cal_MotCurrQax_med_pos_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_med_pos_fp = can_HwTqArbn_HwTq_fp;

        cal_GWM_A0607_MotCurrQax_med_pos_fp = cal_GWM_A0607_MotCurrQax_med_pos_fp / 10.0;
        cal_GWM_A0607_HwTqArbn_HwTq_med_pos_fp = cal_GWM_A0607_HwTqArbn_HwTq_med_pos_fp / 10.0;
        cal_GWM_A0607_MotTq_med_pos_fp = cal_GWM_A0607_MotTq_med_pos_fp / 10.0;

// ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_1p00nm\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);

// ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/

      // 1.00nm torque in negative direction for med value functional.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm);
        torque_value_case_index = neg_1p00nm;   // neg 1.00nm torque
        sent_data_calculation_from_table(sent_data_array_neg_1p00nm);    // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        cal_GWM_A0607_MotCurrQax_med_neg_fp = 0.0;
        cal_GWM_A0607_HwTqArbn_HwTq_med_neg_fp = 0.0;
        cal_GWM_A0607_MotTq_med_neg_fp = 0.0;


for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {
        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != GWM_A0607_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

////        strcpy(cal_MotCurrQax_med_neg_str,can_MotCurrQax_str);
////        strcpy(cal_HwTqArbn_HwTq_med_neg_str,can_HwTqArbn_HwTq_str);

//      cal_MotCurrQax_med_neg_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_med_neg_fp = can_HwTqArbn_HwTq_fp;
        cal_GWM_A0607_MotCurrQax_med_neg_fp += can_GWM_A0607_MotCurrQax_fp;
        cal_GWM_A0607_HwTqArbn_HwTq_med_neg_fp += can_GWM_A0607_HwTrq_fp;
        cal_GWM_A0607_MotTq_med_neg_fp += can_GWM_A0607_MotTq_fp;

        }
//      cal_MotCurrQax_med_neg_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_med_neg_fp = can_HwTqArbn_HwTq_fp;

        cal_GWM_A0607_MotCurrQax_med_neg_fp = cal_GWM_A0607_MotCurrQax_med_neg_fp / 10.0;
        cal_GWM_A0607_HwTqArbn_HwTq_med_neg_fp = cal_GWM_A0607_HwTqArbn_HwTq_med_neg_fp / 10.0;
        cal_GWM_A0607_MotTq_med_neg_fp = cal_GWM_A0607_MotTq_med_neg_fp / 10.0;

// ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_1p00nm\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);

// ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/

      // 2.00nm torque in positive direction only high value functional.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm);
        torque_value_case_index = pos_2p00nm;   // pos 2.00nm torque
        sent_data_calculation_from_table(sent_data_array_pos_2p00nm);   // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        cal_GWM_A0607_MotCurrQax_high_pos_fp = 0.0;
        cal_GWM_A0607_HwTqArbn_HwTq_high_pos_fp = 0.0;
        cal_GWM_A0607_MotTq_high_pos_fp = 0.0;

for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != GWM_A0607_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();


////        strcpy(cal_MotCurrQax_high_pos_str,can_MotCurrQax_str);
////        strcpy(cal_HwTqArbn_HwTq_high_pos_str,can_HwTqArbn_HwTq_str);

//      cal_MotCurrQax_high_pos_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_high_pos_fp = can_HwTqArbn_HwTq_fp;

        cal_GWM_A0607_MotCurrQax_high_pos_fp += can_GWM_A0607_MotCurrQax_fp;
        cal_GWM_A0607_HwTqArbn_HwTq_high_pos_fp += can_GWM_A0607_HwTrq_fp;
        cal_GWM_A0607_MotTq_high_pos_fp += can_GWM_A0607_MotTq_fp;

        }

        cal_GWM_A0607_MotCurrQax_high_pos_fp = cal_GWM_A0607_MotCurrQax_high_pos_fp / 10.0;
        cal_GWM_A0607_HwTqArbn_HwTq_high_pos_fp = cal_GWM_A0607_HwTqArbn_HwTq_high_pos_fp / 10.0;
        cal_GWM_A0607_MotTq_high_pos_fp = cal_GWM_A0607_MotTq_high_pos_fp / 10.0;

// ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_2p00nm\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);

// ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/

      // 2.00nm torque in negative direction only high value functional.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm);
        torque_value_case_index = neg_2p00nm;   // neg 2.00nm torque
        sent_data_calculation_from_table(sent_data_array_neg_2p00nm);   // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
        while(system_msec_clock < system_msec_clock_temp);

        cal_GWM_A0607_MotCurrQax_high_neg_fp = 0.0;
        cal_GWM_A0607_HwTqArbn_HwTq_high_neg_fp = 0.0;
        cal_GWM_A0607_MotTq_high_neg_fp = 0.0;

for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
        {

        // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

        can1_request_index = 0; // set index to start sequence at case 0 in ISR
ShiftCAN1();
        system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
        while((can1_request_index != GWM_A0607_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

        parse_can1_data();

////        strcpy(cal_MotCurrQax_high_neg_str,can_MotCurrQax_str);
////        strcpy(cal_HwTqArbn_HwTq_high_neg_str,can_HwTqArbn_HwTq_str);

//      cal_MotCurrQax_high_neg_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_high_neg_fp = can_HwTqArbn_HwTq_fp;


        cal_GWM_A0607_MotCurrQax_high_neg_fp += can_GWM_A0607_MotCurrQax_fp;
        cal_GWM_A0607_HwTqArbn_HwTq_high_neg_fp += can_GWM_A0607_HwTrq_fp;
        cal_GWM_A0607_MotTq_high_neg_fp += can_GWM_A0607_MotTq_fp;

        }

//      cal_MotCurrQax_high_neg_fp = can_MotCurrQax_fp;
//      cal_HwTqArbn_HwTq_high_neg_fp = can_HwTqArbn_HwTq_fp;

        cal_GWM_A0607_MotCurrQax_high_neg_fp = cal_GWM_A0607_MotCurrQax_high_neg_fp / 10.0;
        cal_GWM_A0607_HwTqArbn_HwTq_high_neg_fp = cal_GWM_A0607_HwTqArbn_HwTq_high_neg_fp / 10.0;
        cal_GWM_A0607_MotTq_high_neg_fp = cal_GWM_A0607_MotTq_high_neg_fp / 10.0;

// ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
        strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_2p00nm\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
        trig();
                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
        while(system_msec_clock < system_msec_clock_temp);

// ------------------------------------------------------------- Step 10 - Done testing current return to 0 amps    \/

      // 0.00nm torque in positive direction.

        tester_present_enable_flag = 0; // stop tester present message

        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
        while(system_msec_clock < system_msec_clock_temp);

        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

//      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
        torque_value_case_index = pos_0nm;   // zero nm torque
        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
        set_torque_TOC_or_SENT_or_Analog();

        system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

        tester_present_enable_flag = 1; // re-enable tester present message


// ------------------------------------------------------------- Step 11 - print out results \/
        /* max up to 23 parameters at a time, sprintf function max   -- Using K2xx format, temp_return_message[]    19MAR12 L.Cronk  */
        /*  69 parameters + DTCs  -- full unused with N_A_num.       */

        sprintf(return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                cal_GWM_A0607_BattVltg_fp,cal_GWM_A0607_SystemState_byt,\
                cal_GWM_A0607_HwTq0Meas_HwTq4_fp,cal_GWM_A0607_HwTq1Meas_HwTq5_fp,\
                cal_GWM_A0607_MotHwPosn_fp,cal_GWM_A0607_MotTq_fp,\
                cal_GWM_A0607_MotCurrQax_fp,cal_GWM_A0607_HwTrq_fp,\
                cal_GWM_A0607_MotMagTestim_fp,cal_GWM_A0607_ECUTFilt_fp);      //10
        /* <23 at a time */

        sprintf(temp_return_message,"%.3f,%.3f,%.3f,%d,%d,%d,%d,%d,%d,%d,",\
                cal_GWM_A0607_MotCurrQax_low_pos_fp,cal_GWM_A0607_MotCurrQax_med_pos_fp,\
                cal_GWM_A0607_MotCurrQax_high_pos_fp,N_A_num,\
                N_A_num,N_A_num,\
                N_A_num,N_A_num,\
                N_A_num,N_A_num);  //10

        strcat(return_message,temp_return_message);

        sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                cal_GWM_A0607_MotCurrQax_low_neg_fp,cal_GWM_A0607_MotCurrQax_med_neg_fp,\
                cal_GWM_A0607_MotCurrQax_high_neg_fp,cal_GWM_A0607_HwTqArbn_HwTq_low_pos_fp,\
                cal_GWM_A0607_HwTqArbn_HwTq_med_pos_fp,cal_GWM_A0607_HwTqArbn_HwTq_high_pos_fp,\
                cal_GWM_A0607_HwTqArbn_HwTq_low_neg_fp,cal_GWM_A0607_HwTqArbn_HwTq_med_neg_fp,\
                cal_GWM_A0607_HwTqArbn_HwTq_high_neg_fp);    //9

        strcat(return_message,temp_return_message);

        sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                cal_GWM_A0607_MotTq_low_pos_fp,cal_GWM_A0607_MotTq_med_pos_fp,\
                cal_GWM_A0607_MotTq_high_pos_fp,cal_GWM_A0607_MotTq_low_neg_fp,\
                cal_GWM_A0607_MotTq_med_neg_fp,cal_GWM_A0607_MotTq_high_neg_fp);  //6

        strcat(return_message,temp_return_message);


/*   All Done - fill it up with  N_A_num  (69-10-10-9-6 = 34) */

//        sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
        N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
//        strcat(return_message,temp_return_message);

//        sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
//        N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
//        strcat(return_message,temp_return_message);

//        sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
//        N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
//        strcat(return_message,temp_return_message);

//        sprintf(temp_return_message,"%d,%d,%d,%d,",\
//        N_A_num,N_A_num,N_A_num,N_A_num);   //4
//        strcat(return_message,temp_return_message);

                get_DTCs1();

                strcat(return_message,dtc1_return_message);

        strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

        strcpy(sbuf_tx_main,"\r\n");
        strcat(sbuf_tx_main,return_message);
        strcat(sbuf_tx_main,"\r\n");

                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
            case CIB:
                if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                {
                   transmit_str_485(return_message);
                }
            break;

            case WEB:
                if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                {
                    transmit_str_485(return_message);
                }
            break;
        }

// ------------------------------------------------------------- Step 12 - Clean up   DONE \/

// turn off Ign
//      clrbit(p1reg,7);    /* set Product Ign to off    29MAR12 L.Cronk */

        ign1_status = OFF;

        gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */

//      Engine_on_Signal = 0;  // end in warm init mode
//      speed_flag = 0;       // set current to 0 amps for FORD -- don't use warm init (-1)
                             // because it makes 'main' do OSV measure until speed > -1  NO OSV
        break;
        }   // end case TARGET_GWM_A0607

        case TARGET_C1XX:
        {
            //  C 1 X X   F U N C T I O N A L S ------------------------------

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

            // ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

            // -------------------------------------------      ign1_status = WARM;
            //      Engine_on_Signal = 0;   // put product in warm init No current output
                    ign1_status = WARM;

                    system_msec_clock_temp = system_msec_clock + 7000;  // wait 7 Sec, wait for temp sensor to acclimate
                    while(system_msec_clock < system_msec_clock_temp);


            // ------------------------------------------------------------- Step 2 - Clr DTCs \/
                    // ************ CLEAR DTC's ******************

                    tester_present_timer = 3000;  // set timer for 3 seconds

                    system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                    while(system_msec_clock < system_msec_clock_temp);


                    ECU1_XCP_reply_index = 1;

                    ECU1_clear_DTCs_flag = 1; // set flag for ISR


                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    ECU1_XCP_reply_index = 0;
                    ECU1_clear_DTCs_flag = 0; // done...clr flag for ISR

                    // ************ END clear DTC's ******************


            // ------------------------------------------------------------- Step 3 - Request/store one time perimetrics \/
                    // set up torque value, not going back to main so initate all steps here

                    tester_present_enable_flag = 0; // stop tester present message

                    system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                    while(system_msec_clock < system_msec_clock_temp);

                    ECU1_XCP_reply_index = 20;  // do nothing case for product reply

            // if we were to use sent_data_calculation_from_torque() call funct with torque as parameter   // zero nm torque
            //  OR
            //      canTransmit(canREG1, XCP_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
            //  OR
                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    tester_present_enable_flag = 1; // re-enable tester present message


                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != C1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

            // New B-CIB using floats for stoarage and printing

                    cal_C1XX_BattVltg_fp = can_C1XX_BattVltg_fp;                                    //  1   Battery Voltage
                    cal_C1XX_Temperature_fp = can_C1XX_Temperature_fp;                              //  2   Ecu Temperature Filtered
                    cal_C1XX_DigT1_fp = can_C1XX_DigT1_fp;                                          //  3   Handwheel channel a trq
                    cal_C1XX_DigT2_fp = can_C1XX_DigT2_fp;                                          //  4   Handwheel channel b trq
                    cal_C1XX_MtrCurrQax_fp = can_C1XX_MtrCurrQax_fp;                                //  5   Motor Current Measurement
                    cal_C1XX_OnStateFltAcc_cnt = can_C1XX_OnStateFltAcc_cnt;                        //  6   OnStateFltAcc
                    cal_C1XX_GateDriveFltAcc_cnt = can_C1XX_GateDriveFltAcc_cnt;                    //  7   GateDriveFltAcc
                    cal_C1XX_GateDrvFltSts_cnt = can_C1XX_GateDrvFltSts_cnt;                        //  8   GateDrvFltSts
                    cal_C1XX_SystemState_byt = can_C1XX_SystemState_byt;                            //  9   System State
                    cal_C1XX_HwTrq_HwNm_fp = can_C1XX_HwTrq_HwNm_fp;                                //  10  Handwheel Tq total
                    cal_C1XX_Abs_Hw_Pos_fp = can_C1XX_Abs_Hw_Pos_fp;                                //  11  Handwheel Angle ABS
                    cal_C1XX_Rel_Hw_Pos_fp = can_C1XX_Rel_Hw_Pos_fp;                                //  12  Handwheel Angle REL
                    cal_C1XX_ManualTrqCmdEn_cnt = can_C1XX_ManualTrqCmdEn_cnt;                      //  13  Motor Commanded Torque cnt
                    cal_C1XX_MtrTrq_Cmd_Nm_fp = can_C1XX_MtrTrq_Cmd_Nm_fp;                          //  14  Motor Commanded Torque value
                    cal_C1XX_MSB_Die1_cnt = can_C1XX_MSB_Die1_cnt;                                  //  15  Motor Position 1
                    cal_C1XX_MSB_Die2_cnt = can_C1XX_MSB_Die2_cnt;                                  //  16  Motor Position 2
                    cal_C1XX_MtrTempEst_MagTempEst_DegC_fp = can_C1XX_MtrTempEst_MagTempEst_DegC_fp;//  17  Motor Magnet temp

            // ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perimetrics -- sent_data_array_pos_0nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);


            // ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.10nm torque in positive direction for low value functional.

                    ign1_status = NORMAL;   // put in run mode to output current.

                    tester_present_enable_flag = 0; // stop tester present message

                    system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                    while(system_msec_clock < system_msec_clock_temp);

                    ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                    torque_value_case_index = pos_p1nm;   // pos .1nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_p1nm); // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    tester_present_enable_flag = 1; // re-enable tester present message

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);


                    cal_C1XX_MtrCurrQax_low_pos_fp      = 0.0;
                    cal_C1XX_HwTrq_HwNm_low_pos_fp      = 0.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_low_pos_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != C1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal_C1XX_MtrCurrQax_low_pos_fp += can_C1XX_MtrCurrQax_fp;
                    cal_C1XX_HwTrq_HwNm_low_pos_fp += can_C1XX_HwTrq_HwNm_fp;
                    cal_C1XX_MtrTrq_Cmd_Nm_low_pos_fp += can_C1XX_MtrTrq_Cmd_Nm_fp;

                    }

                    cal_C1XX_MtrCurrQax_low_pos_fp = cal_C1XX_MtrCurrQax_low_pos_fp / 10.0;
                    cal_C1XX_HwTrq_HwNm_low_pos_fp = cal_C1XX_HwTrq_HwNm_low_pos_fp / 10.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_low_pos_fp = cal_C1XX_MtrTrq_Cmd_Nm_low_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.10nm torque in negative direction for low value functional.


                    tester_present_enable_flag = 0; // stop tester present message

                    system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                    while(system_msec_clock < system_msec_clock_temp);

                    ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                    torque_value_case_index = neg_p1nm;   // neg .1nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_neg_p1nm); // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    tester_present_enable_flag = 1; // re-enable tester present message

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal_C1XX_MtrCurrQax_low_neg_fp = 0.0;
                    cal_C1XX_HwTrq_HwNm_low_neg_fp = 0.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_low_neg_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != C1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal_C1XX_MtrCurrQax_low_neg_fp += can_C1XX_MtrCurrQax_fp;
                    cal_C1XX_HwTrq_HwNm_low_neg_fp += can_C1XX_HwTrq_HwNm_fp;
                    cal_C1XX_MtrTrq_Cmd_Nm_low_neg_fp += can_C1XX_MtrTrq_Cmd_Nm_fp;

                    }

                    cal_C1XX_MtrCurrQax_low_neg_fp = cal_C1XX_MtrCurrQax_low_neg_fp / 10.0;
                    cal_C1XX_HwTrq_HwNm_low_neg_fp = cal_C1XX_HwTrq_HwNm_low_neg_fp / 10.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_low_neg_fp = cal_C1XX_MtrTrq_Cmd_Nm_low_neg_fp / 10.0;


            // ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);


            // ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/

                  // 2.00nm torque in positive direction for med value functional.

                    tester_present_enable_flag = 0; // stop tester present message

                    system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                    while(system_msec_clock < system_msec_clock_temp);

                    ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                    torque_value_case_index = pos_2p00nm;   // pos 2.0nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_2p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    tester_present_enable_flag = 1; // re-enable tester present message

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal_C1XX_MtrCurrQax_med_pos_fp = 0.0;
                    cal_C1XX_HwTrq_HwNm_med_pos_fp = 0.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_med_pos_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != C1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal_C1XX_MtrCurrQax_med_pos_fp += can_C1XX_MtrCurrQax_fp;
                    cal_C1XX_HwTrq_HwNm_med_pos_fp += can_C1XX_HwTrq_HwNm_fp;
                    cal_C1XX_MtrTrq_Cmd_Nm_med_pos_fp += cal_C1XX_MtrTrq_Cmd_Nm_fp;

                    }

                    cal_C1XX_MtrCurrQax_med_pos_fp = cal_C1XX_MtrCurrQax_med_pos_fp / 10.0;
                    cal_C1XX_HwTrq_HwNm_med_pos_fp = cal_C1XX_HwTrq_HwNm_med_pos_fp / 10.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_med_pos_fp = cal_C1XX_MtrTrq_Cmd_Nm_med_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/

                  // 2.00nm torque in negative direction for med value functional.

                    tester_present_enable_flag = 0; // stop tester present message

                    system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                    while(system_msec_clock < system_msec_clock_temp);

                    ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                    torque_value_case_index = neg_2p00nm;   // neg 2.0nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_neg_2p00nm);    // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    tester_present_enable_flag = 1; // re-enable tester present message

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal_C1XX_MtrCurrQax_med_neg_fp = 0.0;
                    cal_C1XX_HwTrq_HwNm_med_neg_fp = 0.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_med_neg_fp = 0.0;


            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != C1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal_C1XX_MtrCurrQax_med_neg_fp += can_C1XX_MtrCurrQax_fp;
                    cal_C1XX_HwTrq_HwNm_med_neg_fp += can_C1XX_HwTrq_HwNm_fp;
                    cal_C1XX_MtrTrq_Cmd_Nm_med_neg_fp += cal_C1XX_MtrTrq_Cmd_Nm_fp;

                    }

                    cal_C1XX_MtrCurrQax_med_neg_fp = cal_C1XX_MtrCurrQax_med_neg_fp / 10.0;
                    cal_C1XX_HwTrq_HwNm_med_neg_fp = cal_C1XX_HwTrq_HwNm_med_neg_fp / 10.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_med_neg_fp = cal_C1XX_MtrTrq_Cmd_Nm_med_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/

                  // 4.00nm torque in positive direction only high value functional.

                    tester_present_enable_flag = 0; // stop tester present message

                    system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                    while(system_msec_clock < system_msec_clock_temp);

                    ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                    torque_value_case_index = pos_4p00nm;   // pos 4.0nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    tester_present_enable_flag = 1; // re-enable tester present message

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal_C1XX_MtrCurrQax_high_pos_fp = 0.0;
                    cal_C1XX_HwTrq_HwNm_high_pos_fp = 0.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_high_pos_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != C1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();


                    cal_C1XX_MtrCurrQax_high_pos_fp += can_C1XX_MtrCurrQax_fp;
                    cal_C1XX_HwTrq_HwNm_high_pos_fp += can_C1XX_HwTrq_HwNm_fp;
                    cal_C1XX_MtrTrq_Cmd_Nm_high_pos_fp += cal_C1XX_MtrTrq_Cmd_Nm_fp;

                    }

                    cal_C1XX_MtrCurrQax_high_pos_fp = cal_C1XX_MtrCurrQax_high_pos_fp / 10.0;
                    cal_C1XX_HwTrq_HwNm_high_pos_fp = cal_C1XX_HwTrq_HwNm_high_pos_fp / 10.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_high_pos_fp = cal_C1XX_MtrTrq_Cmd_Nm_high_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/

                  // 4.00nm torque in negative direction only high value functional.

                    tester_present_enable_flag = 0; // stop tester present message

                    system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                    while(system_msec_clock < system_msec_clock_temp);

                    ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                    torque_value_case_index = neg_4p00nm;   // neg 4.0nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_neg_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    tester_present_enable_flag = 1; // re-enable tester present message

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal_C1XX_MtrCurrQax_high_neg_fp = 0.0;
                    cal_C1XX_HwTrq_HwNm_high_neg_fp = 0.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_high_neg_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != C1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal_C1XX_MtrCurrQax_high_neg_fp += can_C1XX_MtrCurrQax_fp;
                    cal_C1XX_HwTrq_HwNm_high_neg_fp += can_C1XX_HwTrq_HwNm_fp;
                    cal_C1XX_MtrTrq_Cmd_Nm_high_neg_fp += cal_C1XX_MtrTrq_Cmd_Nm_fp;

                    }

                    cal_C1XX_MtrCurrQax_high_neg_fp = cal_C1XX_MtrCurrQax_high_neg_fp / 10.0;
                    cal_C1XX_HwTrq_HwNm_high_neg_fp = cal_C1XX_HwTrq_HwNm_high_neg_fp / 10.0;
                    cal_C1XX_MtrTrq_Cmd_Nm_high_neg_fp = cal_C1XX_MtrTrq_Cmd_Nm_high_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 10 - Done testing current return to 0 amps    \/

                  // 0.00nm torque in positive direction.

                    tester_present_enable_flag = 0; // stop tester present message

                    system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                    while(system_msec_clock < system_msec_clock_temp);

                    ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 220;   // set time out to 220mS
                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    tester_present_enable_flag = 1; // re-enable tester present message


            // ------------------------------------------------------------- Step 11 - print out results \/
                    /* max up to 23 parameters at a time, sprintf function max   -- Using K2xx format, temp_return_message[]    19MAR12 L.Cronk  */
                    /*  69 parameters + DTCs  -- full unused with N_A_num.       */


                    sprintf(return_message,"%.3f,%.3f,%.3f,%d,%d,%d,%d,%.3f,%.3f,%.3f,",\
                            cal_C1XX_BattVltg_fp,cal_C1XX_Temperature_fp,\
                            cal_C1XX_MtrCurrQax_fp,cal_C1XX_OnStateFltAcc_cnt,\
                            cal_C1XX_GateDriveFltAcc_cnt,cal_C1XX_GateDrvFltSts_cnt,\
                            cal_C1XX_SystemState_byt,cal_C1XX_DigT1_fp,\
                            cal_C1XX_DigT2_fp,cal_C1XX_HwTrq_HwNm_fp);      //10
                    /* <23 at a time */

                    sprintf(temp_return_message,"%.3f,%.3f,%d,%.3f,%d,%d,%.3f,%.3f,%.3f,%.3f,",\
                            cal_C1XX_Abs_Hw_Pos_fp,cal_C1XX_Rel_Hw_Pos_fp,\
                            cal_C1XX_ManualTrqCmdEn_cnt,cal_C1XX_MtrTrq_Cmd_Nm_fp,\
                            cal_C1XX_MSB_Die1_cnt,cal_C1XX_MSB_Die2_cnt,\
                            cal_C1XX_MtrTempEst_MagTempEst_DegC_fp,cal_C1XX_MtrCurrQax_low_pos_fp,\
                            cal_C1XX_MtrCurrQax_med_pos_fp,cal_C1XX_MtrCurrQax_high_pos_fp);  //10

                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal_C1XX_MtrCurrQax_low_neg_fp,cal_C1XX_MtrCurrQax_med_neg_fp,\
                            cal_C1XX_MtrCurrQax_high_neg_fp,cal_C1XX_HwTrq_HwNm_low_pos_fp,\
                            cal_C1XX_HwTrq_HwNm_med_pos_fp,cal_C1XX_HwTrq_HwNm_high_pos_fp,\
                            cal_C1XX_HwTrq_HwNm_low_neg_fp,cal_C1XX_HwTrq_HwNm_med_neg_fp,\
                            cal_C1XX_HwTrq_HwNm_high_neg_fp);   //9

                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal_C1XX_MtrTrq_Cmd_Nm_low_pos_fp,cal_C1XX_MtrTrq_Cmd_Nm_med_pos_fp,\
                            cal_C1XX_MtrTrq_Cmd_Nm_high_pos_fp,cal_C1XX_MtrTrq_Cmd_Nm_low_neg_fp,\
                            cal_C1XX_MtrTrq_Cmd_Nm_med_neg_fp,cal_C1XX_MtrTrq_Cmd_Nm_high_neg_fp);  //6

                    strcat(return_message,temp_return_message);


            /*   All Done - fill it up with  N_A_num  (69-10-10-9-6 = 34) */

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num);   //4
                    strcat(return_message,temp_return_message);

                            get_DTCs1();

                            strcat(return_message,dtc1_return_message);


                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500mS ensure message transmit is completed, before using sciSend again.
                    while(system_msec_clock < system_msec_clock_temp);

                    strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    strcpy(sbuf_tx_main,"\r\n");
                    strcat(sbuf_tx_main,return_message);
                    strcat(sbuf_tx_main,"\r\n");

                            sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                    {
                        case CIB:
                            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                            {
                               transmit_str_485(return_message);
                            }
                        break;

                        case WEB:
                            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                            {
                                transmit_str_485(return_message);
                            }
                        break;
                    }



            // ------------------------------------------------------------- Step 12 - Clean up   DONE \/

            // turn off Ign
            //      clrbit(p1reg,7);    /* set Product Ign to off    29MAR12 L.Cronk */


                    ign1_status = OFF;

                    gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */

            //      Engine_on_Signal = 0;  // end in warm init mode
            //      speed_flag = 0;       // set current to 0 amps for FORD -- don't use warm init (-1)
                                         // because it makes 'main' do OSV measure until speed > -1  NO OSV
        break;
        }  // end case TARGET_C1XX

        case TARGET_9BXX:
        {
        sprintf(dtc1_return_message,"Haven't been written yet.");

        strcat(return_message,dtc1_return_message);

        strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

        strcpy(sbuf_tx_main,"\r\n");
        strcat(sbuf_tx_main,return_message);
        strcat(sbuf_tx_main,"\r\n");

                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

        switch(scilinREG_is_CIB_or_Monitor_or_WEB)
        {
            case CIB:
                if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                {
                   transmit_str_485(return_message);
                }
            break;

            case WEB:
                if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                {
                    transmit_str_485(return_message);
                }
            break;
        }

// ------------------------------------------------------------- Step 9 - Clean up   DONE \/

// turn off Ign
//      clrbit(p1reg,7);    /* set Product Ign to off    29MAR12 L.Cronk */

        ign1_status = OFF;

        gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */
//      Engine_on_Signal = 0;  // end in warm init mode
//      speed_flag = 0;       // set current to 0 amps for FORD -- don't use warm init (-1)
                             // because it makes 'main' do OSV measure until speed > -1  NO OSV
            break;
        }       // end case TARGET_9BXX

        case TARGET_FCA_ADAS:
        {
            //  F C A __ A D A S    F U N C T I O N A L S ------------------------------

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

            // ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

            // -------------------------------------------      ign1_status = WARM;
                    ign1_status = WARM;
                    ign2_status = WARM;


                    system_msec_clock_temp = system_msec_clock + 7000;  // wait 7 Sec, wait for temp sensor to acclimate
                    while(system_msec_clock < system_msec_clock_temp);


            // ------------------------------------------------------------- Step 2 - Clr DTCs \/
                    // ************ CLEAR CAN1 DTC's ******************

                    ECU1_XCP_reply_index = 1;

                    ECU1_clear_DTCs_flag = 1; // set flag for ISR

                    canTransmit(canREG1, FCA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    // ************ CLEAR CAN2 DTC's ******************

                    ECU2_XCP_reply_index = 1;

                    ECU2_clear_DTCs_flag = 1; // set flag for ISR

                    canTransmit(canREG2, FCA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU2_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    ECU2_XCP_reply_index = 0;
                    ECU2_clear_DTCs_flag = 0; // done...clr flag for ISR

                    // ************ END clear DTC's ******************


            // ------------------------------------------------------------- Step 3 - Request/store one time perimetrics \/
                    // set up torque value, not going back to main so initate all steps here


                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]


                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();
                    parse_can2_data();

            // New B-CIB using floats for stoarage and printing


                    //   C A N  1
                    cal1_FCA_BattVltg_fp = can1_FCA_BattVltg_fp;                                    //  1       Battery Voltage
                    cal1_FCA_Temperature_fp = can1_FCA_Temperature_fp;                              //  2       Ecu Temperature Filtered
                    cal1_FCA_DigT1_fp = can1_FCA_DigT1_fp;                                          //  3       Handwheel channel a trq
                    cal1_FCA_DigT2_fp = can1_FCA_DigT2_fp;                                          //  4       Handwheel channel b trq
                    cal1_FCA_MtrCurrQax_fp = can1_FCA_MtrCurrQax_fp;                                //  5       Motor Current Measurement
                    cal1_FCA_SystemState_byt = can1_FCA_SystemState_byt;                            //  6       System State
                    cal1_FCA_HwTrq_HwNm_fp = can1_FCA_HwTrq_HwNm_fp;                                //  7       Handwheel Tq total
                    cal1_FCA_Abs_Hw_Pos_fp = can1_FCA_Abs_Hw_Pos_fp;                                //  8       Handwheel Angle ABS

                    //   C A N   2
                    cal2_FCA_BattVltg_fp = can2_FCA_BattVltg_fp;                                    //  1       Battery Voltage
                    cal2_FCA_Temperature_fp = can2_FCA_Temperature_fp;                              //  2       Ecu Temperature Filtered
                    cal2_FCA_DigT1_fp = can2_FCA_DigT1_fp;                                          //  3       Handwheel channel a trq
                    cal2_FCA_DigT2_fp = can2_FCA_DigT2_fp;                                          //  4       Handwheel channel b trq
                    cal2_FCA_MtrCurrQax_fp = can2_FCA_MtrCurrQax_fp;                                //  5       Motor Current Measurement
                    cal2_FCA_SystemState_byt = can2_FCA_SystemState_byt;                            //  6       System State
                    cal2_FCA_HwTrq_HwNm_fp = can2_FCA_HwTrq_HwNm_fp;                                //  7       Handwheel Tq total
                    cal2_FCA_Abs_Hw_Pos_fp = can2_FCA_Abs_Hw_Pos_fp;                                //  8       Handwheel Angle ABS

            // ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perimetrics -- sent_data_array_pos_0nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig(); // not necesary to trig(), but echo results to debug port is useful to monitor progress
                                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in positive direction for low value functional.

                    ign1_status = NORMAL;   // put in run mode to output current.
                    ign2_status = NORMAL;   // put in run mode to output current.

                    torque_value_case_index = pos_p5nm;   // pos .5nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_p5nm); // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);


                    cal1_FCA_MtrCurrQax_low_pos_fp      = 0.0;      // initial to zero
                    cal1_FCA_HwTrq_HwNm_low_pos_fp      = 0.0;

                    cal2_FCA_MtrCurrQax_low_pos_fp      = 0.0;
                    cal2_FCA_HwTrq_HwNm_low_pos_fp      = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FCA_MtrCurrQax_low_pos_fp += can1_FCA_MtrCurrQax_fp;
                    cal1_FCA_HwTrq_HwNm_low_pos_fp += can1_FCA_HwTrq_HwNm_fp;

                    }

                    cal1_FCA_MtrCurrQax_low_pos_fp = cal1_FCA_MtrCurrQax_low_pos_fp / 10.0;
                    cal1_FCA_HwTrq_HwNm_low_pos_fp = cal1_FCA_HwTrq_HwNm_low_pos_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FCA_MtrCurrQax_low_pos_fp += can2_FCA_MtrCurrQax_fp;
                    cal2_FCA_HwTrq_HwNm_low_pos_fp += can2_FCA_HwTrq_HwNm_fp;

                    }

                    cal2_FCA_MtrCurrQax_low_pos_fp = cal2_FCA_MtrCurrQax_low_pos_fp / 10.0;
                    cal2_FCA_HwTrq_HwNm_low_pos_fp = cal2_FCA_HwTrq_HwNm_low_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in negative direction for low value functional.

                    torque_value_case_index = neg_p5nm;   // neg .5nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_neg_p5nm); // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FCA_MtrCurrQax_low_neg_fp = 0.0;
                    cal1_FCA_HwTrq_HwNm_low_neg_fp = 0.0;

                    cal2_FCA_MtrCurrQax_low_neg_fp = 0.0;
                    cal2_FCA_HwTrq_HwNm_low_neg_fp = 0.0;

            // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FCA_MtrCurrQax_low_neg_fp += can1_FCA_MtrCurrQax_fp;
                    cal1_FCA_HwTrq_HwNm_low_neg_fp += can1_FCA_HwTrq_HwNm_fp;

                    }

                    cal1_FCA_MtrCurrQax_low_neg_fp = cal1_FCA_MtrCurrQax_low_neg_fp / 10.0;
                    cal1_FCA_HwTrq_HwNm_low_neg_fp = cal1_FCA_HwTrq_HwNm_low_neg_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FCA_MtrCurrQax_low_neg_fp += can2_FCA_MtrCurrQax_fp;
                    cal2_FCA_HwTrq_HwNm_low_neg_fp += can2_FCA_HwTrq_HwNm_fp;

                    }

                    cal2_FCA_MtrCurrQax_low_neg_fp = cal2_FCA_MtrCurrQax_low_neg_fp / 10.0;
                    cal2_FCA_HwTrq_HwNm_low_neg_fp = cal2_FCA_HwTrq_HwNm_low_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/
                  // 2.00nm torque in positive direction for med value functional.

                    torque_value_case_index = pos_2p00nm;   // pos 2.0nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_2p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FCA_MtrCurrQax_med_pos_fp = 0.0;
                    cal1_FCA_HwTrq_HwNm_med_pos_fp = 0.0;
                    //cal_C1XX_MtrTrq_Cmd_Nm_med_pos_fp = 0.0;

                    cal2_FCA_MtrCurrQax_med_pos_fp = 0.0;
                    cal2_FCA_HwTrq_HwNm_med_pos_fp = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FCA_MtrCurrQax_med_pos_fp += can1_FCA_MtrCurrQax_fp;
                    cal1_FCA_HwTrq_HwNm_med_pos_fp += can1_FCA_HwTrq_HwNm_fp;

                    }

                    cal1_FCA_MtrCurrQax_med_pos_fp = cal1_FCA_MtrCurrQax_med_pos_fp / 10.0;
                    cal1_FCA_HwTrq_HwNm_med_pos_fp = cal1_FCA_HwTrq_HwNm_med_pos_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FCA_MtrCurrQax_med_pos_fp += can2_FCA_MtrCurrQax_fp;
                    cal2_FCA_HwTrq_HwNm_med_pos_fp += can2_FCA_HwTrq_HwNm_fp;

                    }

                    cal2_FCA_MtrCurrQax_med_pos_fp = cal2_FCA_MtrCurrQax_med_pos_fp / 10.0;
                    cal2_FCA_HwTrq_HwNm_med_pos_fp = cal2_FCA_HwTrq_HwNm_med_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/
                    // 2.00nm torque in negative direction for med value functional.

                    torque_value_case_index = neg_2p00nm;   // neg 2.0nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_neg_2p00nm);    // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FCA_MtrCurrQax_med_neg_fp = 0.0;
                    cal1_FCA_HwTrq_HwNm_med_neg_fp = 0.0;

                    cal2_FCA_MtrCurrQax_med_neg_fp = 0.0;
                    cal2_FCA_HwTrq_HwNm_med_neg_fp = 0.0;

            // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FCA_MtrCurrQax_med_neg_fp += can1_FCA_MtrCurrQax_fp;
                    cal1_FCA_HwTrq_HwNm_med_neg_fp += can1_FCA_HwTrq_HwNm_fp;

                    }

                    cal1_FCA_MtrCurrQax_med_neg_fp = cal1_FCA_MtrCurrQax_med_neg_fp / 10.0;
                    cal1_FCA_HwTrq_HwNm_med_neg_fp = cal1_FCA_HwTrq_HwNm_med_neg_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FCA_MtrCurrQax_med_neg_fp += can2_FCA_MtrCurrQax_fp;
                    cal2_FCA_HwTrq_HwNm_med_neg_fp += can2_FCA_HwTrq_HwNm_fp;

                    }

                    cal2_FCA_MtrCurrQax_med_neg_fp = cal2_FCA_MtrCurrQax_med_neg_fp / 10.0;
                    cal2_FCA_HwTrq_HwNm_med_neg_fp = cal2_FCA_HwTrq_HwNm_med_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/
                  // 4.00nm torque in positive direction only high value functional.

                    torque_value_case_index = pos_4p00nm;   // pos 4.0nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FCA_MtrCurrQax_high_pos_fp = 0.0;
                    cal1_FCA_HwTrq_HwNm_high_pos_fp = 0.0;

                    cal2_FCA_MtrCurrQax_high_pos_fp = 0.0;
                    cal2_FCA_HwTrq_HwNm_high_pos_fp = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FCA_MtrCurrQax_high_pos_fp += can1_FCA_MtrCurrQax_fp;
                    cal1_FCA_HwTrq_HwNm_high_pos_fp += can1_FCA_HwTrq_HwNm_fp;

                    }

                    cal1_FCA_MtrCurrQax_high_pos_fp = cal1_FCA_MtrCurrQax_high_pos_fp / 10.0;
                    cal1_FCA_HwTrq_HwNm_high_pos_fp = cal1_FCA_HwTrq_HwNm_high_pos_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FCA_MtrCurrQax_high_pos_fp += can2_FCA_MtrCurrQax_fp;
                    cal2_FCA_HwTrq_HwNm_high_pos_fp += can2_FCA_HwTrq_HwNm_fp;

                    }

                    cal2_FCA_MtrCurrQax_high_pos_fp = cal2_FCA_MtrCurrQax_high_pos_fp / 10.0;
                    cal2_FCA_HwTrq_HwNm_high_pos_fp = cal2_FCA_HwTrq_HwNm_high_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/
                  // 4.00nm torque in negative direction only high value functional.

                    torque_value_case_index = neg_4p00nm;   // neg 4.0nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_neg_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FCA_MtrCurrQax_high_neg_fp = 0.0;
                    cal1_FCA_HwTrq_HwNm_high_neg_fp = 0.0;

                    cal2_FCA_MtrCurrQax_high_neg_fp = 0.0;
                    cal2_FCA_HwTrq_HwNm_high_neg_fp = 0.0;

                    // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FCA_MtrCurrQax_high_neg_fp += can1_FCA_MtrCurrQax_fp;
                    cal1_FCA_HwTrq_HwNm_high_neg_fp += can1_FCA_HwTrq_HwNm_fp;

                    }

                    cal1_FCA_MtrCurrQax_high_neg_fp = cal1_FCA_MtrCurrQax_high_neg_fp / 10.0;
                    cal1_FCA_HwTrq_HwNm_high_neg_fp = cal1_FCA_HwTrq_HwNm_high_neg_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FCA_MtrCurrQax_high_neg_fp += can2_FCA_MtrCurrQax_fp;
                    cal2_FCA_HwTrq_HwNm_high_neg_fp += can2_FCA_HwTrq_HwNm_fp;

                    }

                    cal2_FCA_MtrCurrQax_high_neg_fp = cal2_FCA_MtrCurrQax_high_neg_fp / 10.0;
                    cal2_FCA_HwTrq_HwNm_high_neg_fp = cal2_FCA_HwTrq_HwNm_high_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 10 - Done testing current return to 0 amps    \/
                  // 0.00nm torque in positive direction.

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]


            // ------------------------------------------------------------- Step 11 - print out results \/
                    /* max up to 23 parameters at a time, sprintf function max   -- Using K2xx format, temp_return_message[]    19MAR12 L.Cronk  */
                    /*  69 parameters + DTCs  -- full unused with N_A_num.       */

// CAN1
                    sprintf(return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,",\
                            cal1_FCA_BattVltg_fp,cal1_FCA_Temperature_fp,\
                            cal1_FCA_DigT1_fp,cal1_FCA_DigT2_fp,\
                            cal1_FCA_MtrCurrQax_fp,cal1_FCA_SystemState_byt,\
                            cal1_FCA_HwTrq_HwNm_fp,cal1_FCA_Abs_Hw_Pos_fp);     // 8

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal1_FCA_MtrCurrQax_low_pos_fp,cal1_FCA_MtrCurrQax_med_pos_fp,\
                            cal1_FCA_MtrCurrQax_high_pos_fp,cal1_FCA_MtrCurrQax_low_neg_fp,\
                            cal1_FCA_MtrCurrQax_med_neg_fp,cal1_FCA_MtrCurrQax_high_neg_fp,\
                            cal1_FCA_HwTrq_HwNm_low_pos_fp,cal1_FCA_HwTrq_HwNm_med_pos_fp,\
                            cal1_FCA_HwTrq_HwNm_high_pos_fp,cal1_FCA_HwTrq_HwNm_low_neg_fp,\
                            cal1_FCA_HwTrq_HwNm_med_neg_fp,cal1_FCA_HwTrq_HwNm_high_neg_fp);  // 20

                    strcat(return_message,temp_return_message);

//CAN2
                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,",\
                            cal2_FCA_BattVltg_fp,cal2_FCA_Temperature_fp,\
                            cal2_FCA_DigT1_fp,cal2_FCA_DigT2_fp,\
                            cal2_FCA_MtrCurrQax_fp,cal2_FCA_SystemState_byt,\
                            cal2_FCA_HwTrq_HwNm_fp,cal2_FCA_Abs_Hw_Pos_fp);     // 28

                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal2_FCA_MtrCurrQax_low_pos_fp,cal2_FCA_MtrCurrQax_med_pos_fp,\
                            cal2_FCA_MtrCurrQax_high_pos_fp,cal2_FCA_MtrCurrQax_low_neg_fp,\
                            cal2_FCA_MtrCurrQax_med_neg_fp,cal2_FCA_MtrCurrQax_high_neg_fp,\
                            cal2_FCA_HwTrq_HwNm_low_pos_fp,cal2_FCA_HwTrq_HwNm_med_pos_fp,\
                            cal2_FCA_HwTrq_HwNm_high_pos_fp,cal2_FCA_HwTrq_HwNm_low_neg_fp,\
                            cal2_FCA_HwTrq_HwNm_med_neg_fp,cal2_FCA_HwTrq_HwNm_high_neg_fp);  // 40

                    strcat(return_message,temp_return_message);

            /*   All Done - fill it up with  N_A_num  (69-10-10-9 = 34) */

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //9
                    strcat(return_message,temp_return_message);

//                          get_DTCs1();
//
//                          strcat(return_message,dtc1_return_message);

                    get_DTCs1();

                // append CAN1 [1-7], "0" at #77 field and CAN2 [1-7] DTCs to return_message

                    strcat(return_message,dtc1_return_message);
                    strcat(return_message,"0,");

                    get_DTCs2();

                    strcat(return_message,dtc2_return_message);

                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500mS ensure message transmit is completed, before using sciSend again.
                    while(system_msec_clock < system_msec_clock_temp);

                    strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    strcpy(sbuf_tx_main,"\r\n");
                    strcat(sbuf_tx_main,return_message);
                    strcat(sbuf_tx_main,"\r\n");

                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                    {
                        case CIB:
                            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                            {
                               transmit_str_485(return_message);
                            }
                        break;

                        case WEB:
                            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                            {
                                transmit_str_485(return_message);
                            }
                        break;
                    }

            // ------------------------------------------------------------- Step 12 - Clean up   DONE \/

            // turn off Ign
                    ign1_status = OFF;
                    ign2_status = OFF;

                    gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */
        break;
        }       // end case TARGET_FCA_ADAS

        case TARGET_CD391_ADAS:
        {
            //  F O R D __ A D A S    F U N C T I O N A L S ------------------------------

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

            // ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

            // -------------------------------------------      ign1_status = WARM;
            //      Engine_on_Signal = 0;   // put product in warm init No current output


                    system_msec_clock_temp = system_msec_clock + 7000;  // wait 7 Sec, wait for temp sensor to acclimate
                    while(system_msec_clock < system_msec_clock_temp);


            // ------------------------------------------------------------- Step 2 - Clr DTCs \/
                    // ************ CLEAR CAN1 DTC's ******************

                    ECU1_XCP_reply_index = 1;

                    ECU1_clear_DTCs_flag = 1; // set flag for ISR

                    canTransmit(canREG1, FORD_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);   // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    // ************ CLEAR CAN2 DTC's ******************

                    ECU2_XCP_reply_index = 1;

                    ECU2_clear_DTCs_flag = 1; // set flag for ISR

                    canTransmit(canREG2, FORD_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);   // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU2_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    ECU2_XCP_reply_index = 0;
                    ECU2_clear_DTCs_flag = 0; // done...clr flag for ISR

                    // ************ END clear DTC's ******************


            // ------------------------------------------------------------- Step 3 - Request/store one time perimetrics \/
                    // set up torque value, not going back to main so initate all steps here

                    if(manufacturing_TOC == YES)
                    {
                        tester_present_enable_flag = 0; // stop tester present message

                        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                        while(system_msec_clock < system_msec_clock_temp);



                        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                        canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                    }
                    else
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();
                    parse_can2_data();

            // New B-CIB using floats for stoarage and printing


                    //   C A N  1
                    cal1_FORD_BattVltg_fp = can1_FORD_BattVltg_fp;                                  //  1       Battery Voltage
                    cal1_FORD_Temperature_fp = can1_FORD_Temperature_fp;                                //  2       Ecu Temperature Filtered
                    cal1_FORD_DigT1_fp = can1_FORD_DigT1_fp;                                        //  3       Handwheel channel a trq
                    cal1_FORD_DigT2_fp = can1_FORD_DigT2_fp;                                        //  4       Handwheel channel b trq
                    cal1_FORD_MtrCurrQax_fp = can1_FORD_MtrCurrQax_fp;                              //  5       Motor Current Measurement
                    cal1_FORD_SystemState_byt = can1_FORD_SystemState_byt;                          //  6       System State
                    cal1_FORD_HwTrq_HwNm_fp = can1_FORD_HwTrq_HwNm_fp;                              //  7       Handwheel Tq total
                    cal1_FORD_Abs_Hw_Pos_fp = can1_FORD_Abs_Hw_Pos_fp;                              //  8       Handwheel Angle ABS

                    //   C A N   2
                    cal2_FORD_BattVltg_fp = can2_FORD_BattVltg_fp;                                  //  1       Battery Voltage
                    cal2_FORD_Temperature_fp = can2_FORD_Temperature_fp;                                //  2       Ecu Temperature Filtered
                    cal2_FORD_DigT1_fp = can2_FORD_DigT1_fp;                                        //  3       Handwheel channel a trq
                    cal2_FORD_DigT2_fp = can2_FORD_DigT2_fp;                                        //  4       Handwheel channel b trq
                    cal2_FORD_MtrCurrQax_fp = can2_FORD_MtrCurrQax_fp;                              //  5       Motor Current Measurement
                    cal2_FORD_SystemState_byt = can2_FORD_SystemState_byt;                          //  6       System State
                    cal2_FORD_HwTrq_HwNm_fp = can2_FORD_HwTrq_HwNm_fp;                              //  7       Handwheel Tq total
                    cal2_FORD_Abs_Hw_Pos_fp = can2_FORD_Abs_Hw_Pos_fp;                              //  8       Handwheel Angle ABS

            // ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perimetrics -- sent_data_array_pos_0nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig(); // not necesary to trig(), but echo results to debug port is useful to monitor progress
                                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1
                    if(manufacturing_TOC == YES)
                    {
                        tester_present_enable_flag = 0; // stop tester present message

                        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                        while(system_msec_clock < system_msec_clock_temp);

                        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                        canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                    }
                    else
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }
                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in positive direction for low value functional.

                    ign1_status = NORMAL;   // put in run mode to output current.
                    ign2_status = NORMAL;   // put in run mode to output current.

                    if(manufacturing_TOC == YES)
                    {
                        tester_present_enable_flag = 0; // stop tester present message

                        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                        while(system_msec_clock < system_msec_clock_temp);

                        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                        canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);
                    }
                    else
                    {
                        torque_value_case_index = pos_2p00nm;   // pos_2p00nm nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_2p00nm);   // calc and stuff edge times into sent_edge_event_time[][]
                    }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);


                    cal1_FORD_MtrCurrQax_low_pos_fp         = 0.0;      // initial to zero
                    cal1_FORD_HwTrq_HwNm_low_pos_fp         = 0.0;
                    cal1_FORD_Batt_Current_low_pos_fp       = 0.0;

                    cal2_FORD_MtrCurrQax_low_pos_fp     = 0.0;
                    cal2_FORD_HwTrq_HwNm_low_pos_fp     = 0.0;
                    cal2_FORD_Batt_Current_low_pos_fp   = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FORD_MtrCurrQax_low_pos_fp += can1_FORD_MtrCurrQax_fp;
                    cal1_FORD_HwTrq_HwNm_low_pos_fp += can1_FORD_HwTrq_HwNm_fp;
                    cal1_FORD_Batt_Current_low_pos_fp += can1_FORD_Batt_Current_fp;

                    }

                    cal1_FORD_MtrCurrQax_low_pos_fp = cal1_FORD_MtrCurrQax_low_pos_fp / 10.0;
                    cal1_FORD_HwTrq_HwNm_low_pos_fp = cal1_FORD_HwTrq_HwNm_low_pos_fp / 10.0;
                    cal1_FORD_Batt_Current_low_pos_fp = cal1_FORD_Batt_Current_low_pos_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FORD_MtrCurrQax_low_pos_fp += can2_FORD_MtrCurrQax_fp;
                    cal2_FORD_HwTrq_HwNm_low_pos_fp += can2_FORD_HwTrq_HwNm_fp;
                    cal2_FORD_Batt_Current_low_pos_fp += can2_FORD_Batt_Current_fp;

                    }

                    cal2_FORD_MtrCurrQax_low_pos_fp = cal2_FORD_MtrCurrQax_low_pos_fp / 10.0;
                    cal2_FORD_HwTrq_HwNm_low_pos_fp = cal2_FORD_HwTrq_HwNm_low_pos_fp / 10.0;
                    cal2_FORD_Batt_Current_low_pos_fp = cal2_FORD_Batt_Current_low_pos_fp / 10.0;


            // ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1
                            if(manufacturing_TOC == YES)
                            {
                                tester_present_enable_flag = 0; // stop tester present message

                                system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                                while(system_msec_clock < system_msec_clock_temp);

                                ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                                canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                            }
                            else
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }




                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in negative direction for low value functional.

                    if(manufacturing_TOC == YES)
                    {
                        tester_present_enable_flag = 0; // stop tester present message

                        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                        while(system_msec_clock < system_msec_clock_temp);

                        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                        canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);
                    }
                    else
                    {
                        torque_value_case_index = neg_2p00nm;   // neg_2p00nm nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_neg_2p00nm);    // calc and stuff edge times into sent_edge_event_time[][]
                    }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FORD_MtrCurrQax_low_neg_fp = 0.0;
                    cal1_FORD_HwTrq_HwNm_low_neg_fp = 0.0;
                    cal1_FORD_Batt_Current_low_neg_fp = 0.0;


                    cal2_FORD_MtrCurrQax_low_neg_fp = 0.0;
                    cal2_FORD_HwTrq_HwNm_low_neg_fp = 0.0;
                    cal2_FORD_Batt_Current_low_neg_fp = 0.0;


            // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FORD_MtrCurrQax_low_neg_fp += can1_FORD_MtrCurrQax_fp;
                    cal1_FORD_HwTrq_HwNm_low_neg_fp += can1_FORD_HwTrq_HwNm_fp;
                    cal1_FORD_Batt_Current_low_neg_fp += can1_FORD_Batt_Current_fp;

                    }

                    cal1_FORD_MtrCurrQax_low_neg_fp = cal1_FORD_MtrCurrQax_low_neg_fp / 10.0;
                    cal1_FORD_HwTrq_HwNm_low_neg_fp = cal1_FORD_HwTrq_HwNm_low_neg_fp / 10.0;
                    cal1_FORD_Batt_Current_low_neg_fp = cal1_FORD_Batt_Current_low_neg_fp / 10.0;


            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FORD_MtrCurrQax_low_neg_fp += can2_FORD_MtrCurrQax_fp;
                    cal2_FORD_HwTrq_HwNm_low_neg_fp += can2_FORD_HwTrq_HwNm_fp;
                    cal2_FORD_Batt_Current_low_neg_fp += can2_FORD_Batt_Current_fp;

                    }

                    cal2_FORD_MtrCurrQax_low_neg_fp = cal2_FORD_MtrCurrQax_low_neg_fp / 10.0;
                    cal2_FORD_HwTrq_HwNm_low_neg_fp = cal2_FORD_HwTrq_HwNm_low_neg_fp / 10.0;
                    cal2_FORD_Batt_Current_low_neg_fp = cal2_FORD_Batt_Current_low_neg_fp / 10.0;


            // ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1
                            if(manufacturing_TOC == YES)
                            {
                                tester_present_enable_flag = 0; // stop tester present message

                                system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                                while(system_msec_clock < system_msec_clock_temp);

                                ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                                canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                            }
                            else
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/
                  // 2.00nm torque in positive direction for med value functional.

                    if(manufacturing_TOC == YES)
                    {
                        tester_present_enable_flag = 0; // stop tester present message

                        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                        while(system_msec_clock < system_msec_clock_temp);

                        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                        canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);
                    }
                    else
                    {
                        torque_value_case_index = pos_4p00nm;   // pos_4p00nm nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]
                    }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FORD_MtrCurrQax_med_pos_fp = 0.0;
                    cal1_FORD_HwTrq_HwNm_med_pos_fp = 0.0;
                    cal1_FORD_Batt_Current_med_pos_fp = 0.0;

                    cal2_FORD_MtrCurrQax_med_pos_fp = 0.0;
                    cal2_FORD_HwTrq_HwNm_med_pos_fp = 0.0;
                    cal2_FORD_Batt_Current_med_pos_fp = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FORD_MtrCurrQax_med_pos_fp += can1_FORD_MtrCurrQax_fp;
                    cal1_FORD_HwTrq_HwNm_med_pos_fp += can1_FORD_HwTrq_HwNm_fp;
                    cal1_FORD_Batt_Current_med_pos_fp += can1_FORD_Batt_Current_fp;

                    }

                    cal1_FORD_MtrCurrQax_med_pos_fp = cal1_FORD_MtrCurrQax_med_pos_fp / 10.0;
                    cal1_FORD_HwTrq_HwNm_med_pos_fp = cal1_FORD_HwTrq_HwNm_med_pos_fp / 10.0;
                    cal1_FORD_Batt_Current_med_pos_fp = cal1_FORD_Batt_Current_med_pos_fp / 10.0;


            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FORD_MtrCurrQax_med_pos_fp += can2_FORD_MtrCurrQax_fp;
                    cal2_FORD_HwTrq_HwNm_med_pos_fp += can2_FORD_HwTrq_HwNm_fp;
                    cal2_FORD_Batt_Current_med_pos_fp += can2_FORD_Batt_Current_fp;

                    }

                    cal2_FORD_MtrCurrQax_med_pos_fp = cal2_FORD_MtrCurrQax_med_pos_fp / 10.0;
                    cal2_FORD_HwTrq_HwNm_med_pos_fp = cal2_FORD_HwTrq_HwNm_med_pos_fp / 10.0;
                    cal2_FORD_Batt_Current_med_pos_fp = cal2_FORD_Batt_Current_med_pos_fp / 10.0;


            // ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                            if(manufacturing_TOC == YES)
                            {
                                tester_present_enable_flag = 0; // stop tester present message

                                system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                                while(system_msec_clock < system_msec_clock_temp);

                                ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                                canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                            }
                            else
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/
                    // 2.00nm torque in negative direction for med value functional.

                    if(manufacturing_TOC == YES)
                    {
                        tester_present_enable_flag = 0; // stop tester present message

                        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                        while(system_msec_clock < system_msec_clock_temp);

                        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                        canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);
                    }
                    else
                    {
                        torque_value_case_index = neg_4p00nm;   // neg_4p00nm nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_neg_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]
                    }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FORD_MtrCurrQax_med_neg_fp = 0.0;
                    cal1_FORD_HwTrq_HwNm_med_neg_fp = 0.0;
                    cal1_FORD_Batt_Current_med_neg_fp = 0.0;

                    cal2_FORD_MtrCurrQax_med_neg_fp = 0.0;
                    cal2_FORD_HwTrq_HwNm_med_neg_fp = 0.0;
                    cal2_FORD_Batt_Current_med_neg_fp = 0.0;


            // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FORD_MtrCurrQax_med_neg_fp += can1_FORD_MtrCurrQax_fp;
                    cal1_FORD_HwTrq_HwNm_med_neg_fp += can1_FORD_HwTrq_HwNm_fp;
                    cal1_FORD_Batt_Current_med_neg_fp += can1_FORD_Batt_Current_fp;

                    }

                    cal1_FORD_MtrCurrQax_med_neg_fp = cal1_FORD_MtrCurrQax_med_neg_fp / 10.0;
                    cal1_FORD_HwTrq_HwNm_med_neg_fp = cal1_FORD_HwTrq_HwNm_med_neg_fp / 10.0;
                    cal1_FORD_Batt_Current_med_neg_fp = cal1_FORD_Batt_Current_med_neg_fp / 10.0;


            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FORD_MtrCurrQax_med_neg_fp += can2_FORD_MtrCurrQax_fp;
                    cal2_FORD_HwTrq_HwNm_med_neg_fp += can2_FORD_HwTrq_HwNm_fp;
                    cal2_FORD_Batt_Current_med_neg_fp += can2_FORD_Batt_Current_fp;

                    }

                    cal2_FORD_MtrCurrQax_med_neg_fp = cal2_FORD_MtrCurrQax_med_neg_fp / 10.0;
                    cal2_FORD_HwTrq_HwNm_med_neg_fp = cal2_FORD_HwTrq_HwNm_med_neg_fp / 10.0;
                    cal2_FORD_Batt_Current_med_neg_fp = cal2_FORD_Batt_Current_med_neg_fp / 10.0;


            // ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1
                            if(manufacturing_TOC == YES)
                            {
                                tester_present_enable_flag = 0; // stop tester present message

                                system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                                while(system_msec_clock < system_msec_clock_temp);

                                ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                                canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                            }
                            else
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/
                  // 4.00nm torque in positive direction only high value functional.

                    if(manufacturing_TOC == YES)
                    {
                        tester_present_enable_flag = 0; // stop tester present message

                        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                        while(system_msec_clock < system_msec_clock_temp);

                        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                        canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm);
                    }
                    else
                    {
                        torque_value_case_index = pos_6p00nm;   // pos_6p00nm nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_6p00nm);   // calc and stuff edge times into sent_edge_event_time[][]
                    }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FORD_MtrCurrQax_high_pos_fp = 0.0;
                    cal1_FORD_HwTrq_HwNm_high_pos_fp = 0.0;
                    cal1_FORD_Batt_Current_high_pos_fp = 0.0;

                    cal2_FORD_MtrCurrQax_high_pos_fp = 0.0;
                    cal2_FORD_HwTrq_HwNm_high_pos_fp = 0.0;
                    cal2_FORD_Batt_Current_high_pos_fp = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FORD_MtrCurrQax_high_pos_fp += can1_FORD_MtrCurrQax_fp;
                    cal1_FORD_HwTrq_HwNm_high_pos_fp += can1_FORD_HwTrq_HwNm_fp;
                    cal1_FORD_Batt_Current_high_pos_fp += can1_FORD_Batt_Current_fp;

                    }

                    cal1_FORD_MtrCurrQax_high_pos_fp = cal1_FORD_MtrCurrQax_high_pos_fp / 10.0;
                    cal1_FORD_HwTrq_HwNm_high_pos_fp = cal1_FORD_HwTrq_HwNm_high_pos_fp / 10.0;
                    cal1_FORD_Batt_Current_high_pos_fp = cal1_FORD_Batt_Current_high_pos_fp / 10.0;


            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FORD_MtrCurrQax_high_pos_fp += can2_FORD_MtrCurrQax_fp;
                    cal2_FORD_HwTrq_HwNm_high_pos_fp += can2_FORD_HwTrq_HwNm_fp;
                    cal2_FORD_Batt_Current_high_pos_fp += can2_FORD_Batt_Current_fp;

                    }

                    cal2_FORD_MtrCurrQax_high_pos_fp = cal2_FORD_MtrCurrQax_high_pos_fp / 10.0;
                    cal2_FORD_HwTrq_HwNm_high_pos_fp = cal2_FORD_HwTrq_HwNm_high_pos_fp / 10.0;
                    cal2_FORD_Batt_Current_high_pos_fp = cal2_FORD_Batt_Current_high_pos_fp / 10.0;


            // ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1
                            if(manufacturing_TOC == YES)
                            {
                                tester_present_enable_flag = 0; // stop tester present message

                                system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                                while(system_msec_clock < system_msec_clock_temp);

                                ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                                canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                            }
                            else
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);
            // ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/
                  // 4.00nm torque in negative direction only high value functional.

                    if(manufacturing_TOC == YES)
                    {
                        tester_present_enable_flag = 0; // stop tester present message

                        system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                        while(system_msec_clock < system_msec_clock_temp);

                        ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                        canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm);
                    }
                    else
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_neg_6p00nm);   // calc and stuff edge times into sent_edge_event_time[][]
                    }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FORD_MtrCurrQax_high_neg_fp = 0.0;
                    cal1_FORD_HwTrq_HwNm_high_neg_fp = 0.0;
                    cal1_FORD_Batt_Current_high_neg_fp = 0.0;

                    cal2_FORD_MtrCurrQax_high_neg_fp = 0.0;
                    cal2_FORD_HwTrq_HwNm_high_neg_fp = 0.0;
                    cal2_FORD_Batt_Current_high_neg_fp = 0.0;


                    // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FORD_MtrCurrQax_high_neg_fp += can1_FORD_MtrCurrQax_fp;
                    cal1_FORD_HwTrq_HwNm_high_neg_fp += can1_FORD_HwTrq_HwNm_fp;
                    cal1_FORD_Batt_Current_high_neg_fp += can1_FORD_Batt_Current_fp;

                    }

                    cal1_FORD_MtrCurrQax_high_neg_fp = cal1_FORD_MtrCurrQax_high_neg_fp / 10.0;
                    cal1_FORD_HwTrq_HwNm_high_neg_fp = cal1_FORD_HwTrq_HwNm_high_neg_fp / 10.0;
                    cal1_FORD_Batt_Current_high_neg_fp = cal1_FORD_Batt_Current_high_neg_fp / 10.0;


            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FORD_MtrCurrQax_high_neg_fp += can2_FORD_MtrCurrQax_fp;
                    cal2_FORD_HwTrq_HwNm_high_neg_fp += can2_FORD_HwTrq_HwNm_fp;
                    cal2_FORD_Batt_Current_high_neg_fp += can2_FORD_Batt_Current_fp;

                    }

                    cal2_FORD_MtrCurrQax_high_neg_fp = cal2_FORD_MtrCurrQax_high_neg_fp / 10.0;
                    cal2_FORD_HwTrq_HwNm_high_neg_fp = cal2_FORD_HwTrq_HwNm_high_neg_fp / 10.0;
                    cal2_FORD_Batt_Current_high_neg_fp = cal2_FORD_Batt_Current_high_neg_fp / 10.0;


            // ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1
                            if(manufacturing_TOC == YES)
                            {
                                tester_present_enable_flag = 0; // stop tester present message

                                system_msec_clock_temp = system_msec_clock + 25;    // wait 10 in case tester present message has been sent for a reply to be received
                                while(system_msec_clock < system_msec_clock_temp);

                                ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                                canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                            }
                            else
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }
                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 10 - Done testing current return to 0 amps    \/
                  // 0.00nm torque in positive direction.


                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]


            // ------------------------------------------------------------- Step 11 - print out results \/
                    /* max up to 23 parameters at a time, sprintf function max   -- Using K2xx format, temp_return_message[]    19MAR12 L.Cronk  */
                    /*  69 parameters + DTCs  -- full unused with N_A_num.       */

// CAN1
                    sprintf(return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,",\
                            cal1_FORD_BattVltg_fp,cal1_FORD_Temperature_fp,\
                            cal1_FORD_DigT1_fp,cal1_FORD_DigT2_fp,\
                            cal1_FORD_MtrCurrQax_fp,cal1_FORD_SystemState_byt,\
                            cal1_FORD_HwTrq_HwNm_fp,cal1_FORD_Abs_Hw_Pos_fp);       // 8

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal1_FORD_MtrCurrQax_low_pos_fp,cal1_FORD_MtrCurrQax_med_pos_fp,\
                            cal1_FORD_MtrCurrQax_high_pos_fp,cal1_FORD_MtrCurrQax_low_neg_fp,\
                            cal1_FORD_MtrCurrQax_med_neg_fp,cal1_FORD_MtrCurrQax_high_neg_fp,\
                            cal1_FORD_HwTrq_HwNm_low_pos_fp,cal1_FORD_HwTrq_HwNm_med_pos_fp,\
                            cal1_FORD_HwTrq_HwNm_high_pos_fp,cal1_FORD_HwTrq_HwNm_low_neg_fp,\
                            cal1_FORD_HwTrq_HwNm_med_neg_fp,cal1_FORD_HwTrq_HwNm_high_neg_fp);  // 20

                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal1_FORD_Batt_Current_low_pos_fp,cal1_FORD_Batt_Current_med_pos_fp,\
                            cal1_FORD_Batt_Current_high_pos_fp,cal1_FORD_Batt_Current_low_neg_fp,\
                            cal1_FORD_Batt_Current_med_neg_fp,cal1_FORD_Batt_Current_high_neg_fp);  // 26

                    strcat(return_message,temp_return_message);

//CAN2
                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,",\
                            cal2_FORD_BattVltg_fp,cal2_FORD_Temperature_fp,\
                            cal2_FORD_DigT1_fp,cal2_FORD_DigT2_fp,\
                            cal2_FORD_MtrCurrQax_fp,cal2_FORD_SystemState_byt,\
                            cal2_FORD_HwTrq_HwNm_fp,cal2_FORD_Abs_Hw_Pos_fp);       // 34

                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal2_FORD_MtrCurrQax_low_pos_fp,cal2_FORD_MtrCurrQax_med_pos_fp,\
                            cal2_FORD_MtrCurrQax_high_pos_fp,cal2_FORD_MtrCurrQax_low_neg_fp,\
                            cal2_FORD_MtrCurrQax_med_neg_fp,cal2_FORD_MtrCurrQax_high_neg_fp,\
                            cal2_FORD_HwTrq_HwNm_low_pos_fp,cal2_FORD_HwTrq_HwNm_med_pos_fp,\
                            cal2_FORD_HwTrq_HwNm_high_pos_fp,cal2_FORD_HwTrq_HwNm_low_neg_fp,\
                            cal2_FORD_HwTrq_HwNm_med_neg_fp,cal2_FORD_HwTrq_HwNm_high_neg_fp);  // 46

                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal2_FORD_Batt_Current_low_pos_fp,cal2_FORD_Batt_Current_med_pos_fp,\
                            cal2_FORD_Batt_Current_high_pos_fp,cal2_FORD_Batt_Current_low_neg_fp,\
                            cal2_FORD_Batt_Current_med_neg_fp,cal2_FORD_Batt_Current_high_neg_fp);  // 52

                    strcat(return_message,temp_return_message);


            /*   All Done - fill it up with  N_A_num  (69-10-7 = 52) */

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);                           //7
                    strcat(return_message,temp_return_message);


//                          get_DTCs1();
//
//                          strcat(return_message,dtc1_return_message);

                    get_DTCs1();

                // append CAN1 [1-7], "0" at #77 field and CAN2 [1-7] DTCs to return_message

                    strcat(return_message,dtc1_return_message);
                    strcat(return_message,"0,");

                    get_DTCs2();

                    strcat(return_message,dtc2_return_message);

                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500mS ensure message transmit is completed, before using sciSend again.
                    while(system_msec_clock < system_msec_clock_temp);

                    strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    strcpy(sbuf_tx_main,"\r\n");
                    strcat(sbuf_tx_main,return_message);
                    strcat(sbuf_tx_main,"\r\n");

                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                    {
                        case CIB:
                            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                            {
                               transmit_str_485(return_message);
                            }
                        break;

                        case WEB:
                            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                            {
                                transmit_str_485(return_message);
                            }
                        break;
                    }

            // ------------------------------------------------------------- Step 12 - Clean up   DONE \/

            // turn off Ign
            //      clrbit(p1reg,7);    /* set Product Ign to off    29MAR12 L.Cronk */


                    ign1_status = OFF;
                    ign2_status = OFF;

                    gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */

            //      Engine_on_Signal = 0;  // end in warm init mode
            //      speed_flag = 0;       // set current to 0 amps for FORD -- don't use warm init (-1)
                                         // because it makes 'main' do OSV measure until speed > -1  NO OSV
        break;
        }       // end case TARGET_CD391_ADAS

        case TARGET_G2KCA_ADAS:
        {
            //  G2 2 K C A __ A D A S    F U N C T I O N A L S ------------------------------

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

            // ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

            // -------------------------------------------      ign1_status = WARM;
                    ign1_status = WARM;
                    ign2_status = WARM;

                    system_msec_clock_temp = system_msec_clock + 7000;  // wait 7 Sec, wait for temp sensor to acclimate
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 2 - Clr DTCs \/
                    // ************ CLEAR CAN1 DTC's ******************

                    ECU1_XCP_reply_index = 1;

                    ECU1_clear_DTCs_flag = 1; // set flag for ISR

                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    // ************ CLEAR CAN2 DTC's ******************

                    ECU2_XCP_reply_index = 1;

                    ECU2_clear_DTCs_flag = 1; // set flag for ISR

                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU2_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    ECU1_XCP_reply_index = 0;
                    ECU1_clear_DTCs_flag = 0; // done...clr flag for ISR
                    ECU2_XCP_reply_index = 0;
                    ECU2_clear_DTCs_flag = 0; // done...clr flag for ISR

                    // ************ END clear DTC's ******************


            // ------------------------------------------------------------- Step 3 - Request/store one time perimetrics \/
                    // set up torque value, not going back to main so initate all steps here

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();
                    parse_can2_data();

            // New B-CIB using floats for stoarage and printing


                    //   C A N  1
                    cal1_G2KCA_BattVltg_fp = can1_G2KCA_BattVltg_fp;                                    //  1       Battery Voltage
                    cal1_G2KCA_Temperature_fp = can1_G2KCA_Temperature_fp;                              //  2       Ecu Temperature Filtered
                    cal1_G2KCA_DigT1_fp = can1_G2KCA_DigT1_fp;                                          //  3       Handwheel channel a trq
                    cal1_G2KCA_DigT2_fp = can1_G2KCA_DigT2_fp;                                          //  4       Handwheel channel b trq
                    cal1_G2KCA_MtrCurrQax_fp = can1_G2KCA_MtrCurrQax_fp;                                //  5       Motor Current Measurement
                    cal1_G2KCA_SystemState_byt = can1_G2KCA_SystemState_byt;                            //  6       System State
                    cal1_G2KCA_HwTrq_HwNm_fp = can1_G2KCA_HwTrq_HwNm_fp;                                //  7       Handwheel Tq total
                    cal1_G2KCA_Abs_Hw_Pos_fp = can1_G2KCA_Abs_Hw_Pos_fp;                                //  8       Handwheel Angle ABS

                    //   C A N   2
                    cal2_G2KCA_BattVltg_fp = can2_G2KCA_BattVltg_fp;                                    //  1       Battery Voltage
                    cal2_G2KCA_Temperature_fp = can2_G2KCA_Temperature_fp;                              //  2       Ecu Temperature Filtered
                    cal2_G2KCA_DigT1_fp = can2_G2KCA_DigT1_fp;                                          //  3       Handwheel channel a trq
                    cal2_G2KCA_DigT2_fp = can2_G2KCA_DigT2_fp;                                          //  4       Handwheel channel b trq
                    cal2_G2KCA_MtrCurrQax_fp = can2_G2KCA_MtrCurrQax_fp;                                //  5       Motor Current Measurement
                    cal2_G2KCA_SystemState_byt = can2_G2KCA_SystemState_byt;                            //  6       System State
                    cal2_G2KCA_HwTrq_HwNm_fp = can2_G2KCA_HwTrq_HwNm_fp;                                //  7       Handwheel Tq total
                    cal2_G2KCA_Abs_Hw_Pos_fp = can2_G2KCA_Abs_Hw_Pos_fp;                                //  8       Handwheel Angle ABS

            // ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perimetrics -- sent_data_array_pos_0nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig(); // not necesary to trig(), but echo results to debug port is useful to monitor progress
                                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in positive direction for low value functional.

                    ign1_status = NORMAL;   // put in run mode to output current.
                    ign2_status = NORMAL;   // put in run mode to output current.

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_p5nm;   // pos .5nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_p5nm); // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);


                    cal1_G2KCA_MtrCurrQax_low_pos_fp        = 0.0;      // initial to zero
                    cal1_G2KCA_HwTrq_HwNm_low_pos_fp        = 0.0;

                    cal2_G2KCA_MtrCurrQax_low_pos_fp        = 0.0;
                    cal2_G2KCA_HwTrq_HwNm_low_pos_fp        = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_G2KCA_MtrCurrQax_low_pos_fp += can1_G2KCA_MtrCurrQax_fp;
                    cal1_G2KCA_HwTrq_HwNm_low_pos_fp += can1_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal1_G2KCA_MtrCurrQax_low_pos_fp = cal1_G2KCA_MtrCurrQax_low_pos_fp / 10.0;
                    cal1_G2KCA_HwTrq_HwNm_low_pos_fp = cal1_G2KCA_HwTrq_HwNm_low_pos_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_G2KCA_MtrCurrQax_low_pos_fp += can2_G2KCA_MtrCurrQax_fp;
                    cal2_G2KCA_HwTrq_HwNm_low_pos_fp += can2_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal2_G2KCA_MtrCurrQax_low_pos_fp = cal2_G2KCA_MtrCurrQax_low_pos_fp / 10.0;
                    cal2_G2KCA_HwTrq_HwNm_low_pos_fp = cal2_G2KCA_HwTrq_HwNm_low_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU1_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in negative direction for low value functional.

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_p5nm;   // neg .5nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_neg_p5nm); // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_G2KCA_MtrCurrQax_low_neg_fp = 0.0;
                    cal1_G2KCA_HwTrq_HwNm_low_neg_fp = 0.0;

                    cal2_G2KCA_MtrCurrQax_low_neg_fp = 0.0;
                    cal2_G2KCA_HwTrq_HwNm_low_neg_fp = 0.0;

            // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_G2KCA_MtrCurrQax_low_neg_fp += can1_G2KCA_MtrCurrQax_fp;
                    cal1_G2KCA_HwTrq_HwNm_low_neg_fp += can1_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal1_G2KCA_MtrCurrQax_low_neg_fp = cal1_G2KCA_MtrCurrQax_low_neg_fp / 10.0;
                    cal1_G2KCA_HwTrq_HwNm_low_neg_fp = cal1_G2KCA_HwTrq_HwNm_low_neg_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_G2KCA_MtrCurrQax_low_neg_fp += can2_G2KCA_MtrCurrQax_fp;
                    cal2_G2KCA_HwTrq_HwNm_low_neg_fp += can2_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal2_G2KCA_MtrCurrQax_low_neg_fp = cal2_G2KCA_MtrCurrQax_low_neg_fp / 10.0;
                    cal2_G2KCA_HwTrq_HwNm_low_neg_fp = cal2_G2KCA_HwTrq_HwNm_low_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/
                  // 2.00nm torque in positive direction for med value functional.

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_2p00nm;   // pos 2.0nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_2p00nm);   // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_G2KCA_MtrCurrQax_med_pos_fp = 0.0;
                    cal1_G2KCA_HwTrq_HwNm_med_pos_fp = 0.0;

                    cal2_G2KCA_MtrCurrQax_med_pos_fp = 0.0;
                    cal2_G2KCA_HwTrq_HwNm_med_pos_fp = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_G2KCA_MtrCurrQax_med_pos_fp += can1_G2KCA_MtrCurrQax_fp;
                    cal1_G2KCA_HwTrq_HwNm_med_pos_fp += can1_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal1_G2KCA_MtrCurrQax_med_pos_fp = cal1_G2KCA_MtrCurrQax_med_pos_fp / 10.0;
                    cal1_G2KCA_HwTrq_HwNm_med_pos_fp = cal1_G2KCA_HwTrq_HwNm_med_pos_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_G2KCA_MtrCurrQax_med_pos_fp += can2_G2KCA_MtrCurrQax_fp;
                    cal2_G2KCA_HwTrq_HwNm_med_pos_fp += can2_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal2_G2KCA_MtrCurrQax_med_pos_fp = cal2_G2KCA_MtrCurrQax_med_pos_fp / 10.0;
                    cal2_G2KCA_HwTrq_HwNm_med_pos_fp = cal2_G2KCA_HwTrq_HwNm_med_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/
                    // 2.00nm torque in negative direction for med value functional.


                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = neg_2p00nm;   // neg 2.0nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_neg_2p00nm);    // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_G2KCA_MtrCurrQax_med_neg_fp = 0.0;
                    cal1_G2KCA_HwTrq_HwNm_med_neg_fp = 0.0;

                    cal2_G2KCA_MtrCurrQax_med_neg_fp = 0.0;
                    cal2_G2KCA_HwTrq_HwNm_med_neg_fp = 0.0;

            // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_G2KCA_MtrCurrQax_med_neg_fp += can1_G2KCA_MtrCurrQax_fp;
                    cal1_G2KCA_HwTrq_HwNm_med_neg_fp += can1_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal1_G2KCA_MtrCurrQax_med_neg_fp = cal1_G2KCA_MtrCurrQax_med_neg_fp / 10.0;
                    cal1_G2KCA_HwTrq_HwNm_med_neg_fp = cal1_G2KCA_HwTrq_HwNm_med_neg_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_G2KCA_MtrCurrQax_med_neg_fp += can2_G2KCA_MtrCurrQax_fp;
                    cal2_G2KCA_HwTrq_HwNm_med_neg_fp += can2_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal2_G2KCA_MtrCurrQax_med_neg_fp = cal2_G2KCA_MtrCurrQax_med_neg_fp / 10.0;
                    cal2_G2KCA_HwTrq_HwNm_med_neg_fp = cal2_G2KCA_HwTrq_HwNm_med_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/
                  // 4.00nm torque in positive direction only high value functional.


                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_4p00nm;   // pos 4.0nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_G2KCA_MtrCurrQax_high_pos_fp = 0.0;
                    cal1_G2KCA_HwTrq_HwNm_high_pos_fp = 0.0;

                    cal2_G2KCA_MtrCurrQax_high_pos_fp = 0.0;
                    cal2_G2KCA_HwTrq_HwNm_high_pos_fp = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_G2KCA_MtrCurrQax_high_pos_fp += can1_G2KCA_MtrCurrQax_fp;
                    cal1_G2KCA_HwTrq_HwNm_high_pos_fp += can1_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal1_G2KCA_MtrCurrQax_high_pos_fp = cal1_G2KCA_MtrCurrQax_high_pos_fp / 10.0;
                    cal1_G2KCA_HwTrq_HwNm_high_pos_fp = cal1_G2KCA_HwTrq_HwNm_high_pos_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_G2KCA_MtrCurrQax_high_pos_fp += can2_G2KCA_MtrCurrQax_fp;
                    cal2_G2KCA_HwTrq_HwNm_high_pos_fp += can2_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal2_G2KCA_MtrCurrQax_high_pos_fp = cal2_G2KCA_MtrCurrQax_high_pos_fp / 10.0;
                    cal2_G2KCA_HwTrq_HwNm_high_pos_fp = cal2_G2KCA_HwTrq_HwNm_high_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/
                  // 4.00nm torque in negative direction only high value functional.


                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = neg_4p00nm;   // neg 4.0nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_neg_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_G2KCA_MtrCurrQax_high_neg_fp = 0.0;
                    cal1_G2KCA_HwTrq_HwNm_high_neg_fp = 0.0;

                    cal2_G2KCA_MtrCurrQax_high_neg_fp = 0.0;
                    cal2_G2KCA_HwTrq_HwNm_high_neg_fp = 0.0;

                    // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_G2KCA_MtrCurrQax_high_neg_fp += can1_G2KCA_MtrCurrQax_fp;
                    cal1_G2KCA_HwTrq_HwNm_high_neg_fp += can1_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal1_G2KCA_MtrCurrQax_high_neg_fp = cal1_G2KCA_MtrCurrQax_high_neg_fp / 10.0;
                    cal1_G2KCA_HwTrq_HwNm_high_neg_fp = cal1_G2KCA_HwTrq_HwNm_high_neg_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_G2KCA_MtrCurrQax_high_neg_fp += can2_G2KCA_MtrCurrQax_fp;
                    cal2_G2KCA_HwTrq_HwNm_high_neg_fp += can2_G2KCA_HwTrq_HwNm_fp;

                    }

                    cal2_G2KCA_MtrCurrQax_high_neg_fp = cal2_G2KCA_MtrCurrQax_high_neg_fp / 10.0;
                    cal2_G2KCA_HwTrq_HwNm_high_neg_fp = cal2_G2KCA_HwTrq_HwNm_high_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
                        ECU2_XCP_reply_index = 20;

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear
                        ECU2_clear_DTCs_flag =0;

                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 100;  // make it happen index
                        ECU2_XCP_reply_index = 100;

    /*  Nexteer Session command  */
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                        canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                        canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 10 - Done testing current return to 0 amps    \/
                  // 0.00nm torque in positive direction.

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

            // ------------------------------------------------------------- Step 11 - print out results \/
                    /* max up to 23 parameters at a time, sprintf function max   -- Using K2xx format, temp_return_message[]    19MAR12 L.Cronk  */
                    /*  69 parameters + DTCs  -- full unused with N_A_num.       */

// CAN1
                    sprintf(return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,",\
                            cal1_G2KCA_BattVltg_fp,cal1_G2KCA_Temperature_fp,\
                            cal1_G2KCA_DigT1_fp,cal1_G2KCA_DigT2_fp,\
                            cal1_G2KCA_MtrCurrQax_fp,cal1_G2KCA_SystemState_byt,\
                            cal1_G2KCA_HwTrq_HwNm_fp,cal1_G2KCA_Abs_Hw_Pos_fp);     // 8

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal1_G2KCA_MtrCurrQax_low_pos_fp,cal1_G2KCA_MtrCurrQax_med_pos_fp,\
                            cal1_G2KCA_MtrCurrQax_high_pos_fp,cal1_G2KCA_MtrCurrQax_low_neg_fp,\
                            cal1_G2KCA_MtrCurrQax_med_neg_fp,cal1_G2KCA_MtrCurrQax_high_neg_fp,\
                            cal1_G2KCA_HwTrq_HwNm_low_pos_fp,cal1_G2KCA_HwTrq_HwNm_med_pos_fp,\
                            cal1_G2KCA_HwTrq_HwNm_high_pos_fp,cal1_G2KCA_HwTrq_HwNm_low_neg_fp,\
                            cal1_G2KCA_HwTrq_HwNm_med_neg_fp,cal1_G2KCA_HwTrq_HwNm_high_neg_fp);  // 20

                    strcat(return_message,temp_return_message);

//CAN2
                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,",\
                            cal2_G2KCA_BattVltg_fp,cal2_G2KCA_Temperature_fp,\
                            cal2_G2KCA_DigT1_fp,cal2_G2KCA_DigT2_fp,\
                            cal2_G2KCA_MtrCurrQax_fp,cal2_G2KCA_SystemState_byt,\
                            cal2_G2KCA_HwTrq_HwNm_fp,cal2_G2KCA_Abs_Hw_Pos_fp);     // 28

                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal2_G2KCA_MtrCurrQax_low_pos_fp,cal2_G2KCA_MtrCurrQax_med_pos_fp,\
                            cal2_G2KCA_MtrCurrQax_high_pos_fp,cal2_G2KCA_MtrCurrQax_low_neg_fp,\
                            cal2_G2KCA_MtrCurrQax_med_neg_fp,cal2_G2KCA_MtrCurrQax_high_neg_fp,\
                            cal2_G2KCA_HwTrq_HwNm_low_pos_fp,cal2_G2KCA_HwTrq_HwNm_med_pos_fp,\
                            cal2_G2KCA_HwTrq_HwNm_high_pos_fp,cal2_G2KCA_HwTrq_HwNm_low_neg_fp,\
                            cal2_G2KCA_HwTrq_HwNm_med_neg_fp,cal2_G2KCA_HwTrq_HwNm_high_neg_fp);  // 40

                    strcat(return_message,temp_return_message);


            /*   All Done - fill it up with  N_A_num  (69-10-10-9 = 34) */

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //9
                    strcat(return_message,temp_return_message);


//                          get_DTCs1();
//
//                          strcat(return_message,dtc1_return_message);

                    get_DTCs1();

                    // Phil wants to give product a second try.
                    if(dtc1[0][0] == 0xFF)
                    {
                        get_DTCs1();
                    }

                // append CAN1 [1-7], "0" at #77 field and CAN2 [1-7] DTCs to return_message

                    strcat(return_message,dtc1_return_message);
                    strcat(return_message,"0,");

                    get_DTCs2();

                    // Phil wants to give product a second try.
                    if(dtc2[0][0] == 0xFF)
                    {
                        get_DTCs2();
                    }

                    strcat(return_message,dtc2_return_message);

                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500mS ensure message transmit is completed, before using sciSend again.
                    while(system_msec_clock < system_msec_clock_temp);

                    strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    strcpy(sbuf_tx_main,"\r\n");
                    strcat(sbuf_tx_main,return_message);
                    strcat(sbuf_tx_main,"\r\n");

                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                    {
                        case CIB:
                            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                            {
                               transmit_str_485(return_message);
                            }
                        break;

                        case WEB:
                            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                            {
                                transmit_str_485(return_message);
                            }
                        break;
                            }
            // ------------------------------------------------------------- Step 12 - Clean up   DONE \/

                    ign1_status = OFF;
                    ign2_status = OFF;

                    gioSetBit(hetPORT1, 14, 0); /* turn off Product Ign1 */
                    gioSetBit(hetPORT1, 15, 0); /* turn off Product Ign2 */

                    gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */


        break;
        }   //  end case TARGET_G2KCA_ADAS:

        case TARGET_PSA_CMP:
        {
            //  P S A   C M P     F U N C T I O N A L S ------------------------------

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

            // ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

            // -------------------------------------------      ign1_status = WARM;
                    ign1_status = WARM;

                    system_msec_clock_temp = system_msec_clock + 7000;  // wait 7 Sec, wait for temp sensor to acclimate
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 2 - Clr DTCs \/
                    // ************ CLEAR CAN1 DTC's ******************

                    ECU1_XCP_reply_index = 1;

                    ECU1_clear_DTCs_flag = 1; // set flag for ISR

                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    ECU1_XCP_reply_index = 0;
                    ECU1_clear_DTCs_flag = 0; // done...clr flag for ISR

                    // ************ END clear DTC's ******************


            // ------------------------------------------------------------- Step 3 - Request/store one time parametrics \/
                    // set up torque value, not going back to main so initiate all steps here

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                        /*  Nexteer Session command  */
                        canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                        canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm);

                        system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                        while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                        canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm2);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
                    while((can1_request_index != PSA_CMP_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

            // New B-CIB using floats for storage and printing


                    //   C A N  1
                  cal1_PSA_CMP_BattVltg_fp                  = can1_PSA_CMP_BattVltg_fp;               // can1_dump_err_data 1       Battery Voltage
                  cal1_PSA_CMP_Temperature_fp               = can1_PSA_CMP_Temperature_fp;            // can1_dump_err_data 2       Ecu Temperature Filtered
                  cal1_PSA_CMP_DigT1_fp                     = can1_PSA_CMP_DigT1_fp;                  // can1_dump_err_data 3       Handwheel channel a trq
                  cal1_PSA_CMP_DigT2_fp                     = can1_PSA_CMP_DigT2_fp;                  // can1_dump_err_data 4       Handwheel channel b trq
                  cal1_PSA_CMP_SystemState_byt              = can1_PSA_CMP_SystemState_byt;           // can1_dump_err_data 5       System State
                  cal1_PSA_CMP_MtrCurrQax_fp                = can1_PSA_CMP_MtrCurrQax_fp;             // can1_dump_err_data 6       Motor Current Measurement
                  cal1_PSA_CMP_MtrCurrDax_fp                = can1_PSA_CMP_MtrCurrDax_fp;             // can1_dump_err_data 7       Motor Current Measurement
                  cal1_PSA_CMP_HwTrq_HwNm_fp                = can1_PSA_CMP_HwTrq_HwNm_fp;             // can1_dump_err_data 8       Handwheel Tq total
                  cal1_PSA_CMP_MtrTrqCmd_HwNm_fp            = can1_PSA_CMP_MtrTrqCmd_HwNm_fp;         // can1_dump_err_data 9       Motor Tq Commanded
                  cal1_PSA_CMP_AstMtrTrq_HwNm_fp            = can1_PSA_CMP_AstMtrTrq_HwNm_fp;         // can1_dump_err_data 10      Motor Tq Assist
                  cal1_PSA_CMP_Abs_Hw_Pos_fp                = can1_PSA_CMP_Abs_Hw_Pos_fp;             // can1_dump_err_data 11      Handwheel Abs Position
                  cal1_PSA_CMP_Rel_Hw_Pos_fp                = can1_PSA_CMP_Rel_Hw_Pos_fp;             // can1_dump_err_data 12      Handwheel Rel Position
                  cal1_PSA_CMP_Abs_Hw_Pos_Valid_byt         = can1_PSA_CMP_Abs_Hw_Pos_Valid_byt;      // can1_dump_err_data 13      Handwheel Position Valid
                  cal1_PSA_CMP_MtrPos_fp                    = can1_PSA_CMP_MtrPos_fp;                 // can1_dump_err_data 14      Motor Position
                  cal1_PSA_CMP_ADC_MtrCurr1_fp              = can1_PSA_CMP_ADC_MtrCurr1_fp;           // can1_dump_err_data 15      Motor current ADC 1
                  cal1_PSA_CMP_ADC_MtrCurr2_fp              = can1_PSA_CMP_ADC_MtrCurr2_fp;           // can1_dump_err_data 16      Motor current ADC2



            // ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perimetrics -- sent_data_array_pos_0nm \r\n");
                            sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                trig(); // not necessary to trig(), but echo results to debug port is useful to monitor progress
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                            if(manufacturing_TOC == YES)    // use CAN else use SENT
                            {
                                tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                                tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                                /*  Nexteer Session command  */
                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm);

                                system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                                while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm2);

                            }  // end if(manufacturing_TOC == YES)

                            else    // using SENT signals
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }

                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.10nm torque in positive direction for low value functional.

                    ign1_status = NORMAL;   // put in run mode to output current.

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                    {
                        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                        ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                        /*  Nexteer Session command  */
                        canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                        system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                        while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                        canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_p1nm);

                        system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                        while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                        canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_p1nm2);

                    }  // end if(manufacturing_TOC == YES)

                    else    // using SENT signals
                    {
                        torque_value_case_index = pos_p1nm;   // pos .1nm torque, not used yet, for dynamic call to set torque
                        sent_data_calculation_from_table(sent_data_array_pos_p1nm);  // calc and stuff edge times into sent_edge_event_time[][]
                    }


                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);


                    cal1_PSA_CMP_MtrCurrQax_low_pos_fp        = 0.0;      // initial to zero
                    cal1_PSA_CMP_HwTrq_HwNm_low_pos_fp        = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
                    while((can1_request_index != PSA_CMP_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_PSA_CMP_MtrCurrQax_low_pos_fp += can1_PSA_CMP_MtrCurrQax_fp;
                    cal1_PSA_CMP_HwTrq_HwNm_low_pos_fp += can1_PSA_CMP_HwTrq_HwNm_fp;

                    }

                    cal1_PSA_CMP_MtrCurrQax_low_pos_fp = cal1_PSA_CMP_MtrCurrQax_low_pos_fp / 10.0;
                    cal1_PSA_CMP_HwTrq_HwNm_low_pos_fp = cal1_PSA_CMP_HwTrq_HwNm_low_pos_fp / 10.0;


            // ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig(); // not necessary to trig(), but echo results to debug port is useful to monitor progress
                                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                                if(manufacturing_TOC == YES)    // use CAN else use SENT
                                {
                                    tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                                    tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                                    ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                    ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                                    /*  Nexteer Session command  */
                                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                                    ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm);

                                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm2);

                                }  // end if(manufacturing_TOC == YES)

                                else    // using SENT signals
                                {
                                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                                }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.10nm torque in negative direction for low value functional.

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                     {
                         tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                         tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                         ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                         ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                         /*  Nexteer Session command  */
                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                         system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                         while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                         ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_p1nm);

                         system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                         while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_p1nm2);

                     }  // end if(manufacturing_TOC == YES)

                     else    // using SENT signals
                     {
                         torque_value_case_index = neg_p1nm;   // neg .1nm torque, not used yet, for dynamic call to set torque
                         sent_data_calculation_from_table(sent_data_array_neg_p1nm);  // calc and stuff edge times into sent_edge_event_time[][]
                     }


                     system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                     while(system_msec_clock < system_msec_clock_temp);


                     cal1_PSA_CMP_MtrCurrQax_low_neg_fp        = 0.0;      // initial to zero
                     cal1_PSA_CMP_HwTrq_HwNm_low_neg_fp        = 0.0;

             // gather CAN1 low-amp negaitive conditions
             for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                     {
                     // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                     can1_request_index = 0; // set index to start sequence at case 0 in ISR
             ShiftCAN1();
                     system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
                     while((can1_request_index != PSA_CMP_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                     parse_can1_data();

                     cal1_PSA_CMP_MtrCurrQax_low_neg_fp += can1_PSA_CMP_MtrCurrQax_fp;
                     cal1_PSA_CMP_HwTrq_HwNm_low_neg_fp += can1_PSA_CMP_HwTrq_HwNm_fp;

                     }

                     cal1_PSA_CMP_MtrCurrQax_low_neg_fp = cal1_PSA_CMP_MtrCurrQax_low_neg_fp / 10.0;
                     cal1_PSA_CMP_HwTrq_HwNm_low_neg_fp = cal1_PSA_CMP_HwTrq_HwNm_low_neg_fp / 10.0;


            // ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                            if(manufacturing_TOC == YES)    // use CAN else use SENT
                            {
                                tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                                tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                                /*  Nexteer Session command  */
                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm);

                                system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                                while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm2);

                            }  // end if(manufacturing_TOC == YES)

                            else    // using SENT signals
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }

                system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/
                // 1.00nm torque in positive direction for med value functional.

                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                     {
                         tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                         tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                         ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                         ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                         /*  Nexteer Session command  */
                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                         system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                         while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                         ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_1p00nm);

                         system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                         while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_1p00nm2);

                     }  // end if(manufacturing_TOC == YES)

                     else    // using SENT signals
                     {
                         torque_value_case_index = pos_1p00nm;   // pos 1.00nm torque, not used yet, for dynamic call to set torque
                         sent_data_calculation_from_table(sent_data_array_pos_1p00nm);  // calc and stuff edge times into sent_edge_event_time[][]
                     }


                     system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                     while(system_msec_clock < system_msec_clock_temp);


                     cal1_PSA_CMP_MtrCurrQax_med_pos_fp        = 0.0;      // initial to zero
                     cal1_PSA_CMP_HwTrq_HwNm_med_pos_fp        = 0.0;

                  // gather CAN1 med-amp positive conditions
                  for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                     {
                     // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                     can1_request_index = 0; // set index to start sequence at case 0 in ISR
                  ShiftCAN1();
                     system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
                     while((can1_request_index != PSA_CMP_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                     parse_can1_data();

                     cal1_PSA_CMP_MtrCurrQax_med_pos_fp += can1_PSA_CMP_MtrCurrQax_fp;
                     cal1_PSA_CMP_HwTrq_HwNm_med_pos_fp += can1_PSA_CMP_HwTrq_HwNm_fp;

                     }

                     cal1_PSA_CMP_MtrCurrQax_med_pos_fp = cal1_PSA_CMP_MtrCurrQax_med_pos_fp / 10.0;
                     cal1_PSA_CMP_HwTrq_HwNm_med_pos_fp = cal1_PSA_CMP_HwTrq_HwNm_med_pos_fp / 10.0;


            // ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_1p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                            if(manufacturing_TOC == YES)    // use CAN else use SENT
                            {
                                tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                                tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                                /*  Nexteer Session command  */
                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm);

                                system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                                while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm2);

                            }  // end if(manufacturing_TOC == YES)

                            else    // using SENT signals
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }

                system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/
                    // 1.00nm torque in negative direction for med value functional.


                if(manufacturing_TOC == YES)    // use CAN else use SENT
                 {
                     tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                     tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                     ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                     ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                     /*  Nexteer Session command  */
                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                     system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                     ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_1p00nm);

                     system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                     while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_1p00nm2);

                 }  // end if(manufacturing_TOC == YES)

                 else    // using SENT signals
                 {
                     torque_value_case_index = neg_1p00nm;   // neg 1.00nm torque, not used yet, for dynamic call to set torque
                     sent_data_calculation_from_table(sent_data_array_neg_1p00nm);  // calc and stuff edge times into sent_edge_event_time[][]
                 }


                 system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                 while(system_msec_clock < system_msec_clock_temp);


                 cal1_PSA_CMP_MtrCurrQax_med_neg_fp        = 0.0;      // initial to zero
                 cal1_PSA_CMP_HwTrq_HwNm_med_neg_fp        = 0.0;

                // gather CAN1 med-amp negative conditions
                for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                 {
                 // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                 can1_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN1();
                 system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
                 while((can1_request_index != PSA_CMP_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                 parse_can1_data();

                 cal1_PSA_CMP_MtrCurrQax_med_neg_fp += can1_PSA_CMP_MtrCurrQax_fp;
                 cal1_PSA_CMP_HwTrq_HwNm_med_neg_fp += can1_PSA_CMP_HwTrq_HwNm_fp;

                 }

                 cal1_PSA_CMP_MtrCurrQax_med_neg_fp = cal1_PSA_CMP_MtrCurrQax_med_neg_fp / 10.0;
                 cal1_PSA_CMP_HwTrq_HwNm_med_neg_fp = cal1_PSA_CMP_HwTrq_HwNm_med_neg_fp / 10.0;


            // ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_1p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                            if(manufacturing_TOC == YES)    // use CAN else use SENT
                            {
                                tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                                tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                                /*  Nexteer Session command  */
                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm);

                                system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                                while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm2);

                            }  // end if(manufacturing_TOC == YES)

                            else    // using SENT signals
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/
                  // 2.00nm torque in positive direction only high value functional.


                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                     {
                         tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                         tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                         ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                         ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                         /*  Nexteer Session command  */
                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                         system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                         while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                         ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_2p00nm);

                         system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                         while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_2p00nm2);

                     }  // end if(manufacturing_TOC == YES)

                     else    // using SENT signals
                     {
                         torque_value_case_index = pos_2p00nm;   // pos 2.00nm torque, not used yet, for dynamic call to set torque
                         sent_data_calculation_from_table(sent_data_array_pos_2p00nm);  // calc and stuff edge times into sent_edge_event_time[][]
                     }


                     system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                     while(system_msec_clock < system_msec_clock_temp);


                     cal1_PSA_CMP_MtrCurrQax_high_pos_fp        = 0.0;      // initial to zero
                     cal1_PSA_CMP_HwTrq_HwNm_high_pos_fp        = 0.0;

                  // gather CAN1 high-amp positive conditions
                  for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                     {
                     // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                     can1_request_index = 0; // set index to start sequence at case 0 in ISR
                  ShiftCAN1();
                     system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
                     while((can1_request_index != PSA_CMP_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                     parse_can1_data();

                     cal1_PSA_CMP_MtrCurrQax_high_pos_fp += can1_PSA_CMP_MtrCurrQax_fp;
                     cal1_PSA_CMP_HwTrq_HwNm_high_pos_fp += can1_PSA_CMP_HwTrq_HwNm_fp;

                     }

                     cal1_PSA_CMP_MtrCurrQax_high_pos_fp = cal1_PSA_CMP_MtrCurrQax_high_pos_fp / 10.0;
                     cal1_PSA_CMP_HwTrq_HwNm_high_pos_fp = cal1_PSA_CMP_HwTrq_HwNm_high_pos_fp / 10.0;


            // ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                            if(manufacturing_TOC == YES)    // use CAN else use SENT
                            {
                                tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                                tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                                /*  Nexteer Session command  */
                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm);

                                system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                                while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm2);

                            }  // end if(manufacturing_TOC == YES)

                            else    // using SENT signals
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/
                  // 2.00nm torque in negative direction only high value functional.


                    if(manufacturing_TOC == YES)    // use CAN else use SENT
                     {
                         tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                         tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                         ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                         ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                         /*  Nexteer Session command  */
                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                         system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                         while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                         ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_2p00nm);

                         system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                         while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                         canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_2p00nm2);

                     }  // end if(manufacturing_TOC == YES)

                     else    // using SENT signals
                     {
                         torque_value_case_index = neg_2p00nm;   // neg 2.00nm torque, not used yet, for dynamic call to set torque
                         sent_data_calculation_from_table(sent_data_array_neg_1p00nm);  // calc and stuff edge times into sent_edge_event_time[][]
                     }


                     system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                     while(system_msec_clock < system_msec_clock_temp);


                     cal1_PSA_CMP_MtrCurrQax_high_neg_fp        = 0.0;      // initial to zero
                     cal1_PSA_CMP_HwTrq_HwNm_high_neg_fp        = 0.0;

                    // gather CAN1 high-amp negative conditions
                    for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                     {
                     // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                     can1_request_index = 0; // set index to start sequence at case 0 in ISR
                    ShiftCAN1();
                     system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
                     while((can1_request_index != PSA_CMP_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                     parse_can1_data();

                     cal1_PSA_CMP_MtrCurrQax_high_neg_fp += can1_PSA_CMP_MtrCurrQax_fp;
                     cal1_PSA_CMP_HwTrq_HwNm_high_neg_fp += can1_PSA_CMP_HwTrq_HwNm_fp;

                     }

                     cal1_PSA_CMP_MtrCurrQax_high_neg_fp = cal1_PSA_CMP_MtrCurrQax_high_neg_fp / 10.0;
                     cal1_PSA_CMP_HwTrq_HwNm_high_neg_fp = cal1_PSA_CMP_HwTrq_HwNm_high_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                            if(manufacturing_TOC == YES)    // use CAN else use SENT
                            {
                                tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
                                tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

                                /*  Nexteer Session command  */
                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                                ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm);

                                system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                                while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                                canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm2);

                            }  // end if(manufacturing_TOC == YES)

                            else    // using SENT signals
                            {
                                torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]
                            }

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 10 - Done testing current return to 0 amps    \/
                  // 0.00nm torque in positive direction.

                    torque_value_case_index = pos_0nm;   // zero nm torque, not used yet, for dynamic call to set torque
                    sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

            // ------------------------------------------------------------- Step 11 - print out results \/
                    /* max up to 23 parameters at a time, sprintf function max   -- Using K2xx format, temp_return_message[]    19MAR12 L.Cronk  */
                    /*  69 parameters + DTCs  -- fill unused with N_A_num.       */

// CAN1
                    sprintf(return_message,"%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,%.3f,",\
                            cal1_PSA_CMP_BattVltg_fp,cal1_PSA_CMP_Temperature_fp,\
                            cal1_PSA_CMP_DigT1_fp,cal1_PSA_CMP_DigT2_fp,\
                            cal1_PSA_CMP_SystemState_byt,cal1_PSA_CMP_MtrCurrQax_fp,\
                            cal1_PSA_CMP_MtrCurrDax_fp,cal1_PSA_CMP_HwTrq_HwNm_fp);     // 8

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,%.3f,",\
                            cal1_PSA_CMP_MtrTrqCmd_HwNm_fp,cal1_PSA_CMP_AstMtrTrq_HwNm_fp,\
                            cal1_PSA_CMP_Abs_Hw_Pos_fp,cal1_PSA_CMP_Rel_Hw_Pos_fp,\
                            cal1_PSA_CMP_Abs_Hw_Pos_Valid_byt,cal1_PSA_CMP_MtrPos_fp,\
                            cal1_PSA_CMP_ADC_MtrCurr1_fp,cal1_PSA_CMP_ADC_MtrCurr2_fp);  // 16

                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal1_PSA_CMP_MtrCurrQax_low_pos_fp,cal1_PSA_CMP_MtrCurrQax_med_pos_fp,\
                            cal1_PSA_CMP_MtrCurrQax_high_pos_fp,cal1_PSA_CMP_MtrCurrQax_low_neg_fp,\
                            cal1_PSA_CMP_MtrCurrQax_med_neg_fp,cal1_PSA_CMP_MtrCurrQax_high_neg_fp,\
                            cal1_PSA_CMP_HwTrq_HwNm_low_pos_fp,cal1_PSA_CMP_HwTrq_HwNm_med_pos_fp,\
                            cal1_PSA_CMP_HwTrq_HwNm_high_pos_fp,cal1_PSA_CMP_HwTrq_HwNm_low_neg_fp,\
                            cal1_PSA_CMP_HwTrq_HwNm_med_neg_fp,cal1_PSA_CMP_HwTrq_HwNm_high_neg_fp);  // 28

                    strcat(return_message,temp_return_message);

                    /*   All Done - fill it up with  N_A_num  (28 + 10 + 10 + 10 + 10 + 1= 69) */

                     sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                     N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                     strcat(return_message,temp_return_message);

                     sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                     N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                     strcat(return_message,temp_return_message);

                     sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                     N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                     strcat(return_message,temp_return_message);

                     sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                     N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                     strcat(return_message,temp_return_message);

                     sprintf(temp_return_message,"%d,",\
                     N_A_num);                                                                           //1
                     strcat(return_message,temp_return_message);

                     get_DTCs1();

                     strcat(return_message,dtc1_return_message);

                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500mS ensure message transmit is completed, before using sciSend again.
                    while(system_msec_clock < system_msec_clock_temp);

                    strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                         sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    strcpy(sbuf_tx_main,"\r\n");
                    strcat(sbuf_tx_main,return_message);
                    strcat(sbuf_tx_main,"\r\n");

                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                    {
                        case CIB:
                            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                            {
                               transmit_str_485(return_message);
                            }
                        break;

                        case WEB:
                            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                            {
                                transmit_str_485(return_message);
                            }
                        break;
                    }

            // ------------------------------------------------------------- Step 12 - Clean up   DONE \/

                    ign1_status = OFF;

                    gioSetBit(hetPORT1, 14, 0); /* turn off Product Ign1 */
                    gioSetBit(hetPORT1, 15, 0); /* turn off Product Ign2 */

                    gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */


        break;
        }   //  end case TARGET_PSA_CMP:

        case TARGET_SGMW_CN200:
        {
            //  C N 2 0 0   F U N C T I O N A L S ------------------------------

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

            // ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

            // -------------------------------------------      ign1_status = WARM;
//Phil                    ign1_status = WARM;

                    system_msec_clock_temp = system_msec_clock + 7000;  // wait 7 Sec, wait for temp sensor to acclimate
                    while(system_msec_clock < system_msec_clock_temp);


            // ------------------------------------------------------------- Step 2 - Clr DTCs \/
                    // ************ CLEAR DTC's ******************


                    ECU1_XCP_reply_index = 1;

                    ECU1_clear_DTCs_flag = 1; // set flag for ISR


                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    ECU1_XCP_reply_index = 0;
                    ECU1_clear_DTCs_flag = 0; // done...clr flag for ISR

                    // ************ END clear DTC's ******************


            // ------------------------------------------------------------- Step 3 - Request/store one time parametrics \/
                    // set up torque value, not going back to main so initiate all steps here


                    torque_value_case_index = pos_0nm;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != SGMW_CN200_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

            // New B-CIB using floats for storage and printing
                    //   C A N  1
                  cal1_CN200_BattVltg_fp                = can1_CN200_BattVltg_fp;                     // can1_dump_err_data 1       Battery Voltage
                  cal1_CN200_Temperature_fp             = can1_CN200_Temperature_fp;                  // can1_dump_err_data 2       Ecu Temperature Filtered
                  cal1_CN200_DigT1_HwNm_fp              = can1_CN200_DigT1_HwNm_fp;                   // can1_dump_err_data 3       HwTq 0
                  cal1_CN200_DigT2_HwNm_fp              = can1_CN200_DigT2_HwNm_fp;                   // can1_dump_err_data 4       HwTq 1
                  cal1_CN200_MtrCurrQax_fp              = can1_CN200_MtrCurrQax_fp;                   // can1_dump_err_data 5       Motor Current Measurement
                  cal1_CN200_SystemState_byt            = can1_CN200_SystemState_byt;                 // can1_dump_err_data 6       System State
                  cal1_CN200_HwTrq_HwNm_fp              = can1_CN200_HwTrq_HwNm_fp;                   // can1_dump_err_data 7       Handwheel Tq total
                  cal1_CN200_Abs_Hw_Pos_fp              = can1_CN200_Abs_Hw_Pos_fp;                   // can1_dump_err_data 8       Handwheel Angle
                  cal1_CN200_MotTrq_Crf_fp              = can1_CN200_MotTrq_Crf_fp;                   // can1_dump_err_data 9       MotTrq_Crf
                  cal1_CN200_MotTrq_Mrf_fp              = can1_CN200_MotTrq_Mrf_fp;                   // can1_dump_err_data 10      MotTrq_Mrf
                  cal1_CN200_VehSpd_fp                  = can1_CN200_VehSpd_fp;                       // can1_dump_err_data 11      VehSpd
                  cal1_CN200_Spare2_fp                  = can1_CN200_Spare2_fp;                       // can1_dump_err_data 12      Spair2



            // ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perametrics -- sent_data_array_pos_0nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);



            // ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in positive direction for low value functional.

                    ign1_status = NORMAL;


                    torque_value_case_index = pos_p5nm;   // pos .5nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);


                    cal1_CN200_MtrCurrQax_low_pos_fp = 0.0;
                    cal1_CN200_HwTrq_HwNm_low_pos_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != SGMW_CN200_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_CN200_MtrCurrQax_low_pos_fp += can1_CN200_MtrCurrQax_fp;
                    cal1_CN200_HwTrq_HwNm_low_pos_fp += can1_CN200_HwTrq_HwNm_fp;

                    }

                    cal1_CN200_MtrCurrQax_low_pos_fp = cal1_CN200_MtrCurrQax_low_pos_fp / 10.0;
                    cal1_CN200_HwTrq_HwNm_low_pos_fp = cal1_CN200_HwTrq_HwNm_low_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig(); // not necessary to trig(), but echo results to debug port is useful to monitor progress
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in negative direction for low value functional.


                    torque_value_case_index = neg_p5nm;   // neg .5nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_CN200_MtrCurrQax_low_neg_fp = 0.0;
                    cal1_CN200_HwTrq_HwNm_low_neg_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != SGMW_CN200_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_CN200_MtrCurrQax_low_neg_fp += can1_CN200_MtrCurrQax_fp;
                    cal1_CN200_HwTrq_HwNm_low_neg_fp += can1_CN200_HwTrq_HwNm_fp;

                    }

                    cal1_CN200_MtrCurrQax_low_neg_fp = cal1_CN200_MtrCurrQax_low_neg_fp / 10.0;
                    cal1_CN200_HwTrq_HwNm_low_neg_fp = cal1_CN200_HwTrq_HwNm_low_neg_fp / 10.0;


            // ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);


            // ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/

                  // 1.00nm torque in positive direction for med value functional.  Phil


                    torque_value_case_index = pos_1p00nm;   // pos 1.0nm torque Phil

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_CN200_MtrCurrQax_med_pos_fp = 0.0;
                    cal1_CN200_HwTrq_HwNm_med_pos_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != SGMW_CN200_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_CN200_MtrCurrQax_med_pos_fp += can1_CN200_MtrCurrQax_fp;
                    cal1_CN200_HwTrq_HwNm_med_pos_fp += can1_CN200_HwTrq_HwNm_fp;

                    }

                    cal1_CN200_MtrCurrQax_med_pos_fp = cal1_CN200_MtrCurrQax_med_pos_fp / 10.0;
                    cal1_CN200_HwTrq_HwNm_med_pos_fp = cal1_CN200_HwTrq_HwNm_med_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_1p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/

                  // 1.00nm torque in negative direction for med value functional.  Phil


                    torque_value_case_index = neg_1p00nm;   // neg 1.0nm torque  Phil

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_CN200_MtrCurrQax_med_neg_fp = 0.0;
                    cal1_CN200_HwTrq_HwNm_med_neg_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != SGMW_CN200_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_CN200_MtrCurrQax_med_neg_fp += can1_CN200_MtrCurrQax_fp;
                    cal1_CN200_HwTrq_HwNm_med_neg_fp += can1_CN200_HwTrq_HwNm_fp;

                    }

                    cal1_CN200_MtrCurrQax_med_neg_fp = cal1_CN200_MtrCurrQax_med_neg_fp / 10.0;
                    cal1_CN200_HwTrq_HwNm_med_neg_fp = cal1_CN200_HwTrq_HwNm_med_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_1p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


                    torque_value_case_index = pos_0nm;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/

                  // 2.00nm torque in positive direction only high value functional.


                    torque_value_case_index = pos_2p00nm;   // pos 2.0nm torque  Phil

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_CN200_MtrCurrQax_high_pos_fp = 0.0;
                    cal1_CN200_HwTrq_HwNm_high_pos_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != SGMW_CN200_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_CN200_MtrCurrQax_high_pos_fp += can1_CN200_MtrCurrQax_fp;
                    cal1_CN200_HwTrq_HwNm_high_pos_fp += can1_CN200_HwTrq_HwNm_fp;

                    }

                    cal1_CN200_MtrCurrQax_high_pos_fp = cal1_CN200_MtrCurrQax_high_pos_fp / 10.0;
                    cal1_CN200_HwTrq_HwNm_high_pos_fp = cal1_CN200_HwTrq_HwNm_high_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


                    torque_value_case_index = pos_0nm;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/

                  // 2.00nm torque in negative direction only high value functional.  Phil

                    torque_value_case_index = neg_2p00nm;   // neg 4.0nm torque  Phil

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_CN200_MtrCurrQax_high_neg_fp = 0.0;
                    cal1_CN200_HwTrq_HwNm_high_neg_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != SGMW_CN200_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_CN200_MtrCurrQax_high_neg_fp += can1_CN200_MtrCurrQax_fp;
                    cal1_CN200_HwTrq_HwNm_high_neg_fp += can1_CN200_HwTrq_HwNm_fp;

                    }

                    cal1_CN200_MtrCurrQax_high_neg_fp = cal1_CN200_MtrCurrQax_high_neg_fp / 10.0;
                    cal1_CN200_HwTrq_HwNm_high_neg_fp = cal1_CN200_HwTrq_HwNm_high_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                   torque_value_case_index = pos_0nm;   // zero nm torque

                   set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 10 - Done testing current return to 0 amps    \/

                  // 0.00nm torque in positive direction.

 //   placeholder     torque_value_case_index = 0;   // zero nm torque, not used yet, for dynamic call to set torque
 //                   sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]


            // ------------------------------------------------------------- Step 11 - print out results \/
                    /* max up to 23 parameters at a time, sprintf function max   -- Using K2xx format, temp_return_message[]    19MAR12 L.Cronk  */
                    /*  69 parameters + DTCs  -- full unused with N_A_num.       */

                    sprintf(return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal1_CN200_BattVltg_fp, cal1_CN200_Temperature_fp,\
                            cal1_CN200_DigT1_HwNm_fp,cal1_CN200_DigT2_HwNm_fp,\
                            cal1_CN200_MtrCurrQax_fp,cal1_CN200_SystemState_byt,\
                            cal1_CN200_HwTrq_HwNm_fp,cal1_CN200_Abs_Hw_Pos_fp,\
                            cal1_CN200_MotTrq_Crf_fp,cal1_CN200_MotTrq_Mrf_fp,\
                            cal1_CN200_VehSpd_fp,cal1_CN200_Spare2_fp);      //12
                    /* <23 at a time */

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal1_CN200_MtrCurrQax_low_pos_fp,cal1_CN200_MtrCurrQax_med_pos_fp,\
                            cal1_CN200_MtrCurrQax_high_pos_fp,cal1_CN200_MtrCurrQax_low_neg_fp,\
                            cal1_CN200_MtrCurrQax_med_neg_fp,cal1_CN200_MtrCurrQax_high_neg_fp,\
                            cal1_CN200_HwTrq_HwNm_low_pos_fp,cal1_CN200_HwTrq_HwNm_med_pos_fp,\
                            cal1_CN200_HwTrq_HwNm_high_pos_fp,cal1_CN200_HwTrq_HwNm_low_neg_fp,\
                            cal1_CN200_HwTrq_HwNm_med_neg_fp,cal1_CN200_HwTrq_HwNm_high_neg_fp);  //12

                    strcat(return_message,temp_return_message);

            /*   All Done - fill it up with  N_A_num  (69-10-10-10-10-5 = 45) */

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);                                           //5
                    strcat(return_message,temp_return_message);

                            get_DTCs1();

                            strcat(return_message,dtc1_return_message);

                    strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    strcpy(sbuf_tx_main,"\r\n");
                    strcat(sbuf_tx_main,return_message);
                    strcat(sbuf_tx_main,"\r\n");

                            sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                    {
                        case CIB:
                            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                            {
                               transmit_str_485(return_message);
                            }
                        break;

                        case WEB:
                            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                            {
                                transmit_str_485(return_message);
                            }
                        break;
                    }

            // ------------------------------------------------------------- Step 12 - Clean up   DONE \/

                    ign1_status = OFF;
                    ign2_status = OFF;

                    gioSetBit(hetPORT1, 14, 0); /* turn off Product Ign1 */
                    gioSetBit(hetPORT1, 15, 0); /* turn off Product Ign2 */

                    gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */


         break;
         }   // end case TARGET_SGMW_CN200

        case TARGET_FORD_T3_T6:
        {
            //  F O R D   T 3   -   T 6      F U N C T I O N A L S ------------------------------

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

            // ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

            // -------------------------------------------      ign1_status = WARM;
//                    ign1_status = WARM;
//                    ign2_status = WARM;

                                ign1_status = NORMAL;   // put in run mode to output current.
                                ign2_status = NORMAL;   // put in run mode to output current.

                    system_msec_clock_temp = system_msec_clock + 7000;  // wait 7 Sec, wait for temp sensor to acclimate
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 2 - Clr DTCs \/
                    // ************ CLEAR CAN1 DTC's ******************

                    ECU1_XCP_reply_index = 1;

                    ECU1_clear_DTCs_flag = 1; // set flag for ISR

                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    // ************ CLEAR CAN2 DTC's ******************

                    ECU2_XCP_reply_index = 1;

                    ECU2_clear_DTCs_flag = 1; // set flag for ISR

                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU2_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    ECU1_XCP_reply_index = 0;
                    ECU1_clear_DTCs_flag = 0; // done...clr flag for ISR
                    ECU2_XCP_reply_index = 0;
                    ECU2_clear_DTCs_flag = 0; // done...clr flag for ISR

                    // ************ END clear DTC's ******************


            // ------------------------------------------------------------- Step 3 - Request/store one time perimetrics \/
                    // set up torque value, not going back to main so initiate all steps here

                    torque_value_case_index = pos_0nm;   // zero nm torque, call to set torque
                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 1000 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();
                    parse_can2_data();

            // New B-CIB using floats for storage and printing


                    //   C A N  1    E C U 1
                    cal1_FORD_T3_ECU1_BattVltg_fp = can1_FORD_T3_ECU1_BattVltg_fp;                                    //  1       Battery Voltage
                    cal1_FORD_T3_ECU1_Temperature_fp = can1_FORD_T3_ECU1_Temperature_fp;                              //  2       Ecu Temperature Filtered
                    cal1_FORD_T3_ECU1_DigT1_fp = can1_FORD_T3_ECU1_DigT1_fp;                                          //  3       Handwheel channel a trq
                    cal1_FORD_T3_ECU1_DigT2_fp = can1_FORD_T3_ECU1_DigT2_fp;                                          //  4       Handwheel channel b trq
                    cal1_FORD_T3_ECU1_MtrCurrQax_fp = can1_FORD_T3_ECU1_MtrCurrQax_fp;                                //  5       Motor Current Measurement
                    cal1_FORD_T3_ECU1_SystemState_byt = can1_FORD_T3_ECU1_SystemState_byt;                            //  6       System State
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_fp = can1_FORD_T3_ECU1_HwTrq_HwNm_fp;                                //  7       Handwheel Tq total
                    cal1_FORD_T3_ECU1_Abs_Hw_Pos_fp = can1_FORD_T3_ECU1_Abs_Hw_Pos_fp;                                //  8       Handwheel Angle ABS

                    //   C A N   1    E C U 2
                    cal2_FORD_T3_ECU2_BattVltg_fp = can1_FORD_T3_ECU2_BattVltg_fp;                                    //  1       Battery Voltage
                    cal2_FORD_T3_ECU2_Temperature_fp = can1_FORD_T3_ECU2_Temperature_fp;                              //  2       Ecu Temperature Filtered
                    cal2_FORD_T3_ECU2_DigT1_fp = can1_FORD_T3_ECU2_DigT1_fp;                                          //  3       Handwheel channel a trq
                    cal2_FORD_T3_ECU2_DigT2_fp = can1_FORD_T3_ECU2_DigT2_fp;                                          //  4       Handwheel channel b trq
                    cal2_FORD_T3_ECU2_MtrCurrQax_fp = can1_FORD_T3_ECU2_MtrCurrQax_fp;                                //  5       Motor Current Measurement
                    cal2_FORD_T3_ECU2_SystemState_byt = can1_FORD_T3_ECU2_SystemState_byt;                            //  6       System State
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_fp = can1_FORD_T3_ECU2_HwTrq_HwNm_fp;                                //  7       Handwheel Tq total
                    cal2_FORD_T3_ECU2_Abs_Hw_Pos_fp = can1_FORD_T3_ECU2_Abs_Hw_Pos_fp;                                //  8       Handwheel Angle ABS

            // ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perimetrics -- sent_data_array_pos_0nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig(); // not necesary to trig(), but echo results to debug port is useful to monitor progress
                                sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


                    torque_value_case_index = pos_0nm;   // zero nm torque, call to set torque
                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.

                    system_msec_clock_temp = system_msec_clock + 1000;   // wait 500  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in positive direction for low value functional.

                    ign1_status = NORMAL;   // put in run mode to output current.
                    ign2_status = NORMAL;   // put in run mode to output current.

                    torque_value_case_index = pos_p5nm;   // pos .5nm torque, call to set torque
                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);


                    cal1_FORD_T3_ECU1_MtrCurrQax_low_pos_fp        = 0.0;      // initial to zero
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_low_pos_fp        = 0.0;

                    cal2_FORD_T3_ECU2_MtrCurrQax_low_pos_fp        = 0.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_low_pos_fp        = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();
debug_can1_Qax[loop_cnt_d] = can1_FORD_T3_ECU1_MtrCurrQax_fp;

                    cal1_FORD_T3_ECU1_MtrCurrQax_low_pos_fp += can1_FORD_T3_ECU1_MtrCurrQax_fp;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_low_pos_fp += can1_FORD_T3_ECU1_HwTrq_HwNm_fp;

                    }

                    cal1_FORD_T3_ECU1_MtrCurrQax_low_pos_fp = cal1_FORD_T3_ECU1_MtrCurrQax_low_pos_fp / 10.0;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_low_pos_fp = cal1_FORD_T3_ECU1_HwTrq_HwNm_low_pos_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();
debug_can2_Qax[loop_cnt_d] = can1_FORD_T3_ECU2_MtrCurrQax_fp;

                    cal2_FORD_T3_ECU2_MtrCurrQax_low_pos_fp += can1_FORD_T3_ECU2_MtrCurrQax_fp;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_low_pos_fp += can1_FORD_T3_ECU2_HwTrq_HwNm_fp;

                    }

                    cal2_FORD_T3_ECU2_MtrCurrQax_low_pos_fp = cal2_FORD_T3_ECU2_MtrCurrQax_low_pos_fp / 10.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_low_pos_fp = cal2_FORD_T3_ECU2_HwTrq_HwNm_low_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, call to set torque
                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 1500  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in negative direction for low value functional.

                    torque_value_case_index = neg_p5nm;   // neg .5nm torque, call to set torque
                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.



                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FORD_T3_ECU1_MtrCurrQax_low_neg_fp = 0.0;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_low_neg_fp = 0.0;

                    cal2_FORD_T3_ECU2_MtrCurrQax_low_neg_fp = 0.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_low_neg_fp = 0.0;

            // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FORD_T3_ECU1_MtrCurrQax_low_neg_fp += can1_FORD_T3_ECU2_MtrCurrQax_fp;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_low_neg_fp += can1_FORD_T3_ECU1_HwTrq_HwNm_fp;

                    }

                    cal1_FORD_T3_ECU1_MtrCurrQax_low_neg_fp = cal1_FORD_T3_ECU1_MtrCurrQax_low_neg_fp / 10.0;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_low_neg_fp = cal1_FORD_T3_ECU1_HwTrq_HwNm_low_neg_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FORD_T3_ECU2_MtrCurrQax_low_neg_fp += can1_FORD_T3_ECU2_MtrCurrQax_fp;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_low_neg_fp += can1_FORD_T3_ECU2_HwTrq_HwNm_fp;

                    }

                    cal2_FORD_T3_ECU2_MtrCurrQax_low_neg_fp = cal2_FORD_T3_ECU2_MtrCurrQax_low_neg_fp / 10.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_low_neg_fp = cal2_FORD_T3_ECU2_HwTrq_HwNm_low_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, call to set torque
                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/
                    // 2.50nm torque in positive direction for med value functional.

                    torque_value_case_index = pos_2p50nm;   // pos 2.5nm torque, call to set torque

                     set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FORD_T3_ECU1_MtrCurrQax_med_pos_fp = 0.0;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_med_pos_fp = 0.0;

                    cal2_FORD_T3_ECU2_MtrCurrQax_med_pos_fp = 0.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_med_pos_fp = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FORD_T3_ECU1_MtrCurrQax_med_pos_fp += can1_FORD_T3_ECU1_MtrCurrQax_fp;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_med_pos_fp += can1_FORD_T3_ECU1_HwTrq_HwNm_fp;

                    }

                    cal1_FORD_T3_ECU1_MtrCurrQax_med_pos_fp = cal1_FORD_T3_ECU1_MtrCurrQax_med_pos_fp / 10.0;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_med_pos_fp = cal1_FORD_T3_ECU1_HwTrq_HwNm_med_pos_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FORD_T3_ECU2_MtrCurrQax_med_pos_fp += can1_FORD_T3_ECU2_MtrCurrQax_fp;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_med_pos_fp += can1_FORD_T3_ECU2_HwTrq_HwNm_fp;

                    }

                    cal2_FORD_T3_ECU2_MtrCurrQax_med_pos_fp = cal2_FORD_T3_ECU2_MtrCurrQax_med_pos_fp / 10.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_med_pos_fp = cal2_FORD_T3_ECU2_HwTrq_HwNm_med_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, call to set torque
                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/
                   // 2.50nm torque in negative direction for med value functional.

                    torque_value_case_index = neg_2p50nm;   // neg 2.5nm torque, call to set torque

                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FORD_T3_ECU1_MtrCurrQax_med_neg_fp = 0.0;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_med_neg_fp = 0.0;

                    cal2_FORD_T3_ECU2_MtrCurrQax_med_neg_fp = 0.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_med_neg_fp = 0.0;

            // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FORD_T3_ECU1_MtrCurrQax_med_neg_fp += can1_FORD_T3_ECU1_MtrCurrQax_fp;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_med_neg_fp += can1_FORD_T3_ECU1_HwTrq_HwNm_fp;

                    }

            cal1_FORD_T3_ECU1_MtrCurrQax_med_neg_fp = cal1_FORD_T3_ECU1_MtrCurrQax_med_neg_fp / 10.0;
            cal1_FORD_T3_ECU1_HwTrq_HwNm_med_neg_fp = cal1_FORD_T3_ECU1_HwTrq_HwNm_med_neg_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FORD_T3_ECU2_MtrCurrQax_med_neg_fp += can1_FORD_T3_ECU2_MtrCurrQax_fp;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_med_neg_fp += can1_FORD_T3_ECU2_HwTrq_HwNm_fp;

                    }

                    cal2_FORD_T3_ECU2_MtrCurrQax_med_neg_fp = cal2_FORD_T3_ECU2_MtrCurrQax_med_neg_fp / 10.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_med_neg_fp = cal2_FORD_T3_ECU2_HwTrq_HwNm_med_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, call to set torque
                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/
                  // 3.50nm torque in positive direction only high value functional.

                    torque_value_case_index = pos_3p50nm;   // pos 3.5nm torque, call to set torque

                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FORD_T3_ECU1_MtrCurrQax_high_pos_fp = 0.0;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_high_pos_fp = 0.0;

                    cal2_FORD_T3_ECU2_MtrCurrQax_high_pos_fp = 0.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_high_pos_fp = 0.0;

            // gather CAN1 low-amp positive conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FORD_T3_ECU1_MtrCurrQax_high_pos_fp += can1_FORD_T3_ECU1_MtrCurrQax_fp;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_high_pos_fp += can1_FORD_T3_ECU1_HwTrq_HwNm_fp;

                    }

                    cal1_FORD_T3_ECU1_MtrCurrQax_high_pos_fp = cal1_FORD_T3_ECU1_MtrCurrQax_high_pos_fp / 10.0;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_high_pos_fp = cal1_FORD_T3_ECU1_HwTrq_HwNm_high_pos_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FORD_T3_ECU2_MtrCurrQax_high_pos_fp += can1_FORD_T3_ECU2_MtrCurrQax_fp;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_high_pos_fp += can1_FORD_T3_ECU2_HwTrq_HwNm_fp;

                    }

                    cal2_FORD_T3_ECU2_MtrCurrQax_high_pos_fp = cal2_FORD_T3_ECU2_MtrCurrQax_high_pos_fp / 10.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_high_pos_fp = cal2_FORD_T3_ECU2_HwTrq_HwNm_high_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, call to set torque
                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/
                  // 3.5nm torque in negative direction only high value functional.

                    torque_value_case_index = neg_3p50nm;   // neg 3.5nm torque, call to set torque

                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_FORD_T3_ECU1_MtrCurrQax_high_neg_fp = 0.0;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_high_neg_fp = 0.0;

                    cal2_FORD_T3_ECU2_MtrCurrQax_high_neg_fp = 0.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_high_neg_fp = 0.0;

                    // gather CAN1 low-amp negative conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_FORD_T3_ECU1_MtrCurrQax_high_neg_fp += can1_FORD_T3_ECU1_MtrCurrQax_fp;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_high_neg_fp += can1_FORD_T3_ECU1_HwTrq_HwNm_fp;

                    }

                    cal1_FORD_T3_ECU1_MtrCurrQax_high_neg_fp = cal1_FORD_T3_ECU1_MtrCurrQax_high_neg_fp / 10.0;
                    cal1_FORD_T3_ECU1_HwTrq_HwNm_high_neg_fp = cal1_FORD_T3_ECU1_HwTrq_HwNm_high_neg_fp / 10.0;

            // gather CAN2 low-amp conditions
            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can2_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can2_data();

                    cal2_FORD_T3_ECU2_MtrCurrQax_high_neg_fp += can1_FORD_T3_ECU2_MtrCurrQax_fp;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_high_neg_fp += can1_FORD_T3_ECU2_HwTrq_HwNm_fp;

                    }

                    cal2_FORD_T3_ECU2_MtrCurrQax_high_neg_fp = cal2_FORD_T3_ECU2_MtrCurrQax_high_neg_fp / 10.0;
                    cal2_FORD_T3_ECU2_HwTrq_HwNm_high_neg_fp = cal2_FORD_T3_ECU2_HwTrq_HwNm_high_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = pos_0nm;   // zero nm torque, call to set torque
                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.


                    system_msec_clock_temp = system_msec_clock + 1500;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 10 - Done testing current return to 0 amps    \/
                  // 0.00nm torque in positive direction.

                    torque_value_case_index = pos_0nm;   // zero nm torque, call to set torque
                    set_torque_TOC_or_SENT_or_Analog();  // set product torque by TOC or SENT or Analog, prerequisites must be met.

            // ------------------------------------------------------------- Step 11 - print out results \/
                    /* max up to 23 parameters at a time, sprintf function max   -- Using K2xx format, temp_return_message[]    19MAR12 L.Cronk  */
                    /*  69 parameters + DTCs  -- full unused with N_A_num.       */

    // CAN1
                    sprintf(return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,",\
                            cal1_FORD_T3_ECU1_BattVltg_fp,cal1_FORD_T3_ECU1_Temperature_fp,\
                            cal1_FORD_T3_ECU1_DigT1_fp,cal1_FORD_T3_ECU1_DigT1_fp,\
                            cal1_FORD_T3_ECU1_MtrCurrQax_fp,cal1_FORD_T3_ECU1_SystemState_byt,\
                            cal1_FORD_T3_ECU1_HwTrq_HwNm_fp,cal1_FORD_T3_ECU1_Abs_Hw_Pos_fp);     // 8

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal1_FORD_T3_ECU1_MtrCurrQax_low_pos_fp,cal1_FORD_T3_ECU1_MtrCurrQax_med_pos_fp,\
                            cal1_FORD_T3_ECU1_MtrCurrQax_high_pos_fp,cal1_FORD_T3_ECU1_MtrCurrQax_low_neg_fp,\
                            cal1_FORD_T3_ECU1_MtrCurrQax_med_neg_fp,cal1_FORD_T3_ECU1_MtrCurrQax_high_neg_fp,\
                            cal1_FORD_T3_ECU1_HwTrq_HwNm_low_pos_fp,cal1_FORD_T3_ECU1_HwTrq_HwNm_med_pos_fp,\
                            cal1_FORD_T3_ECU1_HwTrq_HwNm_high_pos_fp,cal1_FORD_T3_ECU1_HwTrq_HwNm_low_neg_fp,\
                            cal1_FORD_T3_ECU1_HwTrq_HwNm_med_neg_fp,cal1_FORD_T3_ECU1_HwTrq_HwNm_high_neg_fp);  // 20

                    strcat(return_message,temp_return_message);

    //CAN2
                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,",\
                            cal2_FORD_T3_ECU2_BattVltg_fp,cal2_FORD_T3_ECU2_Temperature_fp,\
                            cal2_FORD_T3_ECU2_DigT1_fp,cal2_FORD_T3_ECU2_DigT2_fp,\
                            cal2_FORD_T3_ECU2_MtrCurrQax_fp,cal2_FORD_T3_ECU2_SystemState_byt,\
                            cal2_FORD_T3_ECU2_HwTrq_HwNm_fp,cal2_FORD_T3_ECU2_Abs_Hw_Pos_fp);     // 28

                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal2_FORD_T3_ECU2_MtrCurrQax_low_pos_fp,cal2_FORD_T3_ECU2_MtrCurrQax_med_pos_fp,\
                            cal2_FORD_T3_ECU2_MtrCurrQax_high_pos_fp,cal2_FORD_T3_ECU2_MtrCurrQax_low_neg_fp,\
                            cal2_FORD_T3_ECU2_MtrCurrQax_med_neg_fp,cal2_FORD_T3_ECU2_MtrCurrQax_high_neg_fp,\
                            cal2_FORD_T3_ECU2_HwTrq_HwNm_low_pos_fp,cal2_FORD_T3_ECU2_HwTrq_HwNm_med_pos_fp,\
                            cal2_FORD_T3_ECU2_HwTrq_HwNm_high_pos_fp,cal2_FORD_T3_ECU2_HwTrq_HwNm_low_neg_fp,\
                            cal2_FORD_T3_ECU2_HwTrq_HwNm_med_neg_fp,cal2_FORD_T3_ECU2_HwTrq_HwNm_high_neg_fp);  // 40

                    strcat(return_message,temp_return_message);


            /*   All Done - fill it up with  N_A_num  (69-10-10-9 = 34) */

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //9
                    strcat(return_message,temp_return_message);


    //                          get_DTCs1();
    //
    //                          strcat(return_message,dtc1_return_message);

                    get_DTCs1();

                    // Phil wants to give product a second try.
                    if(dtc1[0][0] == 0xFF)
                    {
                        get_DTCs1();
                    }

                // append CAN1 [1-7], "0" at #77 field and CAN2 [1-7] DTCs to return_message

                    strcat(return_message,dtc1_return_message);
                    strcat(return_message,"0,");

                    get_DTCs2();

                    // Phil wants to give product a second try.
                    if(dtc2[0][0] == 0xFF)
                    {
                        get_DTCs2();
                    }

                    strcat(return_message,dtc2_return_message);

                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500mS ensure message transmit is completed, before using sciSend again.
                    while(system_msec_clock < system_msec_clock_temp);

                    strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    strcpy(sbuf_tx_main,"\r\n");
                    strcat(sbuf_tx_main,return_message);
                    strcat(sbuf_tx_main,"\r\n");

                    sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                    {
                        case CIB:
                            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                            {
                               transmit_str_485(return_message);
                            }
                        break;

                        case WEB:
                            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                            {
                                transmit_str_485(return_message);
                            }
                        break;
                    }

            // ------------------------------------------------------------- Step 12 - Clean up   DONE \/

                    ign1_status = OFF;
                    ign2_status = OFF;

                    gioSetBit(hetPORT1, 14, 0); /* turn off Product Ign1 */
                    gioSetBit(hetPORT1, 15, 0); /* turn off Product Ign2 */

                    gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */


        break;
        }   //  end case TARGET_FORD_T3_T6:

        case TARGET_RENAULT_NISSAN:
         {
            //  R E N A U L T _ N I S S A N    F U N C T I O N A L S ------------------------------

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

            // ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

            // -------------------------------------------      ign1_status = WARM;
                    ign1_status = WARM;

                    system_msec_clock_temp = system_msec_clock + 7000;  // wait 7 Sec, wait for temp sensor to acclimate
                    while(system_msec_clock < system_msec_clock_temp);


            // ------------------------------------------------------------- Step 2 - Clr DTCs \/
                    // ************ CLEAR DTC's ******************


                    ECU1_XCP_reply_index = 1;

                    ECU1_clear_DTCs_flag = 1; // set flag for ISR


                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                    while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                    ECU1_XCP_reply_index = 0;
                    ECU1_clear_DTCs_flag = 0; // done...clr flag for ISR

                    // ************ END clear DTC's ******************


            // ------------------------------------------------------------- Step 3 - Request/store one time parametrics \/
                    // set up torque value, not going back to main so initiate all steps here


                    torque_value_case_index = 0;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != RENAULT_NISSAN_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

            // New B-CIB using floats for storage and printing
                    //   C A N  1
                  cal1_RENAULT_NISSAN_BattVltg_fp                = can1_RENAULT_NISSAN_BattVltg_fp;                     // can1_dump_err_data 1       Battery Voltage
                  cal1_RENAULT_NISSAN_Temperature_fp             = can1_RENAULT_NISSAN_Temperature_fp;                  // can1_dump_err_data 2       Ecu Temperature Filtered
                  cal1_RENAULT_NISSAN_DigT1_HwNm_fp              = can1_RENAULT_NISSAN_DigT1_HwNm_fp;                   // can1_dump_err_data 3       HwTq 0
                  cal1_RENAULT_NISSAN_DigT2_HwNm_fp              = can1_RENAULT_NISSAN_DigT2_HwNm_fp;                   // can1_dump_err_data 4       HwTq 1
                  cal1_RENAULT_NISSAN_MtrCurrQax_fp              = can1_RENAULT_NISSAN_MtrCurrQax_fp;                   // can1_dump_err_data 5       Motor Current Measurement
                  cal1_RENAULT_NISSAN_SystemState_byt            = can1_RENAULT_NISSAN_SystemState_byt;                 // can1_dump_err_data 6       System State
                  cal1_RENAULT_NISSAN_HwTrq_HwNm_fp              = can1_RENAULT_NISSAN_HwTrq_HwNm_fp;                   // can1_dump_err_data 7       Handwheel Tq total
                  cal1_RENAULT_NISSAN_Abs_Hw_Pos_fp              = can1_RENAULT_NISSAN_Abs_Hw_Pos_fp;                   // can1_dump_err_data 8       Handwheel Angle
                  cal1_RENAULT_NISSAN_MotTrq_Crf_fp              = can1_RENAULT_NISSAN_MotTrq_Crf_fp;                   // can1_dump_err_data 9       MotTrq_Crf
                  cal1_RENAULT_NISSAN_MotTrq_Mrf_fp              = can1_RENAULT_NISSAN_MotTrq_Mrf_fp;                   // can1_dump_err_data 10      MotTrq_Mrf
                  cal1_RENAULT_NISSAN_VehSpd_fp                  = can1_RENAULT_NISSAN_VehSpd_fp;                       // can1_dump_err_data 11      VehSpd
                  cal1_RENAULT_NISSAN_Spare2_fp                  = can1_RENAULT_NISSAN_Spare2_fp;                       // can1_dump_err_data 12      Spair2



            // ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perametrics -- sent_data_array_pos_0nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = 0;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 500;   // wait 500  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);



            // ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in positive direction for low value functional.

                    ign1_status = NORMAL;


                    torque_value_case_index = 3;   // pos .5nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);


                    cal1_RENAULT_NISSAN_MtrCurrQax_low_pos_fp = 0.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_low_pos_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != RENAULT_NISSAN_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_RENAULT_NISSAN_MtrCurrQax_low_pos_fp += can1_RENAULT_NISSAN_MtrCurrQax_fp;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_low_pos_fp += can1_RENAULT_NISSAN_HwTrq_HwNm_fp;

                    }

                    cal1_RENAULT_NISSAN_MtrCurrQax_low_pos_fp = cal1_RENAULT_NISSAN_MtrCurrQax_low_pos_fp / 10.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_low_pos_fp = cal1_RENAULT_NISSAN_HwTrq_HwNm_low_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    trig(); // not necessary to trig(), but echo results to debug port is useful to monitor progress
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = 0;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
                  // 0.50nm torque in negative direction for low value functional.


                    torque_value_case_index = 4;   // neg .5nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_RENAULT_NISSAN_MtrCurrQax_low_neg_fp = 0.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_low_neg_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != RENAULT_NISSAN_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_RENAULT_NISSAN_MtrCurrQax_low_neg_fp += can1_RENAULT_NISSAN_MtrCurrQax_fp;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_low_neg_fp += can1_RENAULT_NISSAN_HwTrq_HwNm_fp;

                    }

                    cal1_RENAULT_NISSAN_MtrCurrQax_low_neg_fp = cal1_RENAULT_NISSAN_MtrCurrQax_low_neg_fp / 10.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_low_neg_fp = cal1_RENAULT_NISSAN_HwTrq_HwNm_low_neg_fp / 10.0;


            // ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p1nm \r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = 0;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);


            // ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/

                  // 2.00nm torque in positive direction for med value functional.


                    torque_value_case_index = 7;   // pos 2.0nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_RENAULT_NISSAN_MtrCurrQax_med_pos_fp = 0.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_med_pos_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != RENAULT_NISSAN_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_RENAULT_NISSAN_MtrCurrQax_med_pos_fp += can1_RENAULT_NISSAN_MtrCurrQax_fp;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_med_pos_fp += can1_RENAULT_NISSAN_HwTrq_HwNm_fp;

                    }

                    cal1_RENAULT_NISSAN_MtrCurrQax_med_pos_fp = cal1_RENAULT_NISSAN_MtrCurrQax_med_pos_fp / 10.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_med_pos_fp = cal1_RENAULT_NISSAN_HwTrq_HwNm_med_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                    torque_value_case_index = 0;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/

                  // 2.00nm torque in negative direction for med value functional.


                    torque_value_case_index = 8;   // neg 2.0nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_RENAULT_NISSAN_MtrCurrQax_med_neg_fp = 0.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_med_neg_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {
                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != RENAULT_NISSAN_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_RENAULT_NISSAN_MtrCurrQax_med_neg_fp += can1_RENAULT_NISSAN_MtrCurrQax_fp;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_med_neg_fp += can1_RENAULT_NISSAN_HwTrq_HwNm_fp;

                    }

                    cal1_RENAULT_NISSAN_MtrCurrQax_med_neg_fp = cal1_RENAULT_NISSAN_MtrCurrQax_med_neg_fp / 10.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_med_neg_fp = cal1_RENAULT_NISSAN_HwTrq_HwNm_med_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_2p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


                    torque_value_case_index = 0;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/

                  // 4.00nm torque in positive direction only high value functional.


                    torque_value_case_index = 9;   // pos 4.0nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_RENAULT_NISSAN_MtrCurrQax_high_pos_fp = 0.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_high_pos_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != RENAULT_NISSAN_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_RENAULT_NISSAN_MtrCurrQax_high_pos_fp += can1_RENAULT_NISSAN_MtrCurrQax_fp;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_high_pos_fp += can1_RENAULT_NISSAN_HwTrq_HwNm_fp;

                    }

                    cal1_RENAULT_NISSAN_MtrCurrQax_high_pos_fp = cal1_RENAULT_NISSAN_MtrCurrQax_high_pos_fp / 10.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_high_pos_fp = cal1_RENAULT_NISSAN_HwTrq_HwNm_high_pos_fp / 10.0;

            // ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


                    torque_value_case_index = 0;   // zero nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/

                  // 4.00nm torque in negative direction only high value functional.

                    torque_value_case_index = 10;   // neg 4.0nm torque

                    set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
                    while(system_msec_clock < system_msec_clock_temp);

                    cal1_RENAULT_NISSAN_MtrCurrQax_high_neg_fp = 0.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_high_neg_fp = 0.0;

            for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
                    {

                    // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

                    can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();
                    system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                    while((can1_request_index != RENAULT_NISSAN_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

                    parse_can1_data();

                    cal1_RENAULT_NISSAN_MtrCurrQax_high_neg_fp += can1_RENAULT_NISSAN_MtrCurrQax_fp;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_high_neg_fp += can1_RENAULT_NISSAN_HwTrq_HwNm_fp;

                    }

                    cal1_RENAULT_NISSAN_MtrCurrQax_high_neg_fp = cal1_RENAULT_NISSAN_MtrCurrQax_high_neg_fp / 10.0;
                    cal1_RENAULT_NISSAN_HwTrq_HwNm_high_neg_fp = cal1_RENAULT_NISSAN_HwTrq_HwNm_high_neg_fp / 10.0;

            // ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
                    strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_4p00nm\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
                    trig();
                            sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

                   torque_value_case_index = 0;   // zero nm torque

                   set_torque_TOC_or_SENT_or_Analog();

                    system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
                    while(system_msec_clock < system_msec_clock_temp);

            // ------------------------------------------------------------- Step 10 - Done testing current return to 0 amps    \/

                  // 0.00nm torque in positive direction.

 //   placeholder     torque_value_case_index = 0;   // zero nm torque, not used yet, for dynamic call to set torque
 //                   sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]


            // ------------------------------------------------------------- Step 11 - print out results \/
                    /* max up to 23 parameters at a time, sprintf function max   -- Using K2xx format, temp_return_message[]    19MAR12 L.Cronk  */
                    /*  69 parameters + DTCs  -- full unused with N_A_num.       */

                    sprintf(return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal1_RENAULT_NISSAN_BattVltg_fp, cal1_RENAULT_NISSAN_Temperature_fp,\
                            cal1_RENAULT_NISSAN_DigT1_HwNm_fp,cal1_RENAULT_NISSAN_DigT2_HwNm_fp,\
                            cal1_RENAULT_NISSAN_MtrCurrQax_fp,cal1_RENAULT_NISSAN_SystemState_byt,\
                            cal1_RENAULT_NISSAN_HwTrq_HwNm_fp,cal1_RENAULT_NISSAN_Abs_Hw_Pos_fp,\
                            cal1_RENAULT_NISSAN_MotTrq_Crf_fp,cal1_RENAULT_NISSAN_MotTrq_Mrf_fp,\
                            cal1_RENAULT_NISSAN_VehSpd_fp,cal1_RENAULT_NISSAN_Spare2_fp);      //12
                    /* <23 at a time */

                    sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                            cal1_RENAULT_NISSAN_MtrCurrQax_low_pos_fp,cal1_RENAULT_NISSAN_MtrCurrQax_med_pos_fp,\
                            cal1_RENAULT_NISSAN_MtrCurrQax_high_pos_fp,cal1_RENAULT_NISSAN_MtrCurrQax_low_neg_fp,\
                            cal1_RENAULT_NISSAN_MtrCurrQax_med_neg_fp,cal1_RENAULT_NISSAN_MtrCurrQax_high_neg_fp,\
                            cal1_RENAULT_NISSAN_HwTrq_HwNm_low_pos_fp,cal1_RENAULT_NISSAN_HwTrq_HwNm_med_pos_fp,\
                            cal1_RENAULT_NISSAN_HwTrq_HwNm_high_pos_fp,cal1_RENAULT_NISSAN_HwTrq_HwNm_low_neg_fp,\
                            cal1_RENAULT_NISSAN_HwTrq_HwNm_med_neg_fp,cal1_RENAULT_NISSAN_HwTrq_HwNm_high_neg_fp);  //12

                    strcat(return_message,temp_return_message);

            /*   All Done - fill it up with  N_A_num  (69-10-10-10-10-5 = 45) */

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
                    strcat(return_message,temp_return_message);

                    sprintf(temp_return_message,"%d,%d,%d,%d,%d,",\
                    N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);                                           //5
                    strcat(return_message,temp_return_message);

                            get_DTCs1();

                            strcat(return_message,dtc1_return_message);

                    strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                                sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    strcpy(sbuf_tx_main,"\r\n");
                    strcat(sbuf_tx_main,return_message);
                    strcat(sbuf_tx_main,"\r\n");

                            sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

                    switch(scilinREG_is_CIB_or_Monitor_or_WEB)
                    {
                        case CIB:
                            if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                            {
                               transmit_str_485(return_message);
                            }
                        break;

                        case WEB:
                            if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                            {
                                transmit_str_485(return_message);
                            }
                        break;
                    }

            // ------------------------------------------------------------- Step 12 - Clean up   DONE \/

                    ign1_status = OFF;
                    ign2_status = OFF;

                    gioSetBit(hetPORT1, 14, 0); /* turn off Product Ign1 */
                    gioSetBit(hetPORT1, 15, 0); /* turn off Product Ign2 */

                    gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */


         break;
        }      // end case TARGET_RENAULT_NISSAN

        case TARGET_BMW_UKL:
        {
            //  B M W _ U K L    F U N C T I O N A L S ------------------------------

            strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                        sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

            // ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

            gioSetBit(hetPORT1, 31, 1);/* set Product Ign to on, if in single board set up  29MAR12 L.Cronk */
            // ign1_status = WARM;

            system_msec_clock_temp = system_msec_clock + 5000;  // wait 5 Sec, wait for temp sensor to acclimate
            while(system_msec_clock < system_msec_clock_temp);


            // ------------------------------------------------------------- Step 2 - Clr DTCs \/
                    // ************ CLEAR DTC's ******************


            ECU1_XCP_reply_index = 1;

            ECU1_clear_DTCs_flag = 1; // set flag for ISR

            transmitFlexray(Nexteer_session, MFG_TX,2);   // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

            while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

            ECU1_XCP_reply_index = 0;
            ECU1_clear_DTCs_flag = 0; // done...clr flag for ISR


            // ************ END clear DTC's ******************


            // ------------------------------------------------------------- Step 3 - Request/store one time parametrics \/
                    // set up torque value, not going back to main so initiate all steps here

            torque_value_case_index = 0;   // zero nm torque

            set_torque_TOC_or_SENT_or_Analog();

            system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000 mS, wait for system to stabilize
            while(system_msec_clock < system_msec_clock_temp);

            // push ccp_request_connect, this will kick off the rest of Diagnostic Commands from ISR
            fray_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftFRAY();                //send connect message

            system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
            while((fray_request_index != TARGET_BMW_UKL_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at 22, last CAN reads are done, move on */

            parse_can1_data();

            // move data into cal variables

             cal1_BMW_UKL_Batt_Volt_fp                  =  fray1_BMW_UKL_Batt_Volt_fp;             // fray1_dump_err_data 1         Battery Voltage
             cal1_BMW_UKL_Batt_Curr_fp                  =  fray1_BMW_UKL_Batt_Curr_fp;             // fray1_dump_err_data 2         Battery Current
             cal1_BMW_UKL_Mot_Curr_fp                   =  fray1_BMW_UKL_Mot_Curr_fp;              // fray1_dump_err_data 3         Motor Current Measurement
             cal1_BMW_UKL_Mot_Vel_fp                    =  fray1_BMW_UKL_Mot_Vel_fp;               // fray1_dump_err_data 4         Motor Velocity
             cal1_BMW_UKL_Comm_Torque_fp                =  fray1_BMW_UKL_Comm_Torque_fp;           // fray1_dump_err_data 5         Commanded Torque
             cal1_BMW_UKL_Lim_Torque_fp                 =  fray1_BMW_UKL_Lim_Torque_fp;            // fray1_dump_err_data 6         Ecu Temperature Filtered
             cal1_BMW_UKL_PCB_Temp_fp                   =  fray1_BMW_UKL_PCB_Temp_fp;              // fray1_dump_err_data 7         Ecu Temperature
             cal1_BMW_UKL_Mot_Temp_fp                   =  fray1_BMW_UKL_Mot_Temp_fp;              // fray1_dump_err_data 8         Motor Temperature
             cal1_BMW_UKL_Junction_Temp_fp              =  fray1_BMW_UKL_Junction_Temp_fp;         // fray1_dump_err_data 9         Junction Temperature
             cal1_BMW_UKL_HW_Angle_fp                   =  fray1_BMW_UKL_HW_Angle_fp;              // fray1_dump_err_data 10        Handwheel Angle
             cal1_BMW_UKL_Diff_Torque_fp                =  fray1_BMW_UKL_Diff_Torque_fp;           // fray1_dump_err_data 11        HW Tq total
             cal1_BMW_UKL_sys_state_byt                 =  fray1_BMW_UKL_sys_state_byt;            // fray1_dump_err_data 12        unsigned int  System State
             cal1_BMW_UKL_T1_Volt_fp                    =  fray1_BMW_UKL_T1_Volt_fp;               // fray1_dump_err_data 13        channel a trq volts
             cal1_BMW_UKL_T2_Volt_fp                    =  fray1_BMW_UKL_T2_Volt_fp;               // fray1_dump_err_data 14        channel b trq volts

             // ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

             strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perametrics -- sent_data_array_pos_0nm \r\n");
                         sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
             trig();
                     sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

             torque_value_case_index = 0;   // zero nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 500;   // wait 500  for part to respond and relax
             while(system_msec_clock < system_msec_clock_temp);



             // ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
                   // 0.50nm torque in positive direction for low value functional.

             ign1_status = NORMAL;

             torque_value_case_index = 3;   // pos .5nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
             while(system_msec_clock < system_msec_clock_temp);


             cal1_BMW_UKL_MtrCurrQax_low_pos_fp = 0.0;
             cal1_BMW_UKL_HwTrq_HwNm_low_pos_fp = 0.0;

      for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
             {
             // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

             fray_request_index = 0; // set index to start sequence at case 0 in ISR
             ShiftFRAY();

             system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
             while((fray_request_index != TARGET_BMW_UKL_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

             parse_can1_data();

             cal1_BMW_UKL_MtrCurrQax_low_pos_fp += fray1_BMW_UKL_Mot_Curr_fp;
             cal1_BMW_UKL_HwTrq_HwNm_low_pos_fp += fray1_BMW_UKL_Diff_Torque_fp;

             }

             cal1_BMW_UKL_MtrCurrQax_low_pos_fp = cal1_BMW_UKL_MtrCurrQax_low_pos_fp / 10.0;
             cal1_BMW_UKL_HwTrq_HwNm_low_pos_fp = cal1_BMW_UKL_HwTrq_HwNm_low_pos_fp / 10.0;


             // ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
             strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p1nm \r\n");
                         sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

             trig(); // not necessary to trig(), but echo results to debug port is useful to monitor progress
                     sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

             torque_value_case_index = 0;   // zero nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
             while(system_msec_clock < system_msec_clock_temp);

             // ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
                   // 0.50nm torque in negative direction for low value functional.

             torque_value_case_index = 4;   // neg .5nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
             while(system_msec_clock < system_msec_clock_temp);

             cal1_BMW_UKL_MtrCurrQax_low_neg_fp = 0.0;
             cal1_BMW_UKL_HwTrq_HwNm_low_neg_fp = 0.0;

     for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
             {
             // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

             fray_request_index = 0; // set index to start sequence at case 0 in ISR
             ShiftFRAY();

             system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
             while((fray_request_index != TARGET_BMW_UKL_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

             parse_can1_data();

             cal1_BMW_UKL_MtrCurrQax_low_neg_fp += fray1_BMW_UKL_Mot_Curr_fp;
             cal1_BMW_UKL_HwTrq_HwNm_low_neg_fp += fray1_BMW_UKL_Diff_Torque_fp;

             }

             cal1_BMW_UKL_MtrCurrQax_low_neg_fp = cal1_BMW_UKL_MtrCurrQax_low_neg_fp / 10.0;
             cal1_BMW_UKL_HwTrq_HwNm_low_neg_fp = cal1_BMW_UKL_HwTrq_HwNm_low_neg_fp / 10.0;

             // ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
             strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p1nm \r\n");
                         sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
             trig();
                     sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

             torque_value_case_index = 0;   // zero nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
             while(system_msec_clock < system_msec_clock_temp);


             // ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/
                     // 1.50nm torque in positive direction for med value functional.

             torque_value_case_index = 7;   // pos 1.50nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
             while(system_msec_clock < system_msec_clock_temp);

             cal1_BMW_UKL_MtrCurrQax_med_pos_fp = 0.0;
             cal1_BMW_UKL_HwTrq_HwNm_med_pos_fp = 0.0;

     for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
             {
             // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

             fray_request_index = 0; // set index to start sequence at case 0 in ISR
             ShiftFRAY();

             system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
             while((fray_request_index != TARGET_BMW_UKL_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

             parse_can1_data();

             cal1_BMW_UKL_MtrCurrQax_med_pos_fp += fray1_BMW_UKL_Mot_Curr_fp;
             cal1_BMW_UKL_HwTrq_HwNm_med_pos_fp += fray1_BMW_UKL_Diff_Torque_fp;

             }

             cal1_BMW_UKL_MtrCurrQax_med_pos_fp = cal1_BMW_UKL_MtrCurrQax_med_pos_fp / 10.0;
             cal1_BMW_UKL_HwTrq_HwNm_med_pos_fp = cal1_BMW_UKL_HwTrq_HwNm_med_pos_fp / 10.0;

             // ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
             strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_2p00nm\r\n");
                         sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
             trig();
                     sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

             torque_value_case_index = 0;   // zero nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
             while(system_msec_clock < system_msec_clock_temp);

             // ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/
                   // 1.50nm torque in negative direction for med value functional.

              torque_value_case_index = 8;   // neg 1.50nm torque

              set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
              while(system_msec_clock < system_msec_clock_temp);

              cal1_BMW_UKL_MtrCurrQax_med_neg_fp = 0.0;
              cal1_BMW_UKL_HwTrq_HwNm_med_neg_fp = 0.0;

      for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
              {
              // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

              fray_request_index = 0; // set index to start sequence at case 0 in ISR
              ShiftFRAY();

              system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
              while((fray_request_index != TARGET_BMW_UKL_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

              parse_can1_data();

              cal1_BMW_UKL_MtrCurrQax_med_neg_fp += fray1_BMW_UKL_Mot_Curr_fp;
              cal1_BMW_UKL_HwTrq_HwNm_med_neg_fp += fray1_BMW_UKL_Diff_Torque_fp;

              }

              cal1_BMW_UKL_MtrCurrQax_med_neg_fp = cal1_BMW_UKL_MtrCurrQax_med_neg_fp / 10.0;
              cal1_BMW_UKL_HwTrq_HwNm_med_neg_fp = cal1_BMW_UKL_HwTrq_HwNm_med_neg_fp / 10.0;

             // ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
              strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_2p00nm\r\n");
                          sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
              trig();
                      sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


              torque_value_case_index = 0;   // zero nm torque

              set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
              while(system_msec_clock < system_msec_clock_temp);

             // ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/
                   // 2.00nm torque in positive direction only high value functional.

              torque_value_case_index = 9;   // pos 4.0nm torque

              set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
              while(system_msec_clock < system_msec_clock_temp);

              cal1_BMW_UKL_MtrCurrQax_high_pos_fp = 0.0;
              cal1_BMW_UKL_HwTrq_HwNm_high_pos_fp = 0.0;

      for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
              {
              // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

              fray_request_index = 0; // set index to start sequence at case 0 in ISR
              ShiftFRAY();

              system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
              while((fray_request_index != TARGET_BMW_UKL_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

              parse_can1_data();

              cal1_BMW_UKL_MtrCurrQax_high_pos_fp += fray1_BMW_UKL_Mot_Curr_fp;
              cal1_BMW_UKL_HwTrq_HwNm_high_pos_fp += fray1_BMW_UKL_Diff_Torque_fp;

              }

              cal1_BMW_UKL_MtrCurrQax_high_pos_fp = cal1_BMW_UKL_MtrCurrQax_high_pos_fp / 10.0;
              cal1_BMW_UKL_HwTrq_HwNm_high_pos_fp = cal1_BMW_UKL_HwTrq_HwNm_high_pos_fp / 10.0;

             // ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
              strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_4p00nm\r\n");
                          sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
              trig();
                      sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


              torque_value_case_index = 0;   // zero nm torque

              set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
              while(system_msec_clock < system_msec_clock_temp);

             // ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/
                   // 2.00nm torque in negative direction only high value functional.

              torque_value_case_index = 10;   // neg 2.0nm torque

              set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
              while(system_msec_clock < system_msec_clock_temp);

              cal1_BMW_UKL_MtrCurrQax_high_neg_fp = 0.0;
              cal1_BMW_UKL_HwTrq_HwNm_high_neg_fp = 0.0;

      for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
              {
              // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

              fray_request_index = 0; // set index to start sequence at case 0 in ISR
              ShiftFRAY();

              system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
              while((fray_request_index != TARGET_BMW_UKL_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

              parse_can1_data();

              cal1_BMW_UKL_MtrCurrQax_high_neg_fp += fray1_BMW_UKL_Mot_Curr_fp;
              cal1_BMW_UKL_HwTrq_HwNm_high_neg_fp += fray1_BMW_UKL_Diff_Torque_fp;

              }

              cal1_BMW_UKL_MtrCurrQax_high_neg_fp = cal1_BMW_UKL_MtrCurrQax_high_neg_fp / 10.0;
              cal1_BMW_UKL_HwTrq_HwNm_high_neg_fp = cal1_BMW_UKL_HwTrq_HwNm_high_neg_fp / 10.0;

             // ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
              strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_4p00nm\r\n");
                          sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
              trig();
                      sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

             torque_value_case_index = 0;   // zero nm torque

             set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
              while(system_msec_clock < system_msec_clock_temp);

             // ------------------------------------------------------------- Step 10 - Done testing, build data and  Get DCTs    \/
              sprintf(return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,",\
                      cal1_BMW_UKL_Batt_Volt_fp, cal1_BMW_UKL_Batt_Curr_fp,\
                      cal1_BMW_UKL_Mot_Curr_fp,cal1_BMW_UKL_Mot_Vel_fp,\
                      cal1_BMW_UKL_Comm_Torque_fp,cal1_BMW_UKL_Lim_Torque_fp,\
                      cal1_BMW_UKL_PCB_Temp_fp,cal1_BMW_UKL_Mot_Temp_fp,\
                      cal1_BMW_UKL_Junction_Temp_fp,cal1_BMW_UKL_HW_Angle_fp,\
                      cal1_BMW_UKL_Diff_Torque_fp,cal1_BMW_UKL_sys_state_byt,\
                      cal1_BMW_UKL_T1_Volt_fp,cal1_BMW_UKL_T2_Volt_fp);         //14
               /* <23 at a time */

               sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                       cal1_BMW_UKL_MtrCurrQax_low_pos_fp,cal1_BMW_UKL_MtrCurrQax_med_pos_fp,\
                       cal1_BMW_UKL_MtrCurrQax_high_pos_fp,cal1_BMW_UKL_MtrCurrQax_low_neg_fp,\
                       cal1_BMW_UKL_MtrCurrQax_med_neg_fp,cal1_BMW_UKL_MtrCurrQax_high_neg_fp,\
                       cal1_BMW_UKL_HwTrq_HwNm_low_pos_fp,cal1_BMW_UKL_HwTrq_HwNm_med_pos_fp,\
                       cal1_BMW_UKL_HwTrq_HwNm_high_pos_fp,cal1_BMW_UKL_HwTrq_HwNm_low_neg_fp,\
                       cal1_BMW_UKL_HwTrq_HwNm_med_neg_fp,cal1_BMW_UKL_HwTrq_HwNm_high_neg_fp);  //12

               strcat(return_message,temp_return_message);

       /*   All Done - fill it up with  N_A_num  (69-10-10-10-10-3 = 43) */

               sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
               N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
               strcat(return_message,temp_return_message);

               sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
               N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
               strcat(return_message,temp_return_message);

               sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
               N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
               strcat(return_message,temp_return_message);

               sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
               N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
               strcat(return_message,temp_return_message);

               sprintf(temp_return_message,"%d,%d,%d,",\
               N_A_num,N_A_num,N_A_num);                                           //3
               strcat(return_message,temp_return_message);

                       get_DTCs1();

                       strcat(return_message,dtc1_return_message);

               strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                           sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

               strcpy(sbuf_tx_main,"\r\n");
               strcat(sbuf_tx_main,return_message);
               strcat(sbuf_tx_main,"\r\n");

                       sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

               switch(scilinREG_is_CIB_or_Monitor_or_WEB)
               {
                   case CIB:
                       if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                       {
                          transmit_str_485(return_message);
                       }
                   break;

                   case WEB:
                       if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                       {
                           transmit_str_485(return_message);
                       }
                   break;
               }

       // ------------------------------------------------------------- Step 12 - Clean up   DONE \/

               ign1_status = OFF;
               ign2_status = OFF;

               gioSetBit(hetPORT1, 14, 0); /* turn off Product Ign1 */
               gioSetBit(hetPORT1, 15, 0); /* turn off Product Ign2 */

               gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */


        break;

        }   //  end case TARGET_BMW_UKL:

        case TARGET_BMW_FAAR_WE:
        {
            //  B M W _ F A A R   W E    F U N C T I O N A L S ------------------------------

            strcpy(sbuf_tx_main,"\nI'm at -- S T E P 0a    Just starting CAL\r\n");
                        sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

            // ------------------------------------------------------------- Step 1 - Ign is ON, place in warm init \/

            gioSetBit(hetPORT1, 31, 1);/* set Product Ign to on, if in single board set up  29MAR12 L.Cronk */
            // ign1_status = WARM;

            system_msec_clock_temp = system_msec_clock + 5000;  // wait 5 Sec, wait for temp sensor to acclimate
            while(system_msec_clock < system_msec_clock_temp);


            // ------------------------------------------------------------- Step 2 - Clr DTCs \/
                    // ************ CLEAR DTC's ******************


            ECU1_XCP_reply_index = 1;

            ECU1_clear_DTCs_flag = 1; // set flag for ISR

            transmitFlexray(Nexteer_session, MFG_TX,2);   // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

            while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

            ECU1_XCP_reply_index = 0;
            ECU1_clear_DTCs_flag = 0; // done...clr flag for ISR


            // ************ END clear DTC's ******************


            // ------------------------------------------------------------- Step 3 - Request/store one time parametrics \/
                    // set up torque value, not going back to main so initiate all steps here

            torque_value_case_index = 0;   // zero nm torque

            set_torque_TOC_or_SENT_or_Analog();

            system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000 mS, wait for system to stabilize
            while(system_msec_clock < system_msec_clock_temp);

            // push ccp_request_connect, this will kick off the rest of Diagnostic Commands from ISR
            fray_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftFRAY();                //send connect message

            system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
            while((fray_request_index != TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at 22, last CAN reads are done, move on */

            parse_can1_data();

            // move data into cal variables

             cal1_FAAR_WE_SysStMod_byt                  =  fray1_FAAR_WE_SysStMod_byt;               // fray1_dump_err_data 1         System State
             cal1_FAAR_WE_BattVltg_BrdgVltg_fp          =  fray1_FAAR_WE_BattVltg_BrdgVltg_fp;       // fray1_dump_err_data 2         Battery Voltage
             cal1_FAAR_WE_BattRtnCurrAmpr_fp            =  fray1_FAAR_WE_BattRtnCurrAmpr_fp;         // fray1_dump_err_data 3         Measured Battery Current
             cal1_FAAR_WE_HwAgArbn_fp                   =  fray1_FAAR_WE_HwAgArbn_fp;                // fray1_dump_err_data 4         Steering wheel angle
             cal1_FAAR_WE_HwTq4Meas_fp                  =  fray1_FAAR_WE_HwTq4Meas_fp;               // fray1_dump_err_data 5         Torque Sensor T1
             cal1_FAAR_WE_HwTq5Meas_fp                  =  fray1_FAAR_WE_HwTq5Meas_fp;               // fray1_dump_err_data 6         Torque Sensor T2
             cal1_FAAR_WE_HwTqArbn_fp                   =  fray1_FAAR_WE_HwTqArbn_fp;                // fray1_dump_err_data 7         Final Input Torque
             cal1_FAAR_WE_MotCurrSumA_fp                =  fray1_FAAR_WE_MotCurrSumA_fp;             // fray1_dump_err_data 8         Phase A Current
             cal1_FAAR_WE_MotCurrSumB_fp                =  fray1_FAAR_WE_MotCurrSumB_fp;             // fray1_dump_err_data 9         Phase B Current
             cal1_FAAR_WE_MotCurrSumC_fp                =  fray1_FAAR_WE_MotCurrSumC_fp;             // fray1_dump_err_data 10        Phase C Current
             cal1_FAAR_WE_MotVelCrf_fp                  =  fray1_FAAR_WE_MotVelCrf_fp;               // fray1_dump_err_data 11        Rotor Speed
             cal1_FAAR_WE_MotTqCmd_fp                   =  fray1_FAAR_WE_MotTqCmd_fp;                // fray1_dump_err_data 12        Requested Motor Torque
             cal1_FAAR_WE_MotTqEstimd_fp                =  fray1_FAAR_WE_MotTqEstimd_fp;             // fray1_dump_err_data 13        Estimated Motor Torque
             cal1_FAAR_WE_LoaSca_fp                     =  fray1_FAAR_WE_LoaSca_fp;                  // fray1_dump_err_data 14        Derating Vector
             cal1_FAAR_WE_EcuTMeas_fp                   =  fray1_FAAR_WE_EcuTMeas_fp;                // fray1_dump_err_data 15        Board Temp
             cal1_FAAR_WE_MotWidgT_fp                   =  fray1_FAAR_WE_MotWidgT_fp;                // fray1_dump_err_data 16        Estimated Motor Winding Temp
             cal1_FAAR_WE_MotMagT_fp                    =  fray1_FAAR_WE_MotMagT_fp;                 // fray1_dump_err_data 17        EstimatedMagnet Temp
             cal1_FAAR_WE_MotFetT_fp                    =  fray1_FAAR_WE_MotFetT_fp;                 // fray1_dump_err_data 18        Estimated FET Temp


             // ------------------------------------------------------------- Step 3a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/

             strcpy(sbuf_tx_main,"\nI'm at -- S T E P 3a    Just finished Request/store one time perametrics -- sent_data_array_pos_0nm \r\n");
                         sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
             trig();
                     sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

             torque_value_case_index = 0;   // zero nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 500;   // wait 500  for part to respond and relax
             while(system_msec_clock < system_msec_clock_temp);



             // ------------------------------------------------------------- Step 4 - Setup TOC for low-amp condition, request/store perimetrics   \/
                   // 0.50nm torque in positive direction for low value functional.

             ign1_status = NORMAL;

             torque_value_case_index = 3;   // pos .5nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
             while(system_msec_clock < system_msec_clock_temp);


             cal1_FAAR_WE_MtrCurrQax_low_pos_fp = 0.0;
             cal1_FAAR_WE_HwTrq_HwNm_low_pos_fp = 0.0;

      for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
             {
             // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

             fray_request_index = 0; // set index to start sequence at case 0 in ISR
             ShiftFRAY();

             system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
             while((fray_request_index != TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

             parse_can1_data();

             cal1_FAAR_WE_MtrCurrQax_low_pos_fp += fray1_FAAR_WE_MotTqEstimd_fp;
             cal1_FAAR_WE_HwTrq_HwNm_low_pos_fp += fray1_FAAR_WE_HwTqArbn_fp;

             }

             cal1_FAAR_WE_MtrCurrQax_low_pos_fp = cal1_FAAR_WE_MtrCurrQax_low_pos_fp / 10.0;
             cal1_FAAR_WE_HwTrq_HwNm_low_pos_fp = cal1_FAAR_WE_HwTrq_HwNm_low_pos_fp / 10.0;


             // ------------------------------------------------------------- Step 4a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
             strcpy(sbuf_tx_main,"\nI'm at -- S T E P 4a    Just finished sent_data_array_pos_p1nm \r\n");
                         sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

             trig(); // not necessary to trig(), but echo results to debug port is useful to monitor progress
                     sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

             torque_value_case_index = 0;   // zero nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
             while(system_msec_clock < system_msec_clock_temp);

             // ------------------------------------------------------------- Step 5 - Setup TOC for low-amp condition, request/store perimetrics   \/
                   // 0.50nm torque in negative direction for low value functional.

             torque_value_case_index = 4;   // neg .5nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
             while(system_msec_clock < system_msec_clock_temp);

             cal1_FAAR_WE_MtrCurrQax_low_neg_fp = 0.0;
             cal1_FAAR_WE_HwTrq_HwNm_low_neg_fp = 0.0;

     for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
             {
             // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

             fray_request_index = 0; // set index to start sequence at case 0 in ISR
             ShiftFRAY();

             system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
             while((fray_request_index != TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

             parse_can1_data();

             cal1_FAAR_WE_MtrCurrQax_low_neg_fp += fray1_FAAR_WE_MotTqEstimd_fp;
             cal1_FAAR_WE_HwTrq_HwNm_low_neg_fp += fray1_FAAR_WE_HwTqArbn_fp;

             }

             cal1_FAAR_WE_MtrCurrQax_low_neg_fp = cal1_FAAR_WE_MtrCurrQax_low_neg_fp / 10.0;
             cal1_FAAR_WE_HwTrq_HwNm_low_neg_fp = cal1_FAAR_WE_HwTrq_HwNm_low_neg_fp / 10.0;

             // ------------------------------------------------------------- Step 5a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
             strcpy(sbuf_tx_main,"\nI'm at -- S T E P 5a    Just finished sent_data_array_neg_p1nm \r\n");
                         sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
             trig();
                     sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

             torque_value_case_index = 0;   // zero nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
             while(system_msec_clock < system_msec_clock_temp);


             // ------------------------------------------------------------- Step 6 - Setup TOC for med-amp condition, request/store perimetrics \/
                     // 1.50nm torque in positive direction for med value functional.

             torque_value_case_index = 7;   // pos 1.5nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
             while(system_msec_clock < system_msec_clock_temp);

             cal1_FAAR_WE_MtrCurrQax_med_pos_fp = 0.0;
             cal1_FAAR_WE_HwTrq_HwNm_med_pos_fp = 0.0;

     for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
             {
             // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

             fray_request_index = 0; // set index to start sequence at case 0 in ISR
             ShiftFRAY();

             system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
             while((fray_request_index != TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

             parse_can1_data();

             cal1_FAAR_WE_MtrCurrQax_med_pos_fp += fray1_FAAR_WE_MotTqEstimd_fp;
             cal1_FAAR_WE_HwTrq_HwNm_med_pos_fp += fray1_FAAR_WE_HwTqArbn_fp;

             }

             cal1_FAAR_WE_MtrCurrQax_med_pos_fp = cal1_FAAR_WE_MtrCurrQax_med_pos_fp / 10.0;
             cal1_FAAR_WE_HwTrq_HwNm_med_pos_fp = cal1_FAAR_WE_HwTrq_HwNm_med_pos_fp / 10.0;

             // ------------------------------------------------------------- Step 6a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
             strcpy(sbuf_tx_main,"\nI'm at -- S T E P 6a    Just finished sent_data_array_pos_2p00nm\r\n");
                         sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
             trig();
                     sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

             torque_value_case_index = 0;   // zero nm torque

             set_torque_TOC_or_SENT_or_Analog();

             system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
             while(system_msec_clock < system_msec_clock_temp);

             // ------------------------------------------------------------- Step 7 - Setup TOC for med-amp condition, request/store perimetrics \/
                   // 1.50nm torque in negative direction for med value functional.

              torque_value_case_index = 8;   // neg 1.5nm torque

              set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
              while(system_msec_clock < system_msec_clock_temp);

              cal1_FAAR_WE_MtrCurrQax_med_neg_fp = 0.0;
              cal1_FAAR_WE_HwTrq_HwNm_med_neg_fp = 0.0;

      for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
              {
              // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

              fray_request_index = 0; // set index to start sequence at case 0 in ISR
              ShiftFRAY();

              system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
              while((fray_request_index != TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

              parse_can1_data();

              cal1_FAAR_WE_MtrCurrQax_med_neg_fp += fray1_FAAR_WE_MotTqEstimd_fp;
              cal1_FAAR_WE_HwTrq_HwNm_med_neg_fp += fray1_FAAR_WE_HwTqArbn_fp;

              }

              cal1_FAAR_WE_MtrCurrQax_med_neg_fp = cal1_FAAR_WE_MtrCurrQax_med_neg_fp / 10.0;
              cal1_FAAR_WE_HwTrq_HwNm_med_neg_fp = cal1_FAAR_WE_HwTrq_HwNm_med_neg_fp / 10.0;

             // ------------------------------------------------------------- Step 7a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
              strcpy(sbuf_tx_main,"\nI'm at -- S T E P 7a    Just finished sent_data_array_neg_2p00nm\r\n");
                          sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
              trig();
                      sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


              torque_value_case_index = 0;   // zero nm torque

              set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
              while(system_msec_clock < system_msec_clock_temp);

             // ------------------------------------------------------------- Step 8 - Setup TOC for high-amp condition, request/store perimetrics \/
                   // 2.00nm torque in positive direction only high value functional.

              torque_value_case_index = 9;   // pos 2.0nm torque

              set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
              while(system_msec_clock < system_msec_clock_temp);

              cal1_FAAR_WE_MtrCurrQax_high_pos_fp = 0.0;
              cal1_FAAR_WE_HwTrq_HwNm_high_pos_fp = 0.0;

      for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
              {
              // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

              fray_request_index = 0; // set index to start sequence at case 0 in ISR
              ShiftFRAY();

              system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
              while((fray_request_index != TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

              parse_can1_data();

              cal1_FAAR_WE_MtrCurrQax_high_pos_fp += fray1_FAAR_WE_MotTqEstimd_fp;
              cal1_FAAR_WE_HwTrq_HwNm_high_pos_fp += fray1_FAAR_WE_HwTqArbn_fp;

              }

              cal1_FAAR_WE_MtrCurrQax_high_pos_fp = cal1_FAAR_WE_MtrCurrQax_high_pos_fp / 10.0;
              cal1_FAAR_WE_HwTrq_HwNm_high_pos_fp = cal1_FAAR_WE_HwTrq_HwNm_high_pos_fp / 10.0;

             // ------------------------------------------------------------- Step 8a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
              strcpy(sbuf_tx_main,"\nI'm at -- S T E P 8a    Just finished sent_data_array_pos_4p00nm\r\n");
                          sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
              trig();
                      sciSend(sciREG,strlen(return_message),return_message);      // echo to port1


              torque_value_case_index = 0;   // zero nm torque

              set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
              while(system_msec_clock < system_msec_clock_temp);

             // ------------------------------------------------------------- Step 9 - Setup TOC for high-amp condition, request/store perimetrics \/
                   // 2.00nm torque in negative direction only high value functional.

              torque_value_case_index = 10;   // neg 2.0nm torque

              set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 500 mS, wait for system to stabilize
              while(system_msec_clock < system_msec_clock_temp);

              cal1_FAAR_WE_MtrCurrQax_high_neg_fp = 0.0;
              cal1_FAAR_WE_HwTrq_HwNm_high_neg_fp = 0.0;

      for(loop_cnt_d=0;loop_cnt_d < 10;loop_cnt_d++)      // averaging Motor Torque and Handwheel Torque
              {
              // push ccp_request_connect, this will kick off the rest of CAN CCP Commands from ISR

              fray_request_index = 0; // set index to start sequence at case 0 in ISR
              ShiftFRAY();

              system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
              while((fray_request_index != TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS last CAN reads are done, move on */

              parse_can1_data();

              cal1_FAAR_WE_MtrCurrQax_high_neg_fp += fray1_FAAR_WE_MotTqEstimd_fp;
              cal1_FAAR_WE_HwTrq_HwNm_high_neg_fp += fray1_FAAR_WE_HwTqArbn_fp;

              }

              cal1_FAAR_WE_MtrCurrQax_high_neg_fp = cal1_FAAR_WE_MtrCurrQax_high_neg_fp / 10.0;
              cal1_FAAR_WE_HwTrq_HwNm_high_neg_fp = cal1_FAAR_WE_HwTrq_HwNm_high_neg_fp / 10.0;

             // ------------------------------------------------------------- Step 9a - Return torque to 0.0Nm before next step (found issues with major torques changes, causing DCTs)  \/
              strcpy(sbuf_tx_main,"\nI'm at -- S T E P 9a    Just finished sent_data_array_neg_4p00nm\r\n");
                          sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1
              trig();
                      sciSend(sciREG,strlen(return_message),return_message);      // echo to port1

             torque_value_case_index = 0;   // zero nm torque

             set_torque_TOC_or_SENT_or_Analog();

              system_msec_clock_temp = system_msec_clock + 1000;  // wait 1000  for part to respond and relax
              while(system_msec_clock < system_msec_clock_temp);

             // ------------------------------------------------------------- Step 10 - Done testing, build data and  Get DCTs    \/
              sprintf(return_message,"%d,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                      cal1_FAAR_WE_SysStMod_byt, cal1_FAAR_WE_BattVltg_BrdgVltg_fp,\
                      cal1_FAAR_WE_BattRtnCurrAmpr_fp,cal1_FAAR_WE_HwAgArbn_fp,\
                      cal1_FAAR_WE_HwTq4Meas_fp,cal1_FAAR_WE_HwTq5Meas_fp,\
                      cal1_FAAR_WE_HwTqArbn_fp,cal1_FAAR_WE_MotCurrSumA_fp,\
                      cal1_FAAR_WE_MotCurrSumB_fp,cal1_FAAR_WE_MotCurrSumC_fp,\
                      cal1_FAAR_WE_MotVelCrf_fp,cal1_FAAR_WE_MotTqCmd_fp,\
                      cal1_FAAR_WE_MotTqEstimd_fp,cal1_FAAR_WE_LoaSca_fp,\
                      cal1_FAAR_WE_EcuTMeas_fp,cal1_FAAR_WE_MotWidgT_fp,\
                      cal1_FAAR_WE_MotMagT_fp,cal1_FAAR_WE_MotFetT_fp);         //18


               /* <23 at a time */

               sprintf(temp_return_message,"%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,",\
                       cal1_FAAR_WE_MtrCurrQax_low_pos_fp,cal1_FAAR_WE_MtrCurrQax_med_pos_fp,\
                       cal1_FAAR_WE_MtrCurrQax_high_pos_fp,cal1_FAAR_WE_MtrCurrQax_low_neg_fp,\
                       cal1_FAAR_WE_MtrCurrQax_med_neg_fp,cal1_FAAR_WE_MtrCurrQax_high_neg_fp,\
                       cal1_FAAR_WE_HwTrq_HwNm_low_pos_fp,cal1_FAAR_WE_HwTrq_HwNm_med_pos_fp,\
                       cal1_FAAR_WE_HwTrq_HwNm_high_pos_fp,cal1_FAAR_WE_HwTrq_HwNm_low_neg_fp,\
                       cal1_FAAR_WE_HwTrq_HwNm_med_neg_fp,cal1_FAAR_WE_HwTrq_HwNm_high_neg_fp);  //12

               strcat(return_message,temp_return_message);

       /*   All Done - fill it up with  N_A_num  (69-10-10-10-9 = 39    43) */

               sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
               N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
               strcat(return_message,temp_return_message);

               sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
               N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
               strcat(return_message,temp_return_message);

               sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
               N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //10
               strcat(return_message,temp_return_message);

               sprintf(temp_return_message,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",\
               N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num,N_A_num);   //9
               strcat(return_message,temp_return_message);

                       get_DTCs1();

                       strcat(return_message,dtc1_return_message);

               strcpy(sbuf_tx_main,"\r\nF I N I S H E D  -- Printing Results\r\n");
                           sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

               strcpy(sbuf_tx_main,"\r\n");
               strcat(sbuf_tx_main,return_message);
               strcat(sbuf_tx_main,"\r\n");

                       sciSend(sciREG,strlen(sbuf_tx_main),sbuf_tx_main);      // echo to port1

               switch(scilinREG_is_CIB_or_Monitor_or_WEB)
               {
                   case CIB:
                       if(((who_is_addressed == ALL) && (CIB_config_data.BOARD_ID[0] == '1'))||(who_is_addressed == ME)) // if p_on to buffer using 'E" and my address = 1
                       {
                          transmit_str_485(return_message);
                       }
                   break;

                   case WEB:
                       if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
                       {
                           transmit_str_485(return_message);
                       }
                   break;
               }

       // ------------------------------------------------------------- Step 12 - Clean up   DONE \/

               ign1_status = OFF;
               ign2_status = OFF;

               gioSetBit(hetPORT1, 14, 0); /* turn off Product Ign1 */
               gioSetBit(hetPORT1, 15, 0); /* turn off Product Ign2 */

               gioSetBit(hetPORT1, 31, 0);     /* turn off Product Ign, Turn off here, no buffer board in B_CIB system */


        break;
        } //end case TARGET_BMW_FAAR_WE:

        }  // end switch (target_product)

    break;
    }



    default:
    {
//              strcpy(return_message,"command error-syntax\r\n");
//      if(buffer_command == FALSE) /* my address? or all, if all dont print  */
//      {
//          transmit_str_485(return_message);
//      }


    }

    }    // end switch case_select in eval command string


}   // end of eval_command_string()

void ShiftFRAY(void)
//send connect message
{
    transmitFlexray(XCP_TX_request_connect_MSG, XCP_TX, 2);
}       // end ShiftCAN function

void    ShiftCAN1   ( void )
    //send connect message on CAN1
{
    switch (target_product)
    {
    case TARGET_T1XX:       //EA4 is different
    case TARGET_BYD_SA2FL:
    case TARGET_C1XX:
    case TARGET_9BXX:
        canTransmit(canREG1, CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;
    case TARGET_GWM_A0607:
        canTransmit(canREG1, GWM_A0607_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);  
    break;
    case TARGET_FCA_ADAS:
        canTransmit(canREG1, FCA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;

    case TARGET_CD391_ADAS:
        canTransmit(canREG1, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;

    case TARGET_G2KCA_ADAS:
        canTransmit(canREG1, G2KCA_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;

    case TARGET_PSA_CMP:
        canTransmit(canREG1, PSA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;

    case TARGET_SGMW_CN200:
        canTransmit(canREG1, CN200_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;

    case TARGET_FORD_T3_T6:
        canTransmit(canREG1, FORD_T3_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;

    case TARGET_RENAULT_NISSAN:
        canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;

    }
}       // end ShiftCAN1 function

void    ShiftCAN2   ( void )
    //send connect message on CAN2
{
    switch (target_product)
    {
    case TARGET_T1XX:       //EA4 is different
    case TARGET_BYD_SA2FL:
    case TARGET_C1XX:
    case TARGET_9BXX:
        canTransmit(canREG2, CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;
    case TARGET_GWM_A0607:
        canTransmit(canREG2, GWM_A0607_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);   
    break;
    case TARGET_FCA_ADAS:
        canTransmit(canREG2, FCA_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;

    case TARGET_CD391_ADAS:
        canTransmit(canREG2, FORD_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;

    case TARGET_G2KCA_ADAS:
        canTransmit(canREG1, G2KCA_ECU2_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;

    case TARGET_PSA_CMP:
    break;

    case TARGET_SGMW_CN200:
    break;

    case TARGET_FORD_T3_T6:
        canTransmit(canREG1, FORD_T3_ECU2_CAN1_CCP_REQUEST_ID, ( uint8 *) ccp_request_connect);
    break;

    case TARGET_RENAULT_NISSAN:
    break;
    }
}       // end ShiftCAN2 function

void get_DTCs1(void)
{
    // set all DTCs to -1 in case service fails
    // when called set timeout or  DTC_XCP_rply_indx = end

    for(ECU1_dtc_loop_cnt = 0;ECU1_dtc_loop_cnt < 21;ECU1_dtc_loop_cnt++)
     {
       for(ECU1_dtc_inner_loop_cnt = 0;ECU1_dtc_inner_loop_cnt < 5;ECU1_dtc_inner_loop_cnt++)
        {
        dtc1[ECU1_dtc_loop_cnt][ECU1_dtc_inner_loop_cnt] =  0xFF;
        }
     }

    tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on


    ECU1_XCP_reply_index = 1;
    ECU1_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

    switch (target_product)
    {
    case TARGET_T1XX:       //EA4 is different
            canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 14) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;

    case TARGET_BYD_SA2FL:
            canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 14) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;

    case TARGET_GWM_A0607:
            canTransmit(canREG1, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 14) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;
    case TARGET_C1XX:
    case TARGET_9BXX:
        canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

        system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
        while((ECU1_XCP_reply_index < 14) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;
    case TARGET_FCA_ADAS:
            canTransmit(canREG1, FCA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 14) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;
    case TARGET_CD391_ADAS:
            canTransmit(canREG1, FORD_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);   // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 14) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;
    case TARGET_G2KCA_ADAS:     //EA4 is different  GM ADAS is different
            canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 17) && (system_msec_clock < system_msec_clock_temp));       // changed to <17 from 14 for NEW 5 byte DTCs number

    break;
    case TARGET_PSA_CMP:
        canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

        system_msec_clock_temp = system_msec_clock + 700;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
        while((ECU1_XCP_reply_index < 14) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;
    case TARGET_SGMW_CN200:       //EA4 is different
            canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 17) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;
    case TARGET_FORD_T3_T6:       //EA4 is different
            canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 17) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;
    case TARGET_RENAULT_NISSAN:       //EA4 is different
            canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 17) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;
    case TARGET_BMW_UKL:
            transmitFlexray(Nexteer_session, MFG_TX,2);

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 2) && (system_msec_clock < system_msec_clock_temp));    // changed to <14 from 12 for NEW 5 byte DTCs number

            system_msec_clock_temp = system_msec_clock + 100;    // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((system_msec_clock < system_msec_clock_temp));
            transmitFlexray(Get_UKL_DTC_Rqst,MFG_TX, 2);

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 7) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;

    case TARGET_BMW_FAAR_WE:
            transmitFlexray(MFG_TX_nexteer_session_MSG, MFG_TX,3);

            system_msec_clock_temp = system_msec_clock + 1200;  // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU1_XCP_reply_index < 7) && (system_msec_clock < system_msec_clock_temp));    // changed to <14 from 12 for NEW 5 byte DTCs number

            //system_msec_clock_temp = system_msec_clock + 100;    // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            //while((system_msec_clock < system_msec_clock_temp));
            //transmitFlexray(MFG_TX_get_dtcs_MSG,MFG_TX, 3);

            //system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            //while((ECU1_XCP_reply_index < 7) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;

    }
//  system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
//  while((DTC_XCP_rply_indx < 14) && (system_msec_clock < system_msec_clock_temp));      // changed to <14 from 12 for NEW 5 byte DTCs number

    switch (target_product)
    {
// T1XX is special, DCTs are located later in the dump string.
    case TARGET_T1XX:
    case TARGET_GWM_A0607:
    {
    // rows 39-42 DTCs 1-4  47-50
    sprintf(dtc1_return_message,\
    "47,%.1X%.2X:%.2X:%.2X:%.2X,48,%.1X%.2X:%.2X:%.2X:%.2X,49,%.1X%.2X:%.2X:%.2X:%.2X,50,%.1X%.2X:%.2X:%.2X:%.2X,",\
    dtc1[0][0],dtc1[0][1],dtc1[0][2],dtc1[0][3],dtc1[0][4],dtc1[1][0],dtc1[1][1],dtc1[1][2],dtc1[1][3],dtc1[1][4],dtc1[2][0],dtc1[2][1],\
    dtc1[2][2],dtc1[2][3],dtc1[2][4],dtc1[3][0],dtc1[3][1],dtc1[3][2],dtc1[3][3],dtc1[3][4]);

    // rows 43-46 DTCs 5-8  51-54
    sprintf(temp_return_message,\
    "51,%.1X%.2X:%.2X:%.2X:%.2X,52,%.1X%.2X:%.2X:%.2X:%.2X,53,%.1X%.2X:%.2X:%.2X:%.2X,54,%.1X%.2X:%.2X:%.2X:%.2X,",\
    dtc1[4][0],dtc1[4][1],dtc1[4][2],dtc1[4][3],dtc1[4][4],dtc1[5][0],dtc1[5][1],dtc1[5][2],dtc1[5][3],dtc1[5][4],dtc1[6][0],dtc1[6][1],\
    dtc1[6][2],dtc1[6][3],dtc1[6][4],dtc1[7][0],dtc1[7][1],dtc1[7][2],dtc1[7][3],dtc1[7][4]);

    strcat(dtc1_return_message,temp_return_message);

    // rows 47-50 DTCs 9-12     55-58
    sprintf(temp_return_message,\
    "55,%.1X%.2X:%.2X:%.2X:%.2X,56,%.1X%.2X:%.2X:%.2X:%.2X,57,%.1X%.2X:%.2X:%.2X:%.2X,58,%.1X%.2X:%.2X:%.2X:%.2X,",\
    dtc1[8][0],dtc1[8][1],dtc1[8][2],dtc1[8][3],dtc1[8][4],dtc1[9][0],dtc1[9][1],dtc1[9][2],dtc1[9][3],dtc1[9][4],dtc1[10][0],dtc1[10][1],\
    dtc1[10][2],dtc1[10][3],dtc1[10][4],dtc1[11][0],dtc1[11][1],dtc1[11][2],dtc1[11][3],dtc1[11][4]);

    strcat(dtc1_return_message,temp_return_message);

    // rows 41-53 DTCs 13-15    59-61
    sprintf(temp_return_message,\
    "59,%.1X%.2X:%.2X:%.2X:%.2X,60,%.1X%.2X:%.2X:%.2X:%.2X,61,%.1X%.2X:%.2X:%.2X:%.2X \r",\
    dtc1[12][0],dtc1[12][1],dtc1[12][2],dtc1[12][3],dtc1[12][4],dtc1[13][0],dtc1[13][1],dtc1[13][2],dtc1[13][3],dtc1[13][4],dtc1[14][0],dtc1[14][1],\
    dtc1[14][2],dtc1[14][3],dtc1[14][4]);

    strcat(dtc1_return_message,temp_return_message);
    break;
    }
// in the case we have only one ECU, we store 15 consecutive DCTs, unlike the case where we have two ECUs
    case TARGET_C1XX:
    case TARGET_PSA_CMP:
    case TARGET_SGMW_CN200:
    case TARGET_RENAULT_NISSAN:
    {
    // rows 39-42 DTCs 1-4
    sprintf(dtc1_return_message,\
    "39,%.1X%.2X:%.2X:%.2X:%.2X,40,%.1X%.2X:%.2X:%.2X:%.2X,41,%.1X%.2X:%.2X:%.2X:%.2X,42,%.1X%.2X:%.2X:%.2X:%.2X,",\
    dtc1[0][0],dtc1[0][1],dtc1[0][2],dtc1[0][3],dtc1[0][4],dtc1[1][0],dtc1[1][1],dtc1[1][2],dtc1[1][3],dtc1[1][4],dtc1[2][0],dtc1[2][1],\
    dtc1[2][2],dtc1[2][3],dtc1[2][4],dtc1[3][0],dtc1[3][1],dtc1[3][2],dtc1[3][3],dtc1[3][4]);

    // rows 43-46 DTCs 5-8
    sprintf(temp_return_message,\
    "43,%.1X%.2X:%.2X:%.2X:%.2X,44,%.1X%.2X:%.2X:%.2X:%.2X,45,%.1X%.2X:%.2X:%.2X:%.2X,46,%.1X%.2X:%.2X:%.2X:%.2X,",\
    dtc1[4][0],dtc1[4][1],dtc1[4][2],dtc1[4][3],dtc1[4][4],dtc1[5][0],dtc1[5][1],dtc1[5][2],dtc1[5][3],dtc1[5][4],dtc1[6][0],dtc1[6][1],\
    dtc1[6][2],dtc1[6][3],dtc1[6][4],dtc1[7][0],dtc1[7][1],dtc1[7][2],dtc1[7][3],dtc1[7][4]);

    strcat(dtc1_return_message,temp_return_message);

    // rows 47-51 DTCs 9-12
    sprintf(temp_return_message,\
    "47,%.1X%.2X:%.2X:%.2X:%.2X,48,%.1X%.2X:%.2X:%.2X:%.2X,49,%.1X%.2X:%.2X:%.2X:%.2X,50,%.1X%.2X:%.2X:%.2X:%.2X,",\
    dtc1[8][0],dtc1[8][1],dtc1[8][2],dtc1[8][3],dtc1[8][4],dtc1[9][0],dtc1[9][1],dtc1[9][2],dtc1[9][3],dtc1[9][4],dtc1[10][0],dtc1[10][1],\
    dtc1[10][2],dtc1[10][3],dtc1[10][4],dtc1[11][0],dtc1[11][1],dtc1[11][2],dtc1[11][3],dtc1[11][4]);

    strcat(dtc1_return_message,temp_return_message);

    // rows 51-53 DTCs 13-15
    sprintf(temp_return_message,\
    "51,%.1X%.2X:%.2X:%.2X:%.2X,52,%.1X%.2X:%.2X:%.2X:%.2X,53,%.1X%.2X:%.2X:%.2X:%.2X \r",\
    dtc1[12][0],dtc1[12][1],dtc1[12][2],dtc1[12][3],dtc1[12][4],dtc1[13][0],dtc1[13][1],dtc1[13][2],dtc1[13][3],dtc1[13][4],dtc1[14][0],dtc1[14][1],\
    dtc1[14][2],dtc1[14][3],dtc1[14][4]);

    strcat(dtc1_return_message,temp_return_message);
    break;
    }
// in the case we have two ECUs, for ECU1 we only store the first 7 dcts, saving the rest (of the 14 + one N/A field- to visually separate) of the fields for ECU2.
    case TARGET_FCA_ADAS:
    case TARGET_CD391_ADAS:
    case TARGET_G2KCA_ADAS:
    case TARGET_FORD_T3_T6:
    {
    // rows 39-42 DTCs 1-4
    sprintf(dtc1_return_message,\
    "39,%.1X%.2X:%.2X:%.2X:%.2X,40,%.1X%.2X:%.2X:%.2X:%.2X,41,%.1X%.2X:%.2X:%.2X:%.2X,42,%.1X%.2X:%.2X:%.2X:%.2X,",\
    dtc1[0][0],dtc1[0][1],dtc1[0][2],dtc1[0][3],dtc1[0][4],dtc1[1][0],dtc1[1][1],dtc1[1][2],dtc1[1][3],dtc1[1][4],dtc1[2][0],dtc1[2][1],\
    dtc1[2][2],dtc1[2][3],dtc1[2][4],dtc1[3][0],dtc1[3][1],dtc1[3][2],dtc1[3][3],dtc1[3][4]);

    // rows 43-45 DTCs 5-7
    sprintf(temp_return_message,\
    "43,%.1X%.2X:%.2X:%.2X:%.2X,44,%.1X%.2X:%.2X:%.2X:%.2X,45,%.1X%.2X:%.2X:%.2X:%.2X,",\
    dtc1[4][0],dtc1[4][1],dtc1[4][2],dtc1[4][3],dtc1[4][4],dtc1[5][0],dtc1[5][1],dtc1[5][2],dtc1[5][3],dtc1[5][4],dtc1[6][0],dtc1[6][1],\
    dtc1[6][2],dtc1[6][3],dtc1[6][4]);

    strcat(dtc1_return_message,temp_return_message);

    break;
    }

    case TARGET_9BXX:
    {
        sprintf(dtc1_return_message,"Haven't been written yet.");
        break;
    }

    case TARGET_BMW_FAAR_WE:
    case TARGET_BMW_UKL:
    {
        // rows 39-42 DTCs 1-4
        sprintf(dtc1_return_message,\
                "39,%.1X%.2X:%.2X:%.2X:%.2X,40,%.1X%.2X:%.2X:%.2X:%.2X,41,%.1X%.2X:%.2X:%.2X:%.2X,42,%.1X%.2X:%.2X:%.2X:%.2X,",\
                dtc1[0][0],dtc1[0][1],dtc1[0][2],dtc1[0][3],dtc1[0][4],dtc1[1][0],dtc1[1][1],dtc1[1][2],dtc1[1][3],dtc1[1][4],dtc1[2][0],dtc1[2][1],\
                dtc1[2][2],dtc1[2][3],dtc1[2][4],dtc1[3][0],dtc1[3][1],dtc1[3][2],dtc1[3][3],dtc1[3][4]);

        // rows 43-46 DTCs 5-8
        sprintf(temp_return_message,\
                "43,%.1X%.2X:%.2X:%.2X:%.2X,44,%.1X%.2X:%.2X:%.2X:%.2X,45,%.1X%.2X:%.2X:%.2X:%.2X,46,%.1X%.2X:%.2X:%.2X:%.2X,",\
                dtc1[4][0],dtc1[4][1],dtc1[4][2],dtc1[4][3],dtc1[4][4],dtc1[5][0],dtc1[5][1],dtc1[5][2],dtc1[5][3],dtc1[5][4],dtc1[6][0],dtc1[6][1],\
                dtc1[6][2],dtc1[6][3],dtc1[6][4],dtc1[7][0],dtc1[7][1],dtc1[7][2],dtc1[7][3],dtc1[7][4]);

        strcat(dtc1_return_message,temp_return_message);

        // rows 47-50 DTCs 9-12
        sprintf(temp_return_message,\
                "47,%.1X%.2X:%.2X:%.2X:%.2X,48,%.1X%.2X:%.2X:%.2X:%.2X,49,%.1X%.2X:%.2X:%.2X:%.2X,50,%.1X%.2X:%.2X:%.2X:%.2X,",\
                dtc1[8][0],dtc1[8][1],dtc1[8][2],dtc1[8][3],dtc1[8][4],dtc1[9][0],dtc1[9][1],dtc1[9][2],dtc1[9][3],dtc1[9][4],dtc1[10][0],dtc1[10][1],\
                dtc1[10][2],dtc1[10][3],dtc1[10][4],dtc1[11][0],dtc1[11][1],dtc1[11][2],dtc1[11][3],dtc1[11][4]);

        strcat(dtc1_return_message,temp_return_message);

        // rows 41-53 DTCs 13-15
        sprintf(temp_return_message,\
                "51,%.1X%.2X:%.2X:%.2X:%.2X,52,%.1X%.2X:%.2X:%.2X:%.2X,53,%.1X%.2X:%.2X:%.2X:%.2X \r",\
                dtc1[12][0],dtc1[12][1],dtc1[12][2],dtc1[12][3],dtc1[12][4],dtc1[13][0],dtc1[13][1],dtc1[13][2],dtc1[13][3],dtc1[13][4],dtc1[14][0],dtc1[14][1],\
                dtc1[14][2],dtc1[14][3],dtc1[14][4]);

        strcat(dtc1_return_message,temp_return_message);
        break;
    }

    }  // end switch (target_product)

}       // end get_DTCs1 function

void get_DTCs2(void)
{
    // set all DTCs to -1 in case service fails
    // when called set timeout or  DTC_XCP_rply_indx = end

    for(ECU2_dtc_loop_cnt = 0;ECU2_dtc_loop_cnt < 21;ECU2_dtc_loop_cnt++)
     {
       for(ECU2_dtc_inner_loop_cnt = 0;ECU2_dtc_inner_loop_cnt < 5;ECU2_dtc_inner_loop_cnt++)
        {
        dtc2[ECU2_dtc_loop_cnt][ECU2_dtc_inner_loop_cnt] =  0xFF;
        }
     }

    ECU2_XCP_reply_index = 1;
    ECU2_clear_DTCs_flag = 0; // make sure it is get DTC's  NOT clear

    tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on


    switch (target_product)
    {
    case TARGET_T1XX:       //T1XX has no ECU2
//          canTransmit(canREG2, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
    break;

    case TARGET_BYD_SA2FL:       //BYD_SA2FL has no ECU2
    case TARGET_GWM_A0607:       //GWM_A0607 has no ECU2
//          canTransmit(canREG2, XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
    break;

//  case TARGET_C1XX:   // These targets have no ECU2
//  case TARGET_9BXX:
//          canTransmit(canREG2, XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
//  break;
    case TARGET_FCA_ADAS:
            canTransmit(canREG2, FCA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU2_clear_DTCs_flag < 14) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;
    case TARGET_CD391_ADAS:
            canTransmit(canREG2, FORD_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);   // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU2_clear_DTCs_flag < 14) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number

    break;
    case TARGET_G2KCA_ADAS:     //EA4 is different  GM ADAS is different
            canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU2_clear_DTCs_flag < 17) && (system_msec_clock < system_msec_clock_temp));       // changed to <17 from 14 for NEW 5 byte DTCs number

    break;
//    case TARGET_PSA_CMP:  // This target has no ECU2
//        canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
//
//        system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
//        while((ECU1_XCP_reply_index < 14) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number
//
//    break;
//    case TARGET_SGMW_CN200:  // This target has no ECU2
//        canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP
//
//        system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
//        while((ECU1_XCP_reply_index < 14) && (system_msec_clock < system_msec_clock_temp));       // changed to <14 from 12 for NEW 5 byte DTCs number
//
//    break;
    case TARGET_FORD_T3_T6:     //EA4 is different  Ford AE4 is different
            canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);    // open Nexteer session prior to XCP

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
            while((ECU2_clear_DTCs_flag < 17) && (system_msec_clock < system_msec_clock_temp));       // changed to <17 from 14 for NEW 5 byte DTCs number

    break;

    case TARGET_RENAULT_NISSAN:    // this target has no ECU2
    {

    break;
    }
    case TARGET_BMW_UKL:    // this target has no ECU2
    {

    break;
    }
    case TARGET_BMW_FAAR_WE:    // this target has no ECU2
    {

    break;
    }
    }   // end switch (target_product) request DCTs

//  system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
//  while((DTC_XCP_rply_indx < 14) && (system_msec_clock < system_msec_clock_temp));      // changed to <14 from 12 for NEW 5 byte DTCs number

    switch (target_product)
    {
    case TARGET_T1XX:
    {

    break;
    }

    case TARGET_BYD_SA2FL:
    case TARGET_GWM_A0607:
    {

    break;
    }

    case TARGET_C1XX:
    {

    break;
    }

    case TARGET_9BXX:        // this target has no ECU2
    {

    break;
    }

    case TARGET_PSA_CMP:    // this target has no ECU2
    {

    break;
    }
    case TARGET_SGMW_CN200:    // this target has no ECU2
    {

    break;
    }
    case TARGET_RENAULT_NISSAN:    // this target has no ECU2
    {

    break;
    }
    case TARGET_BMW_UKL:    // this target has no ECU2
    {

    break;
    }
    case TARGET_BMW_FAAR_WE:    // this target has no ECU2
    {

    break;
    }
// in the case we have two ECUs, for ECU1 we only store the first 7 dcts, saving the rest (of the 14 + one N/A field- to visually separate) of the fields for ECU2.
    case TARGET_FCA_ADAS:
    case TARGET_CD391_ADAS:
    case TARGET_G2KCA_ADAS:
    case TARGET_FORD_T3_T6:
    {
    // rows 47-50 DTCs 1-4
    sprintf(dtc2_return_message,\
    "47,%.1X%.2X:%.2X:%.2X:%.2X,48,%.1X%.2X:%.2X:%.2X:%.2X,49,%.1X%.2X:%.2X:%.2X:%.2X,50,%.1X%.2X:%.2X:%.2X:%.2X,",\
    dtc2[0][0],dtc2[0][1],dtc2[0][2],dtc2[0][3],dtc2[0][4],dtc2[1][0],dtc2[1][1],dtc2[1][2],dtc2[1][3],dtc2[1][4],dtc2[2][0],dtc2[2][1],\
    dtc2[2][2],dtc2[2][3],dtc2[2][4],dtc2[3][0],dtc2[3][1],dtc2[3][2],dtc2[3][3],dtc2[3][4]);

    // rows 51-53 DTCs 5-7
    sprintf(temp_return_message,\
    "51,%.1X%.2X:%.2X:%.2X:%.2X,52,%.1X%.2X:%.2X:%.2X:%.2X,53,%.1X%.2X:%.2X:%.2X:%.2X \r",\
    dtc2[4][0],dtc2[4][1],dtc2[4][2],dtc2[4][3],dtc2[4][4],dtc2[5][0],dtc2[5][1],dtc2[5][2],dtc2[5][3],dtc2[5][4],dtc2[6][0],dtc2[6][1],\
    dtc2[6][2],dtc2[6][3],dtc2[6][4]);

    strcat(dtc2_return_message,temp_return_message);


    break;
    }

    }  // end switch (target_product) stuff return string with DCT information

}       // end get_DTCs2 function

void trig( void )

{
    switch (target_product)
    {
    case TARGET_T1XX:
    {
        if(ign1_status > OFF)   /* ok to talk CAN and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();                //send connect message

            system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
            while((can1_request_index != T1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can1_request_index != T1XX_CAN_DATA_REQUESTS)
            {

                can1_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN1();                //send CAN1 connect message

                system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                while((can1_request_index != T1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can1_request_index == T1XX_CAN_DATA_REQUESTS)    /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can1_data();

                if(can_T1XX_SystemState_byt == 0xcc00)  /* State = shutdown */
                                fault1_cnt = 1;
                if(can_T1XX_SystemState_byt == 0x3304)  /* State = soft disable */
                    fault2_cnt = 1;
                if(can_T1XX_SystemState_byt == 0x3308)  /* State = hard disable */
                    fault3_cnt = 1;
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d,1,%d,2,%d:%d:%d:%d,3,%d,4,%d,5,%d,6,%d,7,%d,8,%d,9,%d,10,%d,11,%d,12,%d,13,%d,14,%d,",\

                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,fault1_cnt,fault2_cnt,\
                trig_flag,\

                N_A_num,can1_sys_state_warm_init,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                dumperr_Product1_5volt,value_sent5_ChA_T1_cnt,\
                value_sent6_ChA_T2_cnt,value_sent7_ChB_T1_cnt,\
                value_sent8_ChB_T2_cnt,value_sent1_Adr0_ChA0_Pos_cnt,\
                value_sent2_Adr0_ChB0_Pos_cnt,value_sent3_Adr1_ChA1_Pos_cnt,\
                value_sent4_Adr1_ChB1_Pos_cnt,can_T1XX_SystemState_byt);

                sprintf(temp_return_message,\
        "15,%.3f,16,%.3f,17,%.3f,18,%.3f,19,%.3f,20,%.3f,21,%.3f,22,%.3f,23,%.3f,24,%.3f,25,%.3f,26,%.3f,27,%.3f,28,%.3f,29,%.3f,30,%.3f,31,%.3f,32,%.3f,33,%.3f,34,%.3f,35,%.3f,36,%.3f,37,%.3f,38,%.3f,",\
                can_T1XX_MotCurrQax_fp,can_T1XX_HwTq0Meas_HwTq0_fp,\
                can_T1XX_HwTq1Meas_HwTq1_fp,can_T1XX_HwTq2Meas_HwTq2_fp,\
                can_T1XX_HwTq3Meas_HwTq3_fp,can_T1XX_EcuTFild_fp,\
                can_T1XX_HwAgArbn_HwAg_fp,can_T1XX_HwAg0_fp,\
                can_T1XX_HwAg1_fp,can_T1XX_HwTqArbn_HwTq_fp,\
                can_T1XX_MotCurrDax_fp,can_T1XX_HwTqArbn_HwTqChA_fp,\
                can_T1XX_HwTqArbn_HwTqChB_fp,can_T1XX_MotAgCmp_fp,\
                can_T1XX_BattVltg_fp,can_T1XX_BattVltgSwd1_fp,\
                can_T1XX_BattVltgSwd2_fp,can_T1XX_BrdgVltg_fp,\
                can_T1XX_AssiCmdBas_fp,can_T1XX_MotTqCmd_fp,\
                can_T1XX_AssiMechT_fp,can_T1XX_MotFetT_fp,\
                can_T1XX_MotMagT_fp,can_T1XX_MotWidgT_fp);

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "39,%.3f,40,%.3f,41,%.3f,42,%.3f,43,%.3f,44,%.3f,45,%.3f,46,%.3f,",\
                can_T1XX_MotREstim_fp,can_T1XX_MotTq_fp,\
                can_T1XX_MotCurrQax1_fp,can_T1XX_MotCurrQax2_fp,\
                can_T1XX_MotCurrQax3_fp,can_T1XX_HwTqArbn_HwTq1_fp,\
                can_T1XX_HwTqArbn_HwTq2_fp,can_T1XX_HwTqArbn_HwTq3_fp);

                strcat(return_message,temp_return_message);

            // 47 - 61 is DTCs
                get_DTCs1();

                strcat(return_message,dtc1_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

    //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

                /* dump will show, no CAN Response but prod may be running, faultX_cnt is where can1_request_index stopped */
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d,1,%d,2,%d:%d:%d:%d,3,%d,4,%d,5,%d,6,%d,7,%d,8,%d,9,%d,10,%d,11,%d,12,%d,13,%d,14,1,",\
                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,fault1_cnt,fault2_cnt,\
                trig_flag,\

                N_A_num,can1_sys_state_warm_init,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                dumperr_Product1_5volt,value_sent5_ChA_T1_cnt,\
                value_sent6_ChA_T2_cnt,value_sent7_ChB_T1_cnt,\
                value_sent8_ChB_T2_cnt,value_sent1_Adr0_ChA0_Pos_cnt,\
                value_sent2_Adr0_ChB0_Pos_cnt,value_sent3_Adr1_ChA1_Pos_cnt,\
                value_sent4_Adr1_ChB1_Pos_cnt);


                sprintf(temp_return_message,\
        "15,1,16,1,17,1,18,1,19,1,20,1,21,1,22,1,23,1,24,1,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,1,33,1,34,1,35,1,36,1,37,1,38,1,");

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,");

                strcat(return_message,temp_return_message);

            // 47 - 61 is DTCs
                strcpy(temp_return_message,\
        "47,1,48,1,49,1,50,1,51,1,52,1,53,1,54,1,55,1,56,1,57,1,58,1,59,1,60,1,61,1\r");

                strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

    //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d,1,%d,2,%d:%d:%d:%d,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,",\
            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,fault1_cnt,fault2_cnt,\
            trig_flag,\

            N_A_num,can1_sys_state_warm_init,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status);

            sprintf(temp_return_message,\
        "15,0,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,33,0,34,0,35,0,36,0,37,0,38,0,");

            strcat(return_message,temp_return_message);

            sprintf(temp_return_message,\
        "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,");

            strcat(return_message,temp_return_message);

        // 47 - 61 is DTCs
            strcpy(temp_return_message,\
        "47,0,48,0,49,0,50,0,51,0,52,0,53,0,54,0,55,0,56,0,57,0,58,0,59,0,60,0,61,0\r");

            strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */
    break;
    }
    case TARGET_GWM_A0607:
    {
        if(ign1_status > OFF)   /* ok to talk CAN and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();                //send connect message

            system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
            while((can1_request_index != GWM_A0607_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can1_request_index != GWM_A0607_CAN_DATA_REQUESTS)
            {

                can1_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN1();                //send CAN1 connect message

                system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                while((can1_request_index != GWM_A0607_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can1_request_index == GWM_A0607_CAN_DATA_REQUESTS)    /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can1_data();

 //               if(can_BYD_SA2FL_SystemState_byt == 0xcc00)  /* State = shutdown */
 //                              fault1_cnt = 1;
 //               if(can_BYD_SA2FL_SystemState_byt == 0x3304)  /* State = soft disable */
 //                   fault2_cnt = 1;
 //               if(can_BYD_SA2FL_SystemState_byt == 0x3308)  /* State = hard disable */
//                    fault3_cnt = 1;
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d,1,%d,2,%d:%d:%d:%d,3,%d,4,%d,5,%d,6,%d,7,%d,8,%d,9,%d,10,%d,11,%d,12,%d,13,%d,14,%d,",\

                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,fault1_cnt,fault2_cnt,\
                trig_flag,\

                N_A_num,can1_sys_state_warm_init,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                dumperr_Product1_5volt,value_sent5_ChA_T1_cnt,\
                value_sent6_ChA_T2_cnt,value_sent7_ChB_T1_cnt,\
                value_sent8_ChB_T2_cnt,value_sent1_Adr0_ChA0_Pos_cnt,\
                value_sent2_Adr0_ChB0_Pos_cnt,value_sent3_Adr1_ChA1_Pos_cnt,\
                value_sent4_Adr1_ChB1_Pos_cnt,can_GWM_A0607_SystemState_byt);

                sprintf(temp_return_message,\
        "15,%.3f,16,%.3f,17,%.3f,18,%.3f,19,%.3f,20,%.3f,21,%.3f,22,%.3f,23,%.3f,24,%s,25,%s,26,%s,27,%s,28,%s,29,%s,30,%s,31,%s,32,%s,33,%s,34,%s,35,%s,36,%s,37,%s,38,%s,",\
                can_GWM_A0607_MotCurrQax_fp,can_GWM_A0607_HwTq0Meas_HwTq4_fp,\
                can_GWM_A0607_HwTq1Meas_HwTq5_fp,can_GWM_A0607_MotHwPosn_fp,\
                can_GWM_A0607_BattVltg_fp,can_GWM_A0607_MotTq_fp,\
                can_GWM_A0607_HwTrq_fp,can_GWM_A0607_MotMagTestim_fp,\
                can_GWM_A0607_ECUTFilt_fp,N_A_str,\
                N_A_str,N_A_str,\
                N_A_str,N_A_str,\
                N_A_str,N_A_str,\
                N_A_str,N_A_str,\
                N_A_str,N_A_str,\
                N_A_str,N_A_str,\
                N_A_str,N_A_str);

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\

        "39,%s,40,%s,41,%.3f,42,%.3f,43,%.3f,44,%.3f,45,%.3f,46,%.3f,",\
                N_A_str,N_A_str,\
                can_GWM_A0607_MotCurrQax1_fp,can_GWM_A0607_MotCurrQax2_fp,\
                can_GWM_A0607_MotCurrQax3_fp,can_GWM_A0607_HwTqArbn_HwTq1_fp,\
                can_GWM_A0607_HwTqArbn_HwTq2_fp,can_GWM_A0607_HwTqArbn_HwTq3_fp);

                strcat(return_message,temp_return_message);

            // 47 - 61 is DTCs
                get_DTCs1();

                strcat(return_message,dtc1_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

    //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

                /* dump will show, no CAN Response but prod may be running, faultX_cnt is where can1_request_index stopped */
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d,1,%d,2,%d:%d:%d:%d,3,%d,4,%d,5,%d,6,%d,7,%d,8,%d,9,%d,10,%d,11,%d,12,%d,13,%d,14,1,",\
                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,fault1_cnt,fault2_cnt,\
                trig_flag,\

                N_A_num,can1_sys_state_warm_init,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                dumperr_Product1_5volt,value_sent5_ChA_T1_cnt,\
                value_sent6_ChA_T2_cnt,value_sent7_ChB_T1_cnt,\
                value_sent8_ChB_T2_cnt,value_sent1_Adr0_ChA0_Pos_cnt,\
                value_sent2_Adr0_ChB0_Pos_cnt,value_sent3_Adr1_ChA1_Pos_cnt,\
                value_sent4_Adr1_ChB1_Pos_cnt);


                sprintf(temp_return_message,\
        "15,1,16,1,17,1,18,1,19,1,20,1,21,1,22,1,23,1,24,1,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,1,33,1,34,1,35,1,36,1,37,1,38,1,");

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,");

                strcat(return_message,temp_return_message);

            // 47 - 61 is DTCs
                strcpy(temp_return_message,\
        "47,1,48,1,49,1,50,1,51,1,52,1,53,1,54,1,55,1,56,1,57,1,58,1,59,1,60,1,61,1\r");

                strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

    //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d,1,%d,2,%d:%d:%d:%d,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,",\
            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,fault1_cnt,fault2_cnt,\
            trig_flag,\

            N_A_num,can1_sys_state_warm_init,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status);

            sprintf(temp_return_message,\
        "15,0,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,33,0,34,0,35,0,36,0,37,0,38,0,");

            strcat(return_message,temp_return_message);

            sprintf(temp_return_message,\
        "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,");

            strcat(return_message,temp_return_message);

        // 47 - 61 is DTCs
            strcpy(temp_return_message,\
        "47,0,48,0,49,0,50,0,51,0,52,0,53,0,54,0,55,0,56,0,57,0,58,0,59,0,60,0,61,0\r");

            strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */
    break;
    }
    case TARGET_C1XX:
    {
        if(ign1_status > OFF)   /* ok to talk CAN and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();                //send CAN1 connect message

            system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
            while((can1_request_index != C1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can1_request_index != C1XX_CAN_DATA_REQUESTS)
            {

                can1_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN1();                //send connect message

                system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                while((can1_request_index != C1XX_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can1_request_index == C1XX_CAN_DATA_REQUESTS)    /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can1_data();

                if(can_C1XX_SystemState_byt == 0xcc00)  /* State = shutdown */
                                fault1_cnt = 1;
                if(can_C1XX_SystemState_byt == 0x3304)  /* State = soft disable */
                    fault2_cnt = 1;
                if(can_C1XX_SystemState_byt == 0x3308)  /* State = hard disable */
                    fault3_cnt = 1;
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d,1,%d,2,%d:%d:%d:%d,3,%d,4,%d,5,%d,6,%d,7,%d,8,%d,9,%.3f,10,%.3f,11,%.3f,12,%.3f,13,%.3f,14,%d,",\

                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,fault1_cnt,fault2_cnt,\
                trig_flag,\

                N_A_num,can1_sys_state_warm_init,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_5volt,\
                value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt,\
                value_sent1_Adr0_ChA0_Pos_cnt,value_sent2_Adr0_ChB0_Pos_cnt,\
                can_C1XX_BattVltg_fp,can_C1XX_Temperature_fp,\
                can_C1XX_DigT1_fp,can_C1XX_DigT2_fp,\
                can_C1XX_MtrCurrQax_fp,can_C1XX_OnStateFltAcc_cnt);

                sprintf(temp_return_message,\
        "15,%d,16,%d,17,%d,18,%.3f,19,%.3f,20,%.3f,21,%d,22,%.3f,23,%d,24,%d,25,%.3f,26,%.3f,27,%.3f,28,%.3f,29,%.3f,30,%.3f,31,%.3f,",\
                can_C1XX_GateDriveFltAcc_cnt,can_C1XX_GateDrvFltSts_cnt,\
                can_C1XX_SystemState_byt,can_C1XX_HwTrq_HwNm_fp,\
                can_C1XX_Abs_Hw_Pos_fp,can_C1XX_Rel_Hw_Pos_fp,\
                can_C1XX_ManualTrqCmdEn_cnt,can_C1XX_MtrTrq_Cmd_Nm_fp,\
                can_C1XX_MSB_Die1_cnt,can_C1XX_MSB_Die2_cnt,\
                can_C1XX_MtrTempEst_MagTempEst_DegC_fp,can_C1XX_MtrCurrQax1_fp,\
                can_C1XX_MtrCurrQax2_fp,can_C1XX_MtrCurrQax3_fp,\
                can_C1XX_HwTrq_HwNm1_fp,can_C1XX_HwTrq_HwNm2_fp,\
                can_C1XX_HwTrq_HwNm3_fp);

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "32,%s,33,%s,34,%s,35,%s,36,%s,36,%s,37,%s,38,%s,",\
                N_A_str,N_A_str,\
                N_A_str,N_A_str,\
                N_A_str,N_A_str,\
                N_A_str,N_A_str);

                strcat(return_message,temp_return_message);

            // 39 - 53 is DTCs
                get_DTCs1();

                strcat(return_message,dtc1_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

    //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

                /* dump will show, no CAN Response but prod may be running, faultX_cnt is where can1_request_index stopped */
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d,1,%d,2,%d:%d:%d:%d,3,%d,4,%d,5,%d,6,%d,7,%d,8,%d,9,1,10,1,11,1,12,1,13,1,14,1,",\
                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,fault1_cnt,fault2_cnt,\
                trig_flag,\

                N_A_num,can1_sys_state_warm_init,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_5volt,\
                value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt,\
                value_sent1_Adr0_ChA0_Pos_cnt,value_sent2_Adr0_ChB0_Pos_cnt);


                sprintf(temp_return_message,\
        "15,1,16,1,17,1,18,1,19,1,20,1,21,1,22,1,23,1,24,1,25,1,26,1,27,1,28,1,29,1,30,1,31,1,");

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "32,1,33,1,34,1,34,1,36,1,37,1,38,1,");

                strcat(return_message,temp_return_message);

            // 39 - 53 is DTCs
                strcpy(temp_return_message,\
        "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");

                strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

    //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d,1,%d,2,%d:%d:%d:%d,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,",\
            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,fault1_cnt,fault2_cnt,\
            trig_flag,\

            N_A_num,can1_sys_state_warm_init,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status);

            sprintf(temp_return_message,\
        "15,0,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,0,");

            strcat(return_message,temp_return_message);

            sprintf(temp_return_message,\
        "32,0,33,0,34,0,34,0,36,0,37,0,38,0,");

            strcat(return_message,temp_return_message);



        // 39 - 53 is DTCs
            strcpy(temp_return_message,\
        "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");

            strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */
    }
        break;
    case TARGET_9BXX:
    {
        sprintf(return_message,"Haven't been written yet.");
    }
        break;

    case TARGET_FCA_ADAS:
    {
        if(ign1_status > OFF)   /* ok to talk CAN1 and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();                //send CAN1 connect message

            system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
            while((can1_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can1_request_index != FCA_ADAS_CAN_DATA_REQUESTS)
            {

                can1_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN1();                //send CAN1 connect message

                system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                while((can1_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can1_request_index == FCA_ADAS_CAN_DATA_REQUESTS)    /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can1_data();

                //tester1_vign will be dumped for both CAN channels
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,%.3f,6,%.3f,7,%.3f,8,%.3f,9,%.3f,10,%d,11,%.3f,12,%.3f,",\

                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
                trig_flag,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_5volt,\
                value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt,\
                can1_FCA_BattVltg_fp,can1_FCA_Temperature_fp,\
                can1_FCA_DigT1_fp,can1_FCA_DigT2_fp,\
                can1_FCA_MtrCurrQax_fp,can1_FCA_SystemState_byt,\
                can1_FCA_HwTrq_HwNm_fp,can1_FCA_Abs_Hw_Pos_fp);

                sprintf(temp_return_message,\
        "13,%.3f,14,%.3f,15,%.3f,16,%.3f,17,%.3f,18,%.3f,19,%s,",\
                can1_FCA_MtrCurrQax1_fp,can1_FCA_MtrCurrQax2_fp,\
                can1_FCA_MtrCurrQax3_fp,can1_FCA_HwTrq_HwNm1_fp,\
                can1_FCA_HwTrq_HwNm2_fp,can1_FCA_HwTrq_HwNm3_fp,\
                N_A_str);


                strcat(return_message,temp_return_message);

//          // 39 - 53 is DTCs   // get DTCs1 later and append to return message at end
//              get_DTCs1();
//
//              strcat(return_message,dtc1_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

    //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

                /* dump will show, no CAN Response but prod may be running, faultX_cnt is where can1_request_index stopped */
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,",\
                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
                trig_flag,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_5volt,\
                value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt);


                sprintf(temp_return_message,\
        "13,1,14,1,15,1,16,1,17,1,18,1,19,1,");

                strcat(return_message,temp_return_message);

//          // 39 - 53 is DTCs
//              strcpy(temp_return_message,\
//      "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");
//
//              strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

    //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,",\
            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
            trig_flag,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status);

            sprintf(temp_return_message,\
        "13,0,14,0,15,0,16,0,17,0,18,0,19,0,");

            strcat(return_message,temp_return_message);

//      // 39 - 53 is DTCs
//          strcpy(temp_return_message,\
//      "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");
//
//          strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */

        if(ign2_status > OFF)   /* ok to talk CAN2 and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();                //send CAN2 connect message

            system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
            while((can2_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can2_request_index != FCA_ADAS_CAN_DATA_REQUESTS)
            {

                can2_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN2();                //send CAN2 connect message

                system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                while((can2_request_index != FCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can2_request_index == FCA_ADAS_CAN_DATA_REQUESTS)    /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can2_data();

                //tester1_vign will be dumped for both CAN channels, "dumperr_Product1_3volt" is used for CAN2 product 5volt read, its the wiring
                sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,%.3f,26,%.3f,27,%.3f,28,%.3f,29,%.3f,30,%d,31,%.3f,32,%.3f,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt,\
                can2_FCA_BattVltg_fp,can2_FCA_Temperature_fp,\
                can2_FCA_DigT1_fp,can2_FCA_DigT2_fp,\
                can2_FCA_MtrCurrQax_fp,can2_FCA_SystemState_byt,\
                can2_FCA_HwTrq_HwNm_fp,can2_FCA_Abs_Hw_Pos_fp);


                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,%.3f,34,%.3f,35,%.3f,36,%.3f,37,%.3f,38,%.3f,",\
                can2_FCA_MtrCurrQax1_fp,can2_FCA_MtrCurrQax2_fp,\
                can2_FCA_MtrCurrQax3_fp,can2_FCA_HwTrq_HwNm1_fp,\
                can2_FCA_HwTrq_HwNm2_fp,can2_FCA_HwTrq_HwNm3_fp);


                strcat(return_message,temp_return_message);

            // 39 - 53 is DTCs
                get_DTCs1();

            // append CAN1 [1-7], empty #46 field and CAN2 [1-7] DTCs to return_message

                strcat(return_message,dtc1_return_message);
                strcat(return_message,"46,N/A,");

                get_DTCs2();

                strcat(return_message,dtc2_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

    //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

                /* dump will show, no CAN Response but prod may be running, faultX_cnt is where can1_request_index stopped */
                sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,1,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt);

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,1,34,1,35,1,36,1,37,1,38,1,");

                strcat(return_message,temp_return_message);


            // 39 - 53 is DTCs
                strcpy(temp_return_message,\
        "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");

                strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

    //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt);

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,0,34,0,35,0,36,0,37,0,38,0,");

                strcat(return_message,temp_return_message);

        // 39 - 53 is DTCs
            strcpy(temp_return_message,\
        "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");

            strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */

    }
        break;  // end case FCA_ADAS

    case TARGET_CD391_ADAS:
    {
        if(ign1_status > OFF)   /* ok to talk CAN1 and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();                //send CAN1 connect message

            system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
            while((can1_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can1_request_index != CD391_ADAS_CAN_DATA_REQUESTS)
            {

                can1_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN1();                //send CAN1 connect message

                system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                while((can1_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can1_request_index == CD391_ADAS_CAN_DATA_REQUESTS)  /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can1_data();

                //tester1_vign will be dumped for both CAN channels
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,%.3f,6,%.3f,7,%.3f,8,%.3f,9,%.3f,10,%d,11,%.3f,12,%.3f,",\

                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
                trig_flag,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_5volt,\
                value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt,\
                can1_FORD_BattVltg_fp,can1_FORD_Temperature_fp,\
                can1_FORD_DigT1_fp,can1_FORD_DigT2_fp,\
                can1_FORD_MtrCurrQax_fp,can1_FORD_SystemState_byt,\
                can1_FORD_HwTrq_HwNm_fp,can1_FORD_Abs_Hw_Pos_fp);

                sprintf(temp_return_message,\
        "13,%d,14,%d,15,%d,16,%d,17,%.3f,18,%.3f,19,%s,",\
                can1_FORD_LatchFail_ISR_u16,can1_FORD_MtrCntl_ISR_u16,\
                can1_FORD_MinCount_u32,can1_FORD_MaxCount_u32,\
                can1_FORD_Batt_Current_fp,can1_FORD_HwTrq_HwNm3_fp,\
                N_A_str);


                strcat(return_message,temp_return_message);

//          // 39 - 53 is DTCs   // get DTCs1 later and append to return message at end
//              get_DTCs1();
//
//              strcat(return_message,dtc1_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

    //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

                /* dump will show, no CAN Response but prod may be running, faultX_cnt is where can1_request_index stopped */
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,",\
                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
                trig_flag,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_5volt,\
                value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt);


                sprintf(temp_return_message,\
        "13,1,14,1,15,1,16,1,17,1,18,1,19,1,");

                strcat(return_message,temp_return_message);

//          // 39 - 53 is DTCs
//              strcpy(temp_return_message,\
//      "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");
//
//              strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

    //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,",\
            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
            trig_flag,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status);

            sprintf(temp_return_message,\
        "13,0,14,0,15,0,16,0,17,0,18,0,19,0,");

            strcat(return_message,temp_return_message);

//      // 39 - 53 is DTCs
//          strcpy(temp_return_message,\
//      "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");
//
//          strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */

        if(ign2_status > OFF)   /* ok to talk CAN2 and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();                //send CAN2 connect message

            system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
            while((can2_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can2_request_index != CD391_ADAS_CAN_DATA_REQUESTS)
            {

                can2_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN2();                //send CAN2 connect message

                system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                while((can2_request_index != CD391_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can2_request_index == CD391_ADAS_CAN_DATA_REQUESTS)  /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can2_data();

                //tester1_vign will be dumped for both CAN channels, "dumperr_Product1_3volt" is used for CAN2 product 5volt read, its the wiring
                sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,%.3f,26,%.3f,27,%.3f,28,%.3f,29,%.3f,30,%d,31,%.3f,32,%.3f,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt,\
                can2_FORD_BattVltg_fp,can2_FORD_Temperature_fp,\
                can2_FORD_DigT1_fp,can2_FORD_DigT2_fp,\
                can2_FORD_MtrCurrQax_fp,can2_FORD_SystemState_byt,\
                can2_FORD_HwTrq_HwNm_fp,can2_FORD_Abs_Hw_Pos_fp);


                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,%d,34,%d,35,%d,36,%d,37,%.3f,38,%.3f,",\
                can2_FORD_LatchFail_ISR_u16,can2_FORD_MtrCntl_ISR_u16,\
                can2_FORD_MinCount_u32,can2_FORD_MaxCount_u32,\
                can2_FORD_Batt_Current_fp,can2_FORD_HwTrq_HwNm3_fp);


                strcat(return_message,temp_return_message);

            // 39 - 53 is DTCs
                get_DTCs1();

            // append CAN1 [1-7], empty #46 field and CAN2 [1-7] DTCs to return_message

                strcat(return_message,dtc1_return_message);
                strcat(return_message,"46,N/A,");

                get_DTCs2();

                strcat(return_message,dtc2_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

    //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

                /* dump will show, no CAN Response but prod may be running, faultX_cnt is where can1_request_index stopped */
                sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,1,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt);

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,1,34,1,35,1,36,1,37,1,38,1,");

                strcat(return_message,temp_return_message);


            // 39 - 53 is DTCs
                strcpy(temp_return_message,\
        "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");

                strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

    //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt);

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,0,34,0,35,0,36,0,37,0,38,0,");

                strcat(return_message,temp_return_message);

        // 39 - 53 is DTCs
            strcpy(temp_return_message,\
        "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");

            strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */

    }
        break;  // end case FORD_ADAS

    case TARGET_G2KCA_ADAS:
    {
        if(ign1_status > OFF)   /* ok to talk CAN1 and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();                //send CAN1 connect message

            system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
            while((can1_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can1_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS)
            {

                can1_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN1();                //send CAN1 connect message

                system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                while((can1_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can1_request_index == G2KCA_ADAS_CAN_DATA_REQUESTS)  /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can1_data();

                //tester1_vign will be dumped for both CAN channels
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,%.3f,6,%.3f,7,%.3f,8,%.3f,9,%.3f,10,%d,11,%.3f,12,%.3f,",\

                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
                trig_flag,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_5volt,\
                value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt,\
                can1_G2KCA_BattVltg_fp,can1_G2KCA_Temperature_fp,\
                can1_G2KCA_DigT1_fp,can1_G2KCA_DigT2_fp,\
                can1_G2KCA_MtrCurrQax_fp,can1_G2KCA_SystemState_byt,\
                can1_G2KCA_HwTrq_HwNm_fp,can1_G2KCA_Abs_Hw_Pos_fp);

                sprintf(temp_return_message,\
        "13,%.3f,14,%.3f,15,%.3f,16,%.3f,17,%.3f,18,%.3f,19,%s,",\
                can1_G2KCA_MtrCurrQax1_fp,can1_G2KCA_MtrCurrQax2_fp,\
                can1_G2KCA_MtrCurrQax3_fp,can1_G2KCA_HwTrq_HwNm1_fp,\
                can1_G2KCA_HwTrq_HwNm2_fp,can1_G2KCA_HwTrq_HwNm3_fp,\
                N_A_str);


                strcat(return_message,temp_return_message);

//          // 39 - 53 is DTCs   // get DTCs1 later and append to return message at end
//              get_DTCs1();
//
//              strcat(return_message,dtc1_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

    //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

                /* dump will show, no CAN Response but prod may be running, faultX_cnt is where can1_request_index stopped */
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,",\
                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
                trig_flag,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_5volt,\
                value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt);

                sprintf(temp_return_message,\
        "13,1,14,1,15,1,16,1,17,1,18,1,19,1,");

                strcat(return_message,temp_return_message);

//          // 39 - 53 is DTCs
//              strcpy(temp_return_message,\
//      "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");
//
//              strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

    //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,",\
            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
            trig_flag,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status);

            sprintf(temp_return_message,\
        "13,0,14,0,15,0,16,0,17,0,18,0,19,0,");

            strcat(return_message,temp_return_message);

//      // 39 - 53 is DTCs
//          strcpy(temp_return_message,\
//      "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");
//
//          strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */

        if(ign2_status > OFF)   /* ok to talk CAN2 and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();                //send CAN2 connect message

            system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
            while((can2_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can2_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS)
            {

                can2_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN2();                //send CAN2 connect message

                system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                while((can2_request_index != G2KCA_ADAS_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can2_request_index == G2KCA_ADAS_CAN_DATA_REQUESTS)  /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can2_data();

                //tester1_vign will be dumped for both CAN channels, "dumperr_Product1_3volt" is used for CAN2 product 5volt read, its the wiring
                sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,%.3f,26,%.3f,27,%.3f,28,%.3f,29,%.3f,30,%d,31,%.3f,32,%.3f,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt,\
                can2_G2KCA_BattVltg_fp,can2_G2KCA_Temperature_fp,\
                can2_G2KCA_DigT1_fp,can2_G2KCA_DigT2_fp,\
                can2_G2KCA_MtrCurrQax_fp,can2_G2KCA_SystemState_byt,\
                can2_G2KCA_HwTrq_HwNm_fp,can2_G2KCA_Abs_Hw_Pos_fp);


                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,%.3f,34,%.3f,35,%.3f,36,%.3f,37,%.3f,38,%.3f,",\
                can2_G2KCA_MtrCurrQax1_fp,can2_G2KCA_MtrCurrQax2_fp,\
                can2_G2KCA_MtrCurrQax3_fp,can2_G2KCA_HwTrq_HwNm1_fp,\
                can2_G2KCA_HwTrq_HwNm2_fp,can2_G2KCA_HwTrq_HwNm3_fp);


                strcat(return_message,temp_return_message);

            // 39 - 53 is DTCs
                get_DTCs1();

            // append CAN1 [1-7], empty #46 field and CAN2 [1-7] DTCs to return_message

                strcat(return_message,dtc1_return_message);
                strcat(return_message,"46,N/A,");

                get_DTCs2();

                strcat(return_message,dtc2_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

    //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

                /* dump will show, no CAN Response but prod may be running, faultX_cnt is where can1_request_index stopped */
                sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,1,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt);

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,1,34,1,35,1,36,1,37,1,38,1,");

                strcat(return_message,temp_return_message);

            // 39 - 53 is DTCs
                strcpy(temp_return_message,\
        "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");

                strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

    //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt);

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,0,34,0,35,0,36,0,37,0,38,0,");

                strcat(return_message,temp_return_message);

        // 39 - 53 is DTCs
            strcpy(temp_return_message,\
        "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");

            strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */

    }
        break;  // end case G2KCA_ADAS

    case TARGET_PSA_CMP:
    {
        if(ign1_status > OFF)   /* ok to talk CAN and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();                //send CAN1 connect message

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
            while((can1_request_index != PSA_CMP_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can1_request_index != PSA_CMP_CAN_DATA_REQUESTS)
            {

                can1_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN1();                //send connect message

                system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
                while((can1_request_index != PSA_CMP_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can1_request_index == PSA_CMP_CAN_DATA_REQUESTS)    /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can1_data();

            sprintf(return_message,\
            "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,%.3f,6,%.3f,7,%.3f,8,%.3f,9,%d,10,%.3f,11,%.3f,12,%.3f,",\

            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
            trig_flag,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

            dumperr_Tester1_vign,dumperr_Product1_5volt,\
            value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt,\
            can1_PSA_CMP_BattVltg_fp,can1_PSA_CMP_Temperature_fp,\
            can1_PSA_CMP_DigT1_fp,can1_PSA_CMP_DigT2_fp,\
            can1_PSA_CMP_SystemState_byt,can1_PSA_CMP_MtrCurrQax_fp,\
            can1_PSA_CMP_MtrCurrDax_fp,can1_PSA_CMP_HwTrq_HwNm_fp);

            sprintf(temp_return_message,\
            "13,%.3f,14,%.3f,15,%.3f,16,%.3f,17,%d,18,%.3f,19,%.3f,20,%.3f,",\
            can1_PSA_CMP_MtrTrqCmd_HwNm_fp,can1_PSA_CMP_AstMtrTrq_HwNm_fp,\
            can1_PSA_CMP_Abs_Hw_Pos_fp,can1_PSA_CMP_Rel_Hw_Pos_fp,\
            can1_PSA_CMP_Abs_Hw_Pos_Valid_byt,can1_PSA_CMP_MtrPos_fp,\
            can1_PSA_CMP_ADC_MtrCurr1_fp,can1_PSA_CMP_ADC_MtrCurr2_fp);

            strcat(return_message,temp_return_message);

            sprintf(temp_return_message,\
            "21,%s,22,%s,23,%s,24,%s,25,%s,26,%s,27,%s,28,%s,29,%s,30,%s,",\
            N_A_str,N_A_str,\
            N_A_str,N_A_str,\
            N_A_str,N_A_str,\
            N_A_str,N_A_str,\
            N_A_str,N_A_str);

            strcat(return_message,temp_return_message);

            sprintf(temp_return_message,\
            "31,%s,32,%s,33,%s,34,%s,35,%s,36,%s,37,%s,38,%s,",\
            N_A_str,N_A_str,\
            N_A_str,N_A_str,\
            N_A_str,N_A_str,\
            N_A_str,N_A_str);


            strcat(return_message,temp_return_message);

                     // 39 - 53 is DTCs   // get DTCs1 later and append to return message at end
                         get_DTCs1();

                         strcat(return_message,dtc1_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

            //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

            /* dump will show, no CAN response but prod may be running, faultX_cnt is where can1_request_index stopped */
            sprintf(return_message,\
            "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,",\
            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
            trig_flag,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

            dumperr_Tester1_vign,dumperr_Product1_5volt,\
            value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt);

            sprintf(temp_return_message,\
            "13,1,14,1,15,1,16,1,17,1,18,1,19,1,20,1,21,1,22,1,23,1,24,1,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,1,33,1,34,1,35,1,36,1,37,1,38,1,");

            strcat(return_message,temp_return_message);

                      // 39 - 53 is DTCs
                          strcpy(temp_return_message,\
                  "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");

                          strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

            }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
            else    /* dumperr was requested while ign was off, so givem zeros */
            {

            //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(return_message,\
            "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,",\
            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
            trig_flag,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status);

            sprintf(temp_return_message,\
            "13,0,14,0,15,0,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,33,0,34,0,35,0,36,0,37,0,38,0,");

            strcat(return_message,temp_return_message);

                  // 39 - 53 is DTCs
                      strcpy(temp_return_message,\
                  "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");

                      strcat(return_message,temp_return_message);

            }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */

            }
    break;  // end case TARGET_PSA_CMP

    case TARGET_SGMW_CN200:
    {
        if(ign1_status > OFF)   /* ok to talk CAN and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();                //send CAN1 connect message

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
            while((can1_request_index != SGMW_CN200_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can1_request_index != SGMW_CN200_CAN_DATA_REQUESTS)
            {

                can1_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN1();                //send connect message

                system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
                while((can1_request_index != SGMW_CN200_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can1_request_index == SGMW_CN200_CAN_DATA_REQUESTS)    /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can1_data();

            sprintf(return_message,\
            "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,%.3f,6,%.3f,7,%.3f,8,%.3f,9,%.3f,10,%d,11,%.3f,12,%.3f,",\

            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
            trig_flag,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

//            dumperr_Tester1_vign,dumperr_Product1_5volt,
            2*adc1_Group1_mV[6],2*adc1_Group1_mV[7],\
            value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt,\
            can1_CN200_BattVltg_fp,can1_CN200_Temperature_fp,\
            can1_CN200_DigT1_HwNm_fp,can1_CN200_DigT2_HwNm_fp,\
            can1_CN200_MtrCurrQax_fp,can1_CN200_SystemState_byt,\
            can1_CN200_HwTrq_HwNm_fp,can1_CN200_Abs_Hw_Pos_fp);

            sprintf(temp_return_message,\
            "13,%.3f,14,%.3f,15,%.3f,16,%.3f,17,%.3f,18,%.3f,19,%.3f,20,%.3f,21,%.3f,22,%.3f,",\
            can1_CN200_MotTrq_Crf_fp,can1_CN200_MotTrq_Mrf_fp,\
            can1_CN200_VehSpd_fp,can1_CN200_Spare2_fp,\
            can1_CN200_MtrCurrQax1_fp,can1_CN200_MtrCurrQax2_fp,\
            can1_CN200_MtrCurrQax3_fp,can1_CN200_HwTrq_HwNm1_fp,\
            can1_CN200_HwTrq_HwNm2_fp,can1_CN200_HwTrq_HwNm3_fp);

            strcat(return_message,temp_return_message);

            sprintf(temp_return_message,\
            "23,%s,24,%s,25,%s,26,%s,27,%s,28,%s,29,%s,30,%s,",\
            N_A_str,N_A_str,\
            N_A_str,N_A_str,\
            N_A_str,N_A_str,\
            N_A_str,N_A_str);

            strcat(return_message,temp_return_message);

            sprintf(temp_return_message,\
            "31,%s,32,%s,33,%s,34,%s,35,%s,36,%s,37,%s,38,%s,",\
            N_A_str,N_A_str,\
            N_A_str,N_A_str,\
            N_A_str,N_A_str,\
            N_A_str,N_A_str);


            strcat(return_message,temp_return_message);

                     // 39 - 53 is DTCs   // get DTCs1 later and append to return message at end
                         get_DTCs1();

                         strcat(return_message,dtc1_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {


            /* dump will show, no CAN response but prod may be running, faultX_cnt is where can1_request_index stopped */
            sprintf(return_message,\
            "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,",\
            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
            trig_flag,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

            dumperr_Tester1_vign,dumperr_Product1_5volt,\
            value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt);

            sprintf(temp_return_message,\
            "13,1,14,1,15,1,16,1,17,1,18,1,19,1,20,1,21,1,22,1,23,1,24,1,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,1,33,1,34,1,35,1,36,1,37,1,38,1,");

            strcat(return_message,temp_return_message);

                      // 39 - 53 is DTCs
                          strcpy(temp_return_message,\
                  "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");

                          strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

            }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
            else    /* dumperr was requested while ign was off, so givem zeros */
            {

            //       marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(return_message,\
            "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,",\
            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
            trig_flag,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status);

            sprintf(temp_return_message,\
            "13,0,14,0,15,0,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,33,0,34,0,35,0,36,0,37,0,38,0,");

            strcat(return_message,temp_return_message);

                  // 39 - 53 is DTCs
                      strcpy(temp_return_message,\
                  "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");

                      strcat(return_message,temp_return_message);

            }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */

            }
    break;  // end case TARGET_SGMW_CN200

    case TARGET_FORD_T3_T6:
    {
        if(ign1_status > OFF)   /* ok to talk CAN1 and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();                //send CAN1 connect message

            system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
            while((can1_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can1_request_index != FORD_T3_T6_CAN_DATA_REQUESTS)
            {

                can1_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN1();                //send CAN1 connect message

                system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                while((can1_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can1_request_index == FORD_T3_T6_CAN_DATA_REQUESTS)  /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can1_data();

                //tester1_vign will be dumped for both CAN channels
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,%.3f,6,%.3f,7,%.3f,8,%.3f,9,%.3f,10,%d,11,%.3f,12,%.3f,",\

                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
                trig_flag,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_5volt,\
                value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt,\
                can1_FORD_T3_ECU1_BattVltg_fp,can1_FORD_T3_ECU1_Temperature_fp,\
                can1_FORD_T3_ECU1_DigT1_fp,can1_FORD_T3_ECU1_DigT2_fp,\
                can1_FORD_T3_ECU1_MtrCurrQax_fp,can1_FORD_T3_ECU1_SystemState_byt,\
                can1_FORD_T3_ECU1_HwTrq_HwNm_fp,can1_FORD_T3_ECU1_Abs_Hw_Pos_fp);

                sprintf(temp_return_message,\
        "13,%.3f,14,%.3f,15,%.3f,16,%.3f,17,%.3f,18,%.3f,19,%s,",\
                can1_FORD_T3_ECU1_MtrCurrQax1_fp,can1_FORD_T3_ECU1_HwTrq_HwNm1_fp,\
                can1_FORD_T3_ECU1_MtrCurrQax2_fp,can1_FORD_T3_ECU1_HwTrq_HwNm2_fp,\
                can1_FORD_T3_ECU1_MtrCurrQax3_fp,can1_FORD_T3_ECU1_HwTrq_HwNm3_fp,\
                N_A_str);


                strcat(return_message,temp_return_message);

//          // 39 - 53 is DTCs   // get DTCs1 later and append to return message at end
//              get_DTCs1();
//
//              strcat(return_message,dtc1_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

    //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

                /* dump will show, no CAN Response but prod may be running, faultX_cnt is where can1_request_index stopped */
                sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,",\
                CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
                trig_flag,\

                can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                dumperr_Tester1_vign,dumperr_Product1_5volt,\
                value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt);

                sprintf(temp_return_message,\
        "13,1,14,1,15,1,16,1,17,1,18,1,19,1,");

                strcat(return_message,temp_return_message);

//          // 39 - 53 is DTCs
//              strcpy(temp_return_message,\
//      "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");
//
//              strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

    //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,",\
            CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
            trig_flag,\

            can1_request_index,dump_cnt,CIB_reset_flag,ign1_status);

            sprintf(temp_return_message,\
        "13,0,14,0,15,0,16,0,17,0,18,0,19,0,");

            strcat(return_message,temp_return_message);

//      // 39 - 53 is DTCs
//          strcpy(temp_return_message,\
//      "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");
//
//          strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */

        if(ign2_status > OFF)   /* ok to talk CAN2 and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            can2_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN2();                //send CAN2 connect message

            system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
            while((can2_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

        // second try at CAN communications if needed
            if(can2_request_index != FORD_T3_T6_CAN_DATA_REQUESTS)
            {

                can2_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftCAN2();                //send CAN2 connect message

                system_msec_clock_temp = system_msec_clock + 300;   // set time out to 150mS
                while((can2_request_index != FORD_T3_T6_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
            }

            if(can2_request_index == FORD_T3_T6_CAN_DATA_REQUESTS)  /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can2_data();

                //tester1_vign will be dumped for both CAN channels, "dumperr_Product1_3volt" is used for CAN2 product 5volt read, its the wiring
                sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,%.3f,26,%.3f,27,%.3f,28,%.3f,29,%.3f,30,%d,31,%.3f,32,%.3f,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt,\
                can1_FORD_T3_ECU2_BattVltg_fp,can1_FORD_T3_ECU2_Temperature_fp,\
                can1_FORD_T3_ECU2_DigT1_fp,can1_FORD_T3_ECU2_DigT2_fp,\
                can1_FORD_T3_ECU2_MtrCurrQax_fp,can1_FORD_T3_ECU2_SystemState_byt,\
                can1_FORD_T3_ECU2_HwTrq_HwNm_fp,can1_FORD_T3_ECU2_Abs_Hw_Pos_fp);


                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,%.3f,34,%.3f,35,%.3f,36,%.3f,37,%.3f,38,%.3f,",\
                can1_FORD_T3_ECU2_MtrCurrQax1_fp,can1_FORD_T3_ECU2_HwTrq_HwNm1_fp,\
                can1_FORD_T3_ECU2_MtrCurrQax2_fp,can1_FORD_T3_ECU2_HwTrq_HwNm2_fp,\
                can1_FORD_T3_ECU2_MtrCurrQax3_fp,can1_FORD_T3_ECU2_HwTrq_HwNm3_fp);


                strcat(return_message,temp_return_message);

            // 39 - 53 is DTCs
                get_DTCs1();

            // append CAN1 [1-7], empty #46 field and CAN2 [1-7] DTCs to return_message

                strcat(return_message,dtc1_return_message);
                strcat(return_message,"46,N/A,");

                get_DTCs2();

                strcat(return_message,dtc2_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {

    //          speed_flag = 1;             //  CAN marker in speed mess to all 1's in dump_err

                /* dump will show, no CAN Response but prod may be running, faultX_cnt is where can1_request_index stopped */
                sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,1,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt);

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,1,34,1,35,1,36,1,37,1,38,1,");

                strcat(return_message,temp_return_message);

            // 39 - 53 is DTCs
                strcpy(temp_return_message,\
        "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");

                strcat(return_message,temp_return_message);

            }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

    //      speed_flag = 2; // marker CAN mess in speed to find all 0's dump in dump_err

            sprintf(temp_return_message,\
        "20,%d:%d:%d:%d,21,%d,22,%d,23,%d,24,%d,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,",\

                can2_request_index,dump_cnt,CIB_reset_flag,ign2_status,\

                dumperr_Tester1_vign,dumperr_Product1_3volt,\
                value_sent7_ChB_T1_cnt,value_sent8_ChB_T2_cnt);

                strcat(return_message,temp_return_message);

                sprintf(temp_return_message,\
        "33,0,34,0,35,0,36,0,37,0,38,0,");

                strcat(return_message,temp_return_message);

        // 39 - 53 is DTCs
            strcpy(temp_return_message,\
        "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");

            strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */

    }
        break;  // end case TARGET_FORD_T3_T6

    case TARGET_RENAULT_NISSAN:
    {
    if(ign1_status > OFF)   /* ok to talk CAN and dump true data, if not, dump zeros */
    {
        /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
        can1_request_index = 0; // set index to start sequence at case 0 in ISR
        ShiftCAN1();                //send CAN1 connect message

        system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
        while((can1_request_index != RENAULT_NISSAN_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS, last CAN reads are done, move on */

    // second try at CAN communications if needed
        if(can1_request_index != RENAULT_NISSAN_CAN_DATA_REQUESTS)
        {

            can1_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftCAN1();                //send connect message

            system_msec_clock_temp = system_msec_clock + 500;   // set time out to 150mS
            while((can1_request_index != RENAULT_NISSAN_CAN_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at CAN_DATA_REQUESTS ,last CAN reads are done, move on */
        }

        if(can1_request_index == RENAULT_NISSAN_CAN_DATA_REQUESTS)    /* CAN dump was ok, else we timed out- product did not respond */
        {
            parse_can1_data();

        sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,%.3f,6,%.3f,7,%.3f,8,%.3f,9,%.3f,10,%d,11,%.3f,12,%.3f,",\

        CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
        trig_flag,\

        can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

        dumperr_Tester1_vign,dumperr_Product1_5volt,\
        value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt,\
        can1_RENAULT_NISSAN_BattVltg_fp,can1_RENAULT_NISSAN_Temperature_fp,\
        can1_RENAULT_NISSAN_DigT1_HwNm_fp,can1_RENAULT_NISSAN_DigT2_HwNm_fp,\
        can1_RENAULT_NISSAN_MtrCurrQax_fp,can1_RENAULT_NISSAN_SystemState_byt,\
        can1_RENAULT_NISSAN_HwTrq_HwNm_fp,can1_RENAULT_NISSAN_Abs_Hw_Pos_fp);

        sprintf(temp_return_message,\
        "13,%.3f,14,%.3f,15,%.3f,16,%.3f,17,%.3f,18,%.3f,19,%.3f,20,%.3f,21,%.3f,22,%.3f,",\
        can1_RENAULT_NISSAN_MotTrq_Crf_fp,can1_RENAULT_NISSAN_MotTrq_Mrf_fp,\
        can1_RENAULT_NISSAN_VehSpd_fp,can1_RENAULT_NISSAN_Spare2_fp,\
        can1_RENAULT_NISSAN_MtrCurrQax1_fp,can1_RENAULT_NISSAN_MtrCurrQax2_fp,\
        can1_RENAULT_NISSAN_MtrCurrQax3_fp,can1_RENAULT_NISSAN_HwTrq_HwNm1_fp,\
        can1_RENAULT_NISSAN_HwTrq_HwNm2_fp,can1_RENAULT_NISSAN_HwTrq_HwNm3_fp);

        strcat(return_message,temp_return_message);

        sprintf(temp_return_message,\
        "23,%s,24,%s,25,%s,26,%s,27,%s,28,%s,29,%s,30,%s,",\
        N_A_str,N_A_str,\
        N_A_str,N_A_str,\
        N_A_str,N_A_str,\
        N_A_str,N_A_str);

        strcat(return_message,temp_return_message);

        sprintf(temp_return_message,\
        "31,%s,32,%s,33,%s,34,%s,35,%s,36,%s,37,%s,38,%s,",\
        N_A_str,N_A_str,\
        N_A_str,N_A_str,\
        N_A_str,N_A_str,\
        N_A_str,N_A_str);


        strcat(return_message,temp_return_message);

                 // 39 - 53 is DTCs   // get DTCs1 later and append to return message at end
                     get_DTCs1();

                     strcat(return_message,dtc1_return_message);

        }
        else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
        {


        /* dump will show, no CAN response but prod may be running, faultX_cnt is where can1_request_index stopped */
        sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,",\
        CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
        trig_flag,\

        can1_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

        dumperr_Tester1_vign,dumperr_Product1_5volt,\
        value_sent5_ChA_T1_cnt,value_sent6_ChA_T2_cnt);

        sprintf(temp_return_message,\
        "13,1,14,1,15,1,16,1,17,1,18,1,19,1,20,1,21,1,22,1,23,1,24,1,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,1,33,1,34,1,35,1,36,1,37,1,38,1,");

        strcat(return_message,temp_return_message);

                  // 39 - 53 is DTCs
                      strcpy(temp_return_message,\
              "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");

                      strcat(return_message,temp_return_message);

        }   /* end else if(can1_request_index == CAN_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

        //       marker CAN mess in speed to find all 0's dump in dump_err

        sprintf(return_message,\
        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,",\
        CIB_config_data.BOARD_ID,bus1_off_state,bus2_off_state,bus1_warn_state,bus2_warn_state,can1_sys_state_warm_init,can2_sys_state_warm_init,\
        trig_flag,\

        can1_request_index,dump_cnt,CIB_reset_flag,ign1_status);

        sprintf(temp_return_message,\
        "13,0,14,0,15,0,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,33,0,34,0,35,0,36,0,37,0,38,0,");

        strcat(return_message,temp_return_message);

              // 39 - 53 is DTCs
                  strcpy(temp_return_message,\
              "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");

                  strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF)   ---  if(ign_on_flag == TRUE) */

        }
        break;  // end case TARGET_RENAULT_NISSAN

    case TARGET_BMW_UKL:
    {
        if(ign1_status > OFF)   /* ok to talk CAN and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            fray_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftFRAY();                //send connect message

            system_msec_clock_temp = system_msec_clock + 1200;  // set time out to 150mS
            while((fray_request_index != TARGET_BMW_UKL_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at 22, last CAN reads are done, move on */

            // second try at CAN communications if needed
            if(fray_request_index != TARGET_BMW_UKL_FRAY_DATA_REQUESTS)
            {

                fray_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftFRAY();                //send connect message

                system_msec_clock_temp = system_msec_clock + 1200;  // set time out to 150mS
                while((fray_request_index != TARGET_BMW_UKL_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at 22 ,last CAN reads are done, move on */
            }

            if(fray_request_index == TARGET_BMW_UKL_FRAY_DATA_REQUESTS)    /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can1_data();

                sprintf(return_message,\
                        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,%.3f,6,%.3f,7,%.3f,8,%.3f,9,%.3f,10,%d,11,%.3f,12,%.3f,",\

                        CIB_config_data.BOARD_ID,fray_error_occurred_flag,fray_error_counter,fray_error_notification,wait_for_fray_cold_start_node_flag,flexray_comm_status_vector_CCSV,fault2_cnt,\
                        trig_flag,\

                        fray_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                        dumperr_Tester1_vign,dumperr_Product1_5volt,\
                        adc1_Group1_mV[6],adc1_Group1_mV[7],\
                        fray1_BMW_UKL_Batt_Volt_fp,fray1_BMW_UKL_Batt_Curr_fp,\
                        fray1_BMW_UKL_Mot_Curr_fp,fray1_BMW_UKL_Mot_Vel_fp,\
                        fray1_BMW_UKL_Comm_Torque_fp,fray1_BMW_UKL_Lim_Torque_fp,\
                        fray1_BMW_UKL_PCB_Temp_fp,fray1_BMW_UKL_Mot_Temp_fp);

                 sprintf(temp_return_message,\
                        "13,%.3f,14,%.3f,15,%.3f,16,%d,17,%.3f,18,%.3f,",\

                        fray1_BMW_UKL_Junction_Temp_fp,fray1_BMW_UKL_HW_Angle_fp,\
                        fray1_BMW_UKL_Diff_Torque_fp,fray1_BMW_UKL_sys_state_byt,\
                        fray1_BMW_UKL_T1_Volt_fp,fray1_BMW_UKL_T2_Volt_fp);

                        strcat(return_message,temp_return_message);

                 sprintf(temp_return_message,\
                        "19,%s,20,%s,21,%s,22,%s,23,%s,24,%s,25,%s,26,%s,",\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str);

                  strcat(return_message,temp_return_message);

                  sprintf(temp_return_message,\
                        "27,%s,28,%s,29,%s,30,%s,31,%s,32,%s,33,%s,34,%s,",\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str);

                  strcat(return_message,temp_return_message);

                  sprintf(temp_return_message,\
                        "35,%s,36,%s,37,%s,38,%s,",\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str);

                  strcat(return_message,temp_return_message);

                // 39 - 53 is DTCs
                get_DTCs1();

                strcat(return_message,dtc1_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {


                /* dump will show, no CAN response but prod may be running, faultX_cnt is where can_request_index stopped */
                sprintf(return_message,\
                        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,",\

                        CIB_config_data.BOARD_ID,fray_error_occurred_flag,fray_error_counter,fray_error_notification,wait_for_fray_cold_start_node_flag,flexray_comm_status_vector_CCSV,fault2_cnt,\
                        trig_flag,\

                        fray_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                        dumperr_Tester1_vign,dumperr_Product1_5volt,\
                        adc1_Group1_mV[6],adc1_Group1_mV[7]);

                sprintf(temp_return_message,\
                        "13,1,14,1,15,1,16,1,17,1,18,1,19,1,20,1,21,1,22,1,23,1,24,1,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,1,33,1,34,1,35,1,36,1,37,1,38,1,");

                strcat(return_message,temp_return_message);

                // 39 - 53 is DTCs
                strcpy(temp_return_message,\
                       "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");

                strcat(return_message,temp_return_message);

            }   /* end else if(fray_request_index == TARGET_BMW_UKL_FRAY_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

            sprintf(return_message,\
                    "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,",\

                    CIB_config_data.BOARD_ID,fray_error_occurred_flag,fray_error_counter,fray_error_notification,wait_for_fray_cold_start_node_flag,flexray_comm_status_vector_CCSV,fault2_cnt,\
                    trig_flag,\

                    fray_request_index,dump_cnt,CIB_reset_flag,ign1_status);

             sprintf(temp_return_message,\
                     "13,0,14,0,15,0,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,33,0,34,0,35,0,36,0,37,0,38,0,");

            strcat(return_message,temp_return_message);

            // 39 - 53 is DTCs
            strcpy(temp_return_message,\
                   "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");

            strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF) */

        } // end case TARGET_BMW_UKL:

        break;
    case TARGET_BMW_FAAR_WE:
    {
        if(ign1_status > OFF)   /* ok to talk CAN and dump true data, if not, dump zeros */
        {
            /* by the time a/d are done so should vital CAN reads initiated in IN_POSITION, now push next reads */
            fray_request_index = 0; // set index to start sequence at case 0 in ISR
            ShiftFRAY();                //send connect message

            system_msec_clock_temp = system_msec_clock + 2400;  // REV7= 1200mS was set time out to 150mS
            while((fray_request_index != TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at 22, last CAN reads are done, move on */

            // second try at CAN communications if needed
            if(fray_request_index != TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS)
            {

                fray_request_index = 0; // set index to start sequence at case 0 in ISR
                ShiftFRAY();                //send connect message

                system_msec_clock_temp = system_msec_clock + 2400;  // set time out to 150mS
                while((fray_request_index != TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS) && (system_msec_clock < system_msec_clock_temp)); /* at 22 ,last CAN reads are done, move on */
            }

            if(fray_request_index == TARGET_BMW_FAAR_WE_FRAY_DATA_REQUESTS)    /* CAN dump was ok, else we timed out- product did not respond */
            {
                parse_can1_data();

                sprintf(return_message,\
                        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,%d,6,%.3f,7,%.3f,8,%.3f,9,%.3f,10,%.3f,11,%.3f,12,%.3f,",\

                        CIB_config_data.BOARD_ID,fray_error_occurred_flag,fray_error_counter,fray_error_notification,wait_for_fray_cold_start_node_flag,flexray_comm_status_vector_CCSV,fault2_cnt,\
                        trig_flag,\

                        fray_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                        dumperr_Tester1_vign,dumperr_Product1_5volt,\
                        adc1_Group1_mV[6],adc1_Group1_mV[7],\
                        fray1_FAAR_WE_SysStMod_byt,fray1_FAAR_WE_BattVltg_BrdgVltg_fp,\
                        fray1_FAAR_WE_BattRtnCurrAmpr_fp,fray1_FAAR_WE_HwAgArbn_fp,\
                        fray1_FAAR_WE_HwTq4Meas_fp,fray1_FAAR_WE_HwTq5Meas_fp,\
                        fray1_FAAR_WE_HwTqArbn_fp,fray1_FAAR_WE_MotCurrSumA_fp);

                 sprintf(temp_return_message,\
                        "13,%.3f,14,%.3f,15,%.3f,16,%.3f,17,%.3f,18,%.3f,",\

                        fray1_FAAR_WE_MotCurrSumB_fp,fray1_FAAR_WE_MotCurrSumC_fp,\
                        fray1_FAAR_WE_MotVelCrf_fp,fray1_FAAR_WE_MotTqCmd_fp,\
                        fray1_FAAR_WE_MotTqEstimd_fp,fray1_FAAR_WE_LoaSca_fp);

                        strcat(return_message,temp_return_message);

                 sprintf(temp_return_message,\
                        "19,%.3f,20,%.3f,21,%.3f,22,%.3f,23,%s,24,%s,25,%s,26,%s,",\
                        fray1_FAAR_WE_EcuTMeas_fp,fray1_FAAR_WE_MotWidgT_fp,\
                        fray1_FAAR_WE_MotMagT_fp,fray1_FAAR_WE_MotFetT_fp,\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str);

                  strcat(return_message,temp_return_message);

                  sprintf(temp_return_message,\
                        "27,%s,28,%s,29,%s,30,%s,31,%s,32,%s,33,%s,34,%s,",\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str);

                  strcat(return_message,temp_return_message);

                  sprintf(temp_return_message,\
                        "35,%s,36,%s,37,%s,38,%s,",\
                        N_A_str,N_A_str,\
                        N_A_str,N_A_str);

                  strcat(return_message,temp_return_message);

                // 39 - 53 is DTCs
                get_DTCs1();

                strcat(return_message,dtc1_return_message);

            }
            else    /* ign is on, but CAN dump timed out, set CAN data to 1's */
            {


                /* dump will show, no CAN response but prod may be running, faultX_cnt is where can_request_index stopped */
                sprintf(return_message,\
                        "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,%d,2,%d,3,%d,4,%d,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,",\

                        CIB_config_data.BOARD_ID,fray_error_occurred_flag,fray_error_counter,fray_error_notification,wait_for_fray_cold_start_node_flag,flexray_comm_status_vector_CCSV,fault2_cnt,\
                        trig_flag,\

                        fray_request_index,dump_cnt,CIB_reset_flag,ign1_status,\

                        dumperr_Tester1_vign,dumperr_Product1_5volt,\
                        adc1_Group1_mV[6],adc1_Group1_mV[7]);

                sprintf(temp_return_message,\
                        "13,1,14,1,15,1,16,1,17,1,18,1,19,1,20,1,21,1,22,1,23,1,24,1,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,1,33,1,34,1,35,1,36,1,37,1,38,1,");

                strcat(return_message,temp_return_message);

                // 39 - 53 is DTCs
                strcpy(temp_return_message,\
                       "39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1\r");

                strcat(return_message,temp_return_message);

            }   /* end else if(fray_request_index == TARGET_BMW_UKL_FRAY_DATA_REQUESTS) */

        }   /* end  if(ign1_status > OFF)       ---  if(ign_on_flag == TRUE) */
        else    /* dumperr was requested while ign was off, so givem zeros */
        {

            sprintf(return_message,\
                    "err,%s,%d,%d,%d,%d,%d,%d,T%d,0,%d:%d:%d:%d,1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,",\

                    CIB_config_data.BOARD_ID,fray_error_occurred_flag,fray_error_counter,fray_error_notification,wait_for_fray_cold_start_node_flag,flexray_comm_status_vector_CCSV,fault2_cnt,\
                    trig_flag,\

                    fray_request_index,dump_cnt,CIB_reset_flag,ign1_status);

             sprintf(temp_return_message,\
                     "13,0,14,0,15,0,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,33,0,34,0,35,0,36,0,37,0,38,0,");

            strcat(return_message,temp_return_message);

            // 39 - 53 is DTCs
            strcpy(temp_return_message,\
                   "39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0\r");

            strcat(return_message,temp_return_message);

        }   /* end else if(ign1_status > OFF) */


    } // end case TARGET_BMW_FAAR_WE:

    break;

    }  // end switch (target_product)

}  // end trig function


void dump( void )
{
    /* ok to trans in rs485 mode should happen only if spoken to in single board addressing mode */
        if(who_is_addressed == ME)  /* my address? or all, if all dont print  */
        {
            transmit_str_485(return_message);
        }

     dump_cnt++;   // increment dump count

     if (dump_cnt > 9)  // safety - should never be more than 9. gets reset to 0 in main after >9

        {
         dump_cnt=0;
        }

    /* clr error messages - warn, off and product state codes */
        bus1_warn_state = 0;
        bus1_off_state  = 0;
        bus2_warn_state = 0;
        bus2_off_state  = 0;
        fault1_cnt  = 0;
        fault2_cnt  = 0;
        fault3_cnt  = 0;

        trig_flag = 0;   // reset trig flag
        CIB_reset_flag = 0; // set to zero after 1st dump. after a CIB reset it is 1
        can1_sys_state_warm_init = -1; // reset after dump .....variable will be -1 if no crank pulse dump
        can2_sys_state_warm_init = -1; // reset after dump .....variable will be -1 if no crank pulse dump

        fray_error_occurred_flag = 0; //flag to indicate fray errors, clear after print

        //  New B_CIB code
 /******  FORD is unique,  hcurr values are only set on demand by a torque command, some may or may not be available at time of dumperr
  *         so a flag is set at time of request so parse() will not write invalid values over valid values.
  */
        FORD_hcurr_low_value_is_set  = FALSE;       // set to FALSE, when aquired in main() set to true, set back to FALSE after dumperr.
        FORD_hcurr_med_value_is_set  = FALSE;
        FORD_hcurr_high_value_is_set = FALSE;

        can1_FORD_T3_ECU1_MtrCurrQax1_fp = -100;       // init Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
        can1_FORD_T3_ECU1_MtrCurrQax2_fp = -100;
        can1_FORD_T3_ECU1_MtrCurrQax3_fp = -100;

        can1_FORD_T3_ECU1_HwTrq_HwNm1_fp = -100;
        can1_FORD_T3_ECU1_HwTrq_HwNm2_fp = -100;
        can1_FORD_T3_ECU1_HwTrq_HwNm3_fp = -100;

        can1_FORD_T3_ECU2_MtrCurrQax1_fp = -100;
        can1_FORD_T3_ECU2_MtrCurrQax2_fp = -100;
        can1_FORD_T3_ECU2_MtrCurrQax3_fp = -100;

        can1_FORD_T3_ECU2_HwTrq_HwNm1_fp = -100;
        can1_FORD_T3_ECU2_HwTrq_HwNm2_fp = -100;
        can1_FORD_T3_ECU2_HwTrq_HwNm3_fp = -100;

        can1_FORD_MtrCurrQax1_fp = -100;    // init Qax reads to -100 ..also set back after a dumperr
        can1_FORD_MtrCurrQax2_fp = -100;
        can1_FORD_MtrCurrQax3_fp = -100;

        can1_FORD_HwTrq_HwNm1_fp = -100;
        can1_FORD_HwTrq_HwNm2_fp = -100;
        can1_FORD_HwTrq_HwNm3_fp = -100;

        can2_FORD_MtrCurrQax1_fp = -100;
        can2_FORD_MtrCurrQax2_fp = -100;
        can2_FORD_MtrCurrQax3_fp = -100;

        can2_FORD_HwTrq_HwNm1_fp = -100;
        can2_FORD_HwTrq_HwNm2_fp = -100;
        can2_FORD_HwTrq_HwNm3_fp = -100;

        can1_FCA_MtrCurrQax1_fp = -100;     // init Qax reads to -100 ..also set back after a dumperr
        can1_FCA_MtrCurrQax2_fp = -100;
        can1_FCA_MtrCurrQax3_fp = -100;

        can1_FCA_HwTrq_HwNm1_fp = -100;
        can1_FCA_HwTrq_HwNm2_fp = -100;
        can1_FCA_HwTrq_HwNm3_fp = -100;

        can2_FCA_MtrCurrQax1_fp = -100;
        can2_FCA_MtrCurrQax2_fp = -100;
        can2_FCA_MtrCurrQax3_fp = -100;

        can2_FCA_HwTrq_HwNm1_fp = -100;
        can2_FCA_HwTrq_HwNm2_fp = -100;
        can2_FCA_HwTrq_HwNm3_fp = -100;

        can_C1XX_MtrCurrQax1_fp = -100;  // init Hcurr Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
        can_C1XX_MtrCurrQax2_fp = -100;
        can_C1XX_MtrCurrQax3_fp = -100;

        can_C1XX_HwTrq_HwNm1_fp = -100;
        can_C1XX_HwTrq_HwNm2_fp = -100;
        can_C1XX_HwTrq_HwNm3_fp = -100;

        can_T1XX_MotCurrQax1_fp = -100;  // init Hcurr Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
        can_T1XX_MotCurrQax2_fp = -100;
        can_T1XX_MotCurrQax3_fp = -100;

        can_T1XX_HwTqArbn_HwTq1_fp = -100;
        can_T1XX_HwTqArbn_HwTq2_fp = -100;
        can_T1XX_HwTqArbn_HwTq3_fp = -100;

        can_GWM_A0607_MotCurrQax1_fp = -100;  // init Hcurr Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
        can_GWM_A0607_MotCurrQax2_fp = -100;
        can_GWM_A0607_MotCurrQax3_fp = -100;

        can_GWM_A0607_HwTqArbn_HwTq1_fp = -100;
        can_GWM_A0607_HwTqArbn_HwTq2_fp = -100;
        can_GWM_A0607_HwTqArbn_HwTq3_fp = -100;

        can1_G2KCA_MtrCurrQax1_fp = -100;       // init Qax reads to -100 ..also set back after a dumperr
        can1_G2KCA_MtrCurrQax2_fp = -100;
        can1_G2KCA_MtrCurrQax3_fp = -100;

        can1_G2KCA_HwTrq_HwNm1_fp = -100;
        can1_G2KCA_HwTrq_HwNm2_fp = -100;
        can1_G2KCA_HwTrq_HwNm3_fp = -100;

        can2_G2KCA_MtrCurrQax1_fp = -100;
        can2_G2KCA_MtrCurrQax2_fp = -100;
        can2_G2KCA_MtrCurrQax3_fp = -100;

        can2_G2KCA_HwTrq_HwNm1_fp = -100;
        can2_G2KCA_HwTrq_HwNm2_fp = -100;
        can2_G2KCA_HwTrq_HwNm3_fp = -100;

        // Note - PSA does not have a Hcurr sequence

        can1_CN200_MtrCurrQax1_fp = -100;       // init Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
        can1_CN200_MtrCurrQax2_fp = -100;
        can1_CN200_MtrCurrQax3_fp = -100;

        can1_CN200_HwTrq_HwNm1_fp = -100;
        can1_CN200_HwTrq_HwNm2_fp = -100;
        can1_CN200_HwTrq_HwNm3_fp = -100;

        can1_RENAULT_NISSAN_MtrCurrQax1_fp = -100;       // init Qax reads to -100 ..also set back after a dumperr. Only changed during Hcurr command.
        can1_RENAULT_NISSAN_MtrCurrQax2_fp = -100;
        can1_RENAULT_NISSAN_MtrCurrQax3_fp = -100;

        can1_RENAULT_NISSAN_HwTrq_HwNm1_fp = -100;
        can1_RENAULT_NISSAN_HwTrq_HwNm2_fp = -100;
        can1_RENAULT_NISSAN_HwTrq_HwNm3_fp = -100;

        // Note - BMW does not have a Hcurr sequence



} // end dump function

void parse_can1_data(void)
{
    // OR ECU1
    // itemxx: is a label.  Not used by program. Just a easy way for you to associate where data came from.
    //      Number is canMessageNotification (case CCP_RESPONSE_ID:) switch(can1_request_index), index value at the point of message reception.
    //      So, I sent a CAN CCP request, got a CAN Response, stored it, memcpy(&can1_dump_err_data[1],&can1_rx_data,8); and here, process it.

    switch (processor_type)
    {
    case TMS570:
        switch (target_product)
        {

        case TARGET_CD391_ADAS:
            itemA_1:   memcpy(&can1_FORD_BattVltg_fp,&can1_dump_err_data[1][1],4);
            itemA_2:   memcpy(&can1_FORD_Temperature_fp,&can1_dump_err_data[2][1],4);
            itemA_3:   memcpy(&can1_FORD_DigT1_fp,&can1_dump_err_data[3][1],4);
            itemA_4:   memcpy(&can1_FORD_DigT2_fp,&can1_dump_err_data[4][1],4);
            itemA_5:   memcpy(&can1_FORD_MtrCurrQax_fp,&can1_dump_err_data[5][1],4);
            itemA_6:   can1_FORD_SystemState_byt = can1_dump_err_data[6][1];
            itemA_7:   memcpy(&can1_FORD_HwTrq_HwNm_fp,&can1_dump_err_data[7][1],4);
            itemA_8:   memcpy(&can1_FORD_Abs_Hw_Pos_fp,&can1_dump_err_data[8][1],4);
            itemA_9:   memcpy(&can1_FORD_Batt_Current_fp,&can1_dump_err_data[9][1],4);
            itemA_10:   can1_FORD_LatchFail_ISR_u16 = can1_dump_err_data[10][2];
            itemA_11:   can1_FORD_MtrCntl_ISR_u16 = can1_dump_err_data[11][2];
            itemA_12:   can1_FORD_MinCount_u32 = can1_dump_err_data[12][4];
            itemA_13:   can1_FORD_MaxCount_u32 = can1_dump_err_data[13][4];
            itemA_14:   can1_FORD_CatGate_cnt = can1_dump_err_data[14][4];


            itemA_2000: memcpy(&can1_FORD_MtrCurrQax1_fp,&can1_dump_err_data[15][1],4);
            itemA_2001: memcpy(&can1_FORD_HwTrq_HwNm1_fp,&can1_dump_err_data[16][1],4);
            itemA_2010: memcpy(&can1_FORD_MtrCurrQax2_fp,&can1_dump_err_data[17][1],4);
            itemA_2011: memcpy(&can1_FORD_HwTrq_HwNm2_fp,&can1_dump_err_data[18][1],4);
            itemA_2020: memcpy(&can1_FORD_MtrCurrQax3_fp,&can1_dump_err_data[19][1],4);
            itemA_2021:     memcpy(&can1_FORD_HwTrq_HwNm3_fp,&can1_dump_err_data[20][1],4);

        break;  //  end case TARGET_CD391_ADAS:

        case TARGET_FCA_ADAS:
            itemB_1:   memcpy(&can1_FCA_BattVltg_fp,&can1_dump_err_data[1][1],4);
            itemB_2:   memcpy(&can1_FCA_Temperature_fp,&can1_dump_err_data[2][1],4);
            itemB_3:   memcpy(&can1_FCA_DigT1_fp,&can1_dump_err_data[3][1],4);
            itemB_4:   memcpy(&can1_FCA_DigT2_fp,&can1_dump_err_data[4][1],4);
            itemB_5:   memcpy(&can1_FCA_MtrCurrQax_fp,&can1_dump_err_data[5][1],4);
            itemB_6:   can1_FCA_SystemState_byt = can1_dump_err_data[6][1];
            itemB_7:   memcpy(&can1_FCA_HwTrq_HwNm_fp,&can1_dump_err_data[7][1],4);
            itemB_8:   memcpy(&can1_FCA_Abs_Hw_Pos_fp,&can1_dump_err_data[8][1],4);

            itemB_2000: memcpy(&can1_FCA_MtrCurrQax1_fp,&can1_dump_err_data[9][1],4);
            itemB_2001: memcpy(&can1_FCA_HwTrq_HwNm1_fp,&can1_dump_err_data[10][1],4);
            itemB_2010: memcpy(&can1_FCA_MtrCurrQax2_fp,&can1_dump_err_data[11][1],4);
            itemB_2011: memcpy(&can1_FCA_HwTrq_HwNm2_fp,&can1_dump_err_data[12][1],4);
            itemB_2020: memcpy(&can1_FCA_MtrCurrQax3_fp,&can1_dump_err_data[13][1],4);
            itemB_2021: memcpy(&can1_FCA_HwTrq_HwNm3_fp,&can1_dump_err_data[14][1],4);

        break;  //  end case TARGET_FCA_ADAS:


        case TARGET_9BXX:       // hex string for floating point repesentation "0x00 0x00 0x00 0x00"  (old style)

            //  order for big eindian  TMS570 product
//          item01:     can_sys_state = can1_dump_err_data[1][1];
//          item02:     sprintf(can_RelHwPos_HwDeg_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[2][1],can1_dump_err_data[2][2],can1_dump_err_data[2][3],can1_dump_err_data[2][4]);
//          item03:     sprintf(can_AbsHwPos_HwDeg_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[3][1],can1_dump_err_data[3][2],can1_dump_err_data[3][3],can1_dump_err_data[3][4]);
//          item04:     sprintf(can_ColPos_HwDeg_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[4][1],can1_dump_err_data[4][2],can1_dump_err_data[4][3],can1_dump_err_data[4][4]);
//          item05:     sprintf(can_AnaHwTrq1_HwNm_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[5][1],can1_dump_err_data[5][2],can1_dump_err_data[5][3],can1_dump_err_data[5][4]);
//          item06:     sprintf(can_AnaHwTrq2_HwNm_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[6][1],can1_dump_err_data[6][2],can1_dump_err_data[6][3],can1_dump_err_data[6][4]);
//          item07:     sprintf(can_Ch1_T1_T2_HwNm_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[7][1],can1_dump_err_data[7][2],can1_dump_err_data[7][3],can1_dump_err_data[7][4]);
//          item08:     sprintf(can_DigHwTrq3_HwNm_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[8][1],can1_dump_err_data[8][2],can1_dump_err_data[8][3],can1_dump_err_data[8][4]);
//          item09:     sprintf(can_DigHwTrq4_HwNm_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[9][1],can1_dump_err_data[9][2],can1_dump_err_data[9][3],can1_dump_err_data[9][4]);
//          item010:    sprintf(can_Ch2_T3_T4_HwNm_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[10][1],can1_dump_err_data[10][2],can1_dump_err_data[10][3],can1_dump_err_data[10][4]);
//          item011:    sprintf(can_HwTrq_Final_HwNm_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[11][1],can1_dump_err_data[11][2],can1_dump_err_data[11][3],can1_dump_err_data[11][4]);
//          item012:    sprintf(can_vbatt_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[12][1],can1_dump_err_data[12][2],can1_dump_err_data[12][3],can1_dump_err_data[12][4]);
//          item013:    sprintf(can_batt_curr_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[13][1],can1_dump_err_data[13][2],can1_dump_err_data[13][3],can1_dump_err_data[13][4]);
//          item014:    sprintf(can_temperature_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[14][1],can1_dump_err_data[14][2],can1_dump_err_data[14][3],can1_dump_err_data[14][4]);
//          item015:    sprintf(can_MtrCurrQax_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[15][1],can1_dump_err_data[15][2],can1_dump_err_data[15][3],can1_dump_err_data[15][4]);
//          item016:    sprintf(can_EstQaxCurr_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[16][1],can1_dump_err_data[16][2],can1_dump_err_data[16][3],can1_dump_err_data[16][4]);
//          item017:    sprintf(can_MtrTrq_Cmd_Nm_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[17][1],can1_dump_err_data[17][2],can1_dump_err_data[17][3],can1_dump_err_data[17][4]);
//          item018:    sprintf(can_MtrCurrDax_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[18][1],can1_dump_err_data[18][2],can1_dump_err_data[18][3],can1_dump_err_data[18][4]);
//          item019:    sprintf(can_MtrCurrA_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[19][1],can1_dump_err_data[19][2],can1_dump_err_data[19][3],can1_dump_err_data[19][4]);
//  // what they look like
//  //  item19: can_sent1_cnt = (can1_dump_err_data[18][1] << 8) + (can1_dump_err_data[18][2]);
//  //  item20: can_sent2_cnt = (can1_dump_err_data[19][1] << 8) + (can1_dump_err_data[19][2]);
//  //  item19: sprintf(can_sent1_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[18][1],can1_dump_err_data[18][2],can1_dump_err_data[18][3],can1_dump_err_data[18][4]);
//
//          item020:    sprintf(can_MtrCurrB_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[20][1],can1_dump_err_data[20][2],can1_dump_err_data[20][3],can1_dump_err_data[20][4]);
//          item021:    sprintf(can_MtrCurrC_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[21][1],can1_dump_err_data[21][2],can1_dump_err_data[21][3],can1_dump_err_data[21][4]);
//          item022:    can_DigMSB_MtrPos1_Rev_cnt = (can1_dump_err_data[22][1] << 8) + (can1_dump_err_data[22][2]);
//          item023:    can_DigMSB_MtrPos2_Rev_cnt = (can1_dump_err_data[23][1] << 8) + (can1_dump_err_data[23][2]);
//          item024:    can_DigMSB_MtrPos1_Roll_cnt = (can1_dump_err_data[24][1] << 8) + (can1_dump_err_data[24][2]);
//          item025:    can_DigMSB_MtrPos2_Roll_cnt = (can1_dump_err_data[25][1] << 8) + (can1_dump_err_data[25][2]);
//          item026:    sprintf(can_DigMSB_MtrPosMecl_Rev_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[26][1],can1_dump_err_data[26][2],can1_dump_err_data[26][3],can1_dump_err_data[26][4]);
//          item027:    can_AnaMSB_Cos_cnt = (can1_dump_err_data[27][1] << 8) + (can1_dump_err_data[27][2]);
//          item028:    can_AnaMSB_Sin_cnt = (can1_dump_err_data[28][1] << 8) + (can1_dump_err_data[28][2]);
//          item029:    can_AnaMSB_MtrPosMecl_Rev_cnt = (can1_dump_err_data[29][1] << 8) + (can1_dump_err_data[29][2]);
//          item030:    can_AnaMSB_MtrPosMecl_Roll_cnt = (can1_dump_err_data[30][1] << 8) + (can1_dump_err_data[30][2]);
//          item031:    sprintf(can_MtrCurrPos_Rev_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[31][1],can1_dump_err_data[31][2],can1_dump_err_data[31][3],can1_dump_err_data[31][4]);
//          item032:    sprintf(can_ElecMtrPos_Rev_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[32][1],can1_dump_err_data[32][2],can1_dump_err_data[32][3],can1_dump_err_data[32][4]);
//          item033:    sprintf(can_prod_3p3V_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[33][1],can1_dump_err_data[33][2],can1_dump_err_data[33][3],can1_dump_err_data[33][4]);
//          item034:    sprintf(can_prod_5V_P1_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[34][1],can1_dump_err_data[34][2],can1_dump_err_data[34][3],can1_dump_err_data[34][4]);
//          item035:    sprintf(can_prod_5V_P2_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[35][1],can1_dump_err_data[35][2],can1_dump_err_data[35][3],can1_dump_err_data[35][4]);
//
//  //      item02000:  sprintf(can_MotCurrQax1_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[28][1],can1_dump_err_data[28][2],can1_dump_err_data[28][3],can1_dump_err_data[28][4]);
//  //      item02001:  sprintf(can_HwTqArbn_HwTq1_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[29][1],can1_dump_err_data[29][2],can1_dump_err_data[29][3],can1_dump_err_data[29][4]);
//  //      item02010:  sprintf(can_MotCurrQax2_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[30][1],can1_dump_err_data[30][2],can1_dump_err_data[30][3],can1_dump_err_data[30][4]);
//  //      item02011:  sprintf(can_HwTqArbn_HwTq2_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[31][1],can1_dump_err_data[31][2],can1_dump_err_data[31][3],can1_dump_err_data[31][4]);
//  //      item02020:  sprintf(can_MotCurrQax3_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[32][1],can1_dump_err_data[32][2],can1_dump_err_data[32][3],can1_dump_err_data[32][4]);
//  //      item02021:   sprintf(can_HwTqArbn_HwTq3_str,"%.2X%.2X%.2X%.2X",can1_dump_err_data[33][1],can1_dump_err_data[33][2],can1_dump_err_data[33][3],can1_dump_err_data[33][4]);

            break;  //  end case TARGET_9BXX:

        case TARGET_S550ANALOG:
            break;

        case TARGET_S550DIGITAL:
            break;

        case TARGET_C1XX:       // move Hex coded float, 4 bytes starting at [1], allows dumperr string to output true floats  ex: "12.47" (new style)

            itemC_1:    memcpy(&can_C1XX_BattVltg_fp,&can1_dump_err_data[1][1],4);
            itemC_2:    memcpy(&can_C1XX_Temperature_fp,&can1_dump_err_data[2][1],4);
            itemC_3:    memcpy(&can_C1XX_DigT1_fp,&can1_dump_err_data[3][1],4);
            itemC_4:    memcpy(&can_C1XX_DigT2_fp,&can1_dump_err_data[4][1],4);
            itemC_5:    memcpy(&can_C1XX_MtrCurrQax_fp,&can1_dump_err_data[5][1],4);
            itemC_6:    can_C1XX_OnStateFltAcc_cnt = (can1_dump_err_data[6][1] << 8) + (can1_dump_err_data[6][2]);
            itemC_7:    can_C1XX_GateDriveFltAcc_cnt = (can1_dump_err_data[7][1] << 8) + (can1_dump_err_data[7][2]);
            itemC_8:    can_C1XX_GateDrvFltSts_cnt = (can1_dump_err_data[8][1] << 8) + (can1_dump_err_data[8][2]);
            itemC_9:    can_C1XX_SystemState_byt = can1_dump_err_data[9][1];

            itemC_10:   memcpy(&can_C1XX_HwTrq_HwNm_fp,&can1_dump_err_data[10][1],4);
            itemC_11:   memcpy(&can_C1XX_Abs_Hw_Pos_fp,&can1_dump_err_data[11][1],4);
            itemC_12:   memcpy(&can_C1XX_Rel_Hw_Pos_fp,&can1_dump_err_data[12][1],4);
            itemC_13:   can_C1XX_ManualTrqCmdEn_cnt = (can1_dump_err_data[13][1] << 8) + (can1_dump_err_data[13][2]);
            itemC_14:   memcpy(&can_C1XX_MtrTrq_Cmd_Nm_fp,&can1_dump_err_data[14][1],4);
            itemC_15:   can_C1XX_MSB_Die1_cnt = (can1_dump_err_data[15][1] << 8) + (can1_dump_err_data[15][2]);
            itemC_16:   can_C1XX_MSB_Die2_cnt = (can1_dump_err_data[16][1] << 8) + (can1_dump_err_data[16][2]);
            itemC_17:   memcpy(&can_C1XX_MtrTempEst_MagTempEst_DegC_fp,&can1_dump_err_data[17][1],4);

            itemC_2000: memcpy(&can_C1XX_MtrCurrQax1_fp,&can1_dump_err_data[18][1],4);
            itemC_2001: memcpy(&can_C1XX_HwTrq_HwNm1_fp,&can1_dump_err_data[19][1],4);
            itemC_2010: memcpy(&can_C1XX_MtrCurrQax2_fp,&can1_dump_err_data[20][1],4);
            itemC_2011: memcpy(&can_C1XX_HwTrq_HwNm2_fp,&can1_dump_err_data[21][1],4);
            itemC_2020: memcpy(&can_C1XX_MtrCurrQax3_fp,&can1_dump_err_data[22][1],4);
            itemC_2021: memcpy(&can_C1XX_HwTrq_HwNm3_fp,&can1_dump_err_data[23][1],4);


            break;  //  end case TARGET_C1XX:

        case TARGET_PSA_CMP:       // move Hex coded float, 4 bytes starting at [1], allows dumperr string to output true floats  ex: "12.47" (new style)

            itemD_1:   memcpy(&can1_PSA_CMP_BattVltg_fp,&can1_dump_err_data[1][1],4);
            itemD_2:   memcpy(&can1_PSA_CMP_Temperature_fp,&can1_dump_err_data[2][1],4);
            itemD_3:   memcpy(&can1_PSA_CMP_DigT1_fp,&can1_dump_err_data[3][1],4);
            itemD_4:   memcpy(&can1_PSA_CMP_DigT2_fp,&can1_dump_err_data[4][1],4);
            itemD_5:   can1_PSA_CMP_SystemState_byt = can1_dump_err_data[5][1];
            itemD_6:   memcpy(&can1_PSA_CMP_MtrCurrQax_fp,&can1_dump_err_data[6][1],4);
            itemD_7:   memcpy(&can1_PSA_CMP_MtrCurrDax_fp,&can1_dump_err_data[7][1],4);
            itemD_8:   memcpy(&can1_PSA_CMP_HwTrq_HwNm_fp,&can1_dump_err_data[8][1],4);
            itemD_9:   memcpy(&can1_PSA_CMP_MtrTrqCmd_HwNm_fp,&can1_dump_err_data[9][1],4);
            itemD_10:  memcpy(&can1_PSA_CMP_AstMtrTrq_HwNm_fp,&can1_dump_err_data[10][1],4);
            itemD_11:  memcpy(&can1_PSA_CMP_Abs_Hw_Pos_fp,&can1_dump_err_data[11][1],4);
            itemD_12:  memcpy(&can1_PSA_CMP_Rel_Hw_Pos_fp,&can1_dump_err_data[12][1],4);
            itemD_13:  can1_PSA_CMP_Abs_Hw_Pos_Valid_byt = can1_dump_err_data[13][1];
            itemD_14:  memcpy(&can1_PSA_CMP_MtrPos_fp,&can1_dump_err_data[14][1],4);
            itemD_15:  memcpy(&can1_PSA_CMP_ADC_MtrCurr1_fp,&can1_dump_err_data[15][1],4);
            itemD_16:  memcpy(&can1_PSA_CMP_ADC_MtrCurr2_fp,&can1_dump_err_data[16][1],4);

            break;  //  end case TARGET_PSA_CMP:

        case TARGET_BMW_UKL:
            // still needs to be swapped because of FlexRay protocal
            itemE_1:  swap[0]= fray_dump_err_data[1][3];swap[1]= fray_dump_err_data[1][2];swap[2]= fray_dump_err_data[1][1];swap[3]= fray_dump_err_data[1][0];memcpy(&fray1_BMW_UKL_Batt_Volt_fp, &swap,4);
            itemE_2:  swap[0]= fray_dump_err_data[2][3];swap[1]= fray_dump_err_data[2][2];swap[2]= fray_dump_err_data[2][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_BMW_UKL_Batt_Curr_fp, &swap,4);
            itemE_3:  swap[0]= fray_dump_err_data[3][3];swap[1]= fray_dump_err_data[3][2];swap[2]= fray_dump_err_data[3][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_BMW_UKL_Mot_Curr_fp, &swap,4);
            itemE_4:  swap[0]= fray_dump_err_data[4][3];swap[1]= fray_dump_err_data[4][2];swap[2]= fray_dump_err_data[4][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_BMW_UKL_Mot_Vel_fp, &swap,4);
            itemE_5:  swap[0]= fray_dump_err_data[5][3];swap[1]= fray_dump_err_data[5][2];swap[2]= fray_dump_err_data[5][1];swap[3]= fray_dump_err_data[2][0]; memcpy(&fray1_BMW_UKL_Comm_Torque_fp, &swap,4);
            itemE_6:  swap[0]= fray_dump_err_data[6][3];swap[1]= fray_dump_err_data[6][2];swap[2]= fray_dump_err_data[6][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_BMW_UKL_Lim_Torque_fp, &swap,4);
            itemE_7:  swap[0]= fray_dump_err_data[7][3];swap[1]= fray_dump_err_data[7][2];swap[2]= fray_dump_err_data[7][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_BMW_UKL_PCB_Temp_fp, &swap,4);
            itemE_8:  swap[0]= fray_dump_err_data[8][3];swap[1]= fray_dump_err_data[8][2];swap[2]= fray_dump_err_data[8][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_BMW_UKL_Mot_Temp_fp, &swap,4);
            itemE_9:  swap[0]= fray_dump_err_data[9][3];swap[1]= fray_dump_err_data[9][2];swap[2]= fray_dump_err_data[9][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_BMW_UKL_Junction_Temp_fp, &swap,4);
            itemE_10: swap[0]= fray_dump_err_data[10][3];swap[1]= fray_dump_err_data[10][2];swap[2]= fray_dump_err_data[10][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_BMW_UKL_HW_Angle_fp, &swap,4);
            itemE_11: swap[0]= fray_dump_err_data[11][3];swap[1]= fray_dump_err_data[11][2];swap[2]= fray_dump_err_data[11][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_BMW_UKL_Diff_Torque_fp, &swap,4);
            itemE_12: fray1_BMW_UKL_sys_state_byt = fray_dump_err_data[12][3];
            itemE_13: swap[0]= fray_dump_err_data[13][3];swap[1]= fray_dump_err_data[13][2];swap[2]= fray_dump_err_data[13][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_BMW_UKL_T1_Volt_fp, &swap,4);
            itemE_14: swap[0]= fray_dump_err_data[14][3];swap[1]= fray_dump_err_data[14][2];swap[2]= fray_dump_err_data[14][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_BMW_UKL_T2_Volt_fp, &swap,4);
            break;  //  end case TARGET_BMW_UKL:

        }

        break;  // end case TMS570:

    case RENSIS:
        // eindian_swap[0] = can_test_string[4];eindian_swap[1] = can_test_string[3];eindian_swap[2] = can_test_string[2];eindian_swap[3] = can_test_string[1];
        // memcpy(&can_MotCurrQax_fp, eindian_swap,4);  // method1
        switch (target_product)
        {

        case TARGET_SGMW_CN200:
            itemL_1:   swap[0]=can1_dump_err_data[1][4];swap[1]=can1_dump_err_data[1][3];swap[2]=can1_dump_err_data[1][2];swap[3]=can1_dump_err_data[1][1];memcpy(&can1_CN200_BattVltg_fp, swap,4);
            itemL_2:   swap[0]=can1_dump_err_data[2][4];swap[1]=can1_dump_err_data[2][3];swap[2]=can1_dump_err_data[2][2];swap[3]=can1_dump_err_data[2][1];memcpy(&can1_CN200_Temperature_fp, swap,4);
            itemL_3:   swap[0]=can1_dump_err_data[3][4];swap[1]=can1_dump_err_data[3][3];swap[2]=can1_dump_err_data[3][2];swap[3]=can1_dump_err_data[3][1];memcpy(&can1_CN200_DigT1_HwNm_fp, swap,4);
            itemL_4:   swap[0]=can1_dump_err_data[4][4];swap[1]=can1_dump_err_data[4][3];swap[2]=can1_dump_err_data[4][2];swap[3]=can1_dump_err_data[4][1];memcpy(&can1_CN200_DigT2_HwNm_fp, swap,4);
            itemL_5:   swap[0]=can1_dump_err_data[5][4];swap[1]=can1_dump_err_data[5][3];swap[2]=can1_dump_err_data[5][2];swap[3]=can1_dump_err_data[5][1];memcpy(&can1_CN200_MtrCurrQax_fp, swap,4);
            itemL_6:   can1_CN200_SystemState_byt = can1_dump_err_data[6][1];
            itemL_7:   swap[0]=can1_dump_err_data[7][4];swap[1]=can1_dump_err_data[7][3];swap[2]=can1_dump_err_data[7][2];swap[3]=can1_dump_err_data[7][1];memcpy(&can1_CN200_HwTrq_HwNm_fp, swap,4);
            itemL_8:   swap[0]=can1_dump_err_data[8][4];swap[1]=can1_dump_err_data[8][3];swap[2]=can1_dump_err_data[8][2];swap[3]=can1_dump_err_data[8][1];memcpy(&can1_CN200_Abs_Hw_Pos_fp, swap,4);
            itemL_9:   swap[0]=can1_dump_err_data[9][4];swap[1]=can1_dump_err_data[9][3];swap[2]=can1_dump_err_data[9][2];swap[3]=can1_dump_err_data[9][1];memcpy(&can1_CN200_MotTrq_Crf_fp, swap,4);
            itemL_10:  swap[0]=can1_dump_err_data[10][4];swap[1]=can1_dump_err_data[10][3];swap[2]=can1_dump_err_data[10][2];swap[3]=can1_dump_err_data[10][1];memcpy(&can1_CN200_MotTrq_Mrf_fp, swap,4);
            itemL_11:  swap[0]=can1_dump_err_data[11][4];swap[1]=can1_dump_err_data[11][3];swap[2]=can1_dump_err_data[11][2];swap[3]=can1_dump_err_data[11][1];memcpy(&can1_CN200_VehSpd_fp, swap,4);
            itemL_12:  swap[0]=can1_dump_err_data[12][4];swap[1]=can1_dump_err_data[12][3];swap[2]=can1_dump_err_data[12][2];swap[3]=can1_dump_err_data[12][1];memcpy(&can1_CN200_Spare2_fp, swap,4);


            itemL_2000:  swap[0]=can1_dump_err_data[13][4];swap[1]=can1_dump_err_data[13][3];swap[2]=can1_dump_err_data[13][2];swap[3]=can1_dump_err_data[13][1];memcpy(&can1_CN200_MtrCurrQax1_fp, swap,4);
            itemL_2001:  swap[0]=can1_dump_err_data[14][4];swap[1]=can1_dump_err_data[14][3];swap[2]=can1_dump_err_data[14][2];swap[3]=can1_dump_err_data[14][1];memcpy(&can1_CN200_HwTrq_HwNm1_fp, swap,4);
            itemL_2010:  swap[0]=can1_dump_err_data[15][4];swap[1]=can1_dump_err_data[15][3];swap[2]=can1_dump_err_data[15][2];swap[3]=can1_dump_err_data[15][1];memcpy(&can1_CN200_MtrCurrQax2_fp, swap,4);
            itemL_2011:  swap[0]=can1_dump_err_data[16][4];swap[1]=can1_dump_err_data[16][3];swap[2]=can1_dump_err_data[16][2];swap[3]=can1_dump_err_data[16][1];memcpy(&can1_CN200_HwTrq_HwNm2_fp, swap,4);
            itemL_2020:  swap[0]=can1_dump_err_data[17][4];swap[1]=can1_dump_err_data[17][3];swap[2]=can1_dump_err_data[17][2];swap[3]=can1_dump_err_data[17][1];memcpy(&can1_CN200_MtrCurrQax3_fp, swap,4);
            itemL_2021:  swap[0]=can1_dump_err_data[18][4];swap[1]=can1_dump_err_data[18][3];swap[2]=can1_dump_err_data[18][2];swap[3]=can1_dump_err_data[18][1];memcpy(&can1_CN200_HwTrq_HwNm3_fp, swap,4);


        break;  //  end case TARGET_SGMW_CN200:

        case TARGET_G2KCA_ADAS:
            itemM_1:   swap[0]=can1_dump_err_data[1][4];swap[1]=can1_dump_err_data[1][3];swap[2]=can1_dump_err_data[1][2];swap[3]=can1_dump_err_data[1][1];memcpy(&can1_G2KCA_BattVltg_fp, swap,4);
            itemM_2:   swap[0]=can1_dump_err_data[2][4];swap[1]=can1_dump_err_data[2][3];swap[2]=can1_dump_err_data[2][2];swap[3]=can1_dump_err_data[2][1];memcpy(&can1_G2KCA_Temperature_fp, swap,4);
            itemM_3:   swap[0]=can1_dump_err_data[3][4];swap[1]=can1_dump_err_data[3][3];swap[2]=can1_dump_err_data[3][2];swap[3]=can1_dump_err_data[3][1];memcpy(&can1_G2KCA_DigT1_fp, swap,4);
            itemM_4:   swap[0]=can1_dump_err_data[4][4];swap[1]=can1_dump_err_data[4][3];swap[2]=can1_dump_err_data[4][2];swap[3]=can1_dump_err_data[4][1];memcpy(&can1_G2KCA_DigT2_fp, swap,4);
            itemM_5:   swap[0]=can1_dump_err_data[5][4];swap[1]=can1_dump_err_data[5][3];swap[2]=can1_dump_err_data[5][2];swap[3]=can1_dump_err_data[5][1];memcpy(&can1_G2KCA_MtrCurrQax_fp, swap,4);
            itemM_6:   can1_G2KCA_SystemState_byt = can1_dump_err_data[6][1];
            itemM_7:   swap[0]=can1_dump_err_data[7][4];swap[1]=can1_dump_err_data[7][3];swap[2]=can1_dump_err_data[7][2];swap[3]=can1_dump_err_data[7][1];memcpy(&can1_G2KCA_HwTrq_HwNm_fp, swap,4);
            itemM_8:   swap[0]=can1_dump_err_data[8][4];swap[1]=can1_dump_err_data[8][3];swap[2]=can1_dump_err_data[8][2];swap[3]=can1_dump_err_data[8][1];memcpy(&can1_G2KCA_Abs_Hw_Pos_fp, swap,4);


            itemM_2000: swap[0]=can1_dump_err_data[9][4];swap[1]=can1_dump_err_data[9][3];swap[2]=can1_dump_err_data[9][2];swap[3]=can1_dump_err_data[9][1];memcpy(&can1_G2KCA_MtrCurrQax1_fp, swap,4);
            itemM_2001: swap[0]=can1_dump_err_data[10][4];swap[1]=can1_dump_err_data[10][3];swap[2]=can1_dump_err_data[10][2];swap[3]=can1_dump_err_data[10][1];memcpy(&can1_G2KCA_HwTrq_HwNm1_fp, swap,4);
            itemM_2010: swap[0]=can1_dump_err_data[11][4];swap[1]=can1_dump_err_data[11][3];swap[2]=can1_dump_err_data[11][2];swap[3]=can1_dump_err_data[11][1];memcpy(&can1_G2KCA_MtrCurrQax2_fp, swap,4);
            itemM_2011: swap[0]=can1_dump_err_data[12][4];swap[1]=can1_dump_err_data[12][3];swap[2]=can1_dump_err_data[12][2];swap[3]=can1_dump_err_data[12][1];memcpy(&can1_G2KCA_HwTrq_HwNm2_fp, swap,4);
            itemM_2020: swap[0]=can1_dump_err_data[13][4];swap[1]=can1_dump_err_data[13][3];swap[2]=can1_dump_err_data[13][2];swap[3]=can1_dump_err_data[13][1];memcpy(&can1_G2KCA_MtrCurrQax3_fp, swap,4);
            itemM_2021: swap[0]=can1_dump_err_data[14][4];swap[1]=can1_dump_err_data[14][3];swap[2]=can1_dump_err_data[14][2];swap[3]=can1_dump_err_data[14][1];memcpy(&can1_G2KCA_HwTrq_HwNm3_fp, swap,4);

        break;  //  end case TARGET_G2KCA_ADAS:

        case TARGET_T1XX:
        //      changed order for little Eindian RenSys processor, resulting in memcpy directly into floating point variable, which allows dumperr string to output true floats  ex: "12.47" (new style)
            itemN_1:    can_T1XX_SystemState_byt = can1_dump_err_data[1][1];
            itemN_2:    swap[0]= can1_dump_err_data[2][4];swap[1]= can1_dump_err_data[2][3];swap[2]= can1_dump_err_data[2][2];swap[3]= can1_dump_err_data[2][1];memcpy(&can_T1XX_MotCurrQax_fp, swap,4);
            itemN_3:    swap[0]= can1_dump_err_data[3][4];swap[1]= can1_dump_err_data[3][3];swap[2]= can1_dump_err_data[3][2];swap[3]= can1_dump_err_data[3][1];memcpy(&can_T1XX_HwTq0Meas_HwTq0_fp, swap,4);
            itemN_4:    swap[0]= can1_dump_err_data[4][4];swap[1]= can1_dump_err_data[4][3];swap[2]= can1_dump_err_data[4][2];swap[3]= can1_dump_err_data[4][1];memcpy(&can_T1XX_HwTq1Meas_HwTq1_fp, swap,4);
            itemN_5:    swap[0]= can1_dump_err_data[5][4];swap[1]= can1_dump_err_data[5][3];swap[2]= can1_dump_err_data[5][2];swap[3]= can1_dump_err_data[5][1];memcpy(&can_T1XX_HwTq2Meas_HwTq2_fp, swap,4);
            itemN_6:    swap[0]= can1_dump_err_data[6][4];swap[1]= can1_dump_err_data[6][3];swap[2]= can1_dump_err_data[6][2];swap[3]= can1_dump_err_data[6][1];memcpy(&can_T1XX_HwTq3Meas_HwTq3_fp, swap,4);
            itemN_7:    swap[0]= can1_dump_err_data[7][4];swap[1]= can1_dump_err_data[7][3];swap[2]= can1_dump_err_data[7][2];swap[3]= can1_dump_err_data[7][1];memcpy(&can_T1XX_EcuTFild_fp, swap,4);
            itemN_8:    swap[0]= can1_dump_err_data[8][4];swap[1]= can1_dump_err_data[8][3];swap[2]= can1_dump_err_data[8][2];swap[3]= can1_dump_err_data[8][1];memcpy(&can_T1XX_HwAgArbn_HwAg_fp, swap,4);
            itemN_9:    swap[0]= can1_dump_err_data[9][4];swap[1]= can1_dump_err_data[9][3];swap[2]= can1_dump_err_data[9][2];swap[3]= can1_dump_err_data[9][1];memcpy(&can_T1XX_HwAg0_fp, swap,4);
            itemN_10:   swap[0]=can1_dump_err_data[10][4];swap[1]=can1_dump_err_data[10][3];swap[2]=can1_dump_err_data[10][2];swap[3]=can1_dump_err_data[10][1];memcpy(&can_T1XX_HwAg1_fp, swap,4);
            itemN_11:   swap[0]=can1_dump_err_data[11][4];swap[1]=can1_dump_err_data[11][3];swap[2]=can1_dump_err_data[11][2];swap[3]=can1_dump_err_data[11][1];memcpy(&can_T1XX_HwTqArbn_HwTq_fp, swap,4);
            itemN_12:   swap[0]=can1_dump_err_data[12][4];swap[1]=can1_dump_err_data[12][3];swap[2]=can1_dump_err_data[12][2];swap[3]=can1_dump_err_data[12][1];memcpy(&can_T1XX_MotCurrDax_fp, swap,4);
            itemN_13:   swap[0]=can1_dump_err_data[13][4];swap[1]=can1_dump_err_data[13][3];swap[2]=can1_dump_err_data[13][2];swap[3]=can1_dump_err_data[13][1];memcpy(&can_T1XX_HwTqArbn_HwTqChA_fp, swap,4);
            itemN_14:   swap[0]=can1_dump_err_data[14][4];swap[1]=can1_dump_err_data[14][3];swap[2]=can1_dump_err_data[14][2];swap[3]=can1_dump_err_data[14][1];memcpy(&can_T1XX_HwTqArbn_HwTqChB_fp, swap,4);
            itemN_15:   swap[0]=can1_dump_err_data[15][4];swap[1]=can1_dump_err_data[15][3];swap[2]=can1_dump_err_data[15][2];swap[3]=can1_dump_err_data[15][1];memcpy(&can_T1XX_MotAgCmp_fp, swap,4);
            itemN_16:   swap[0]=can1_dump_err_data[16][4];swap[1]=can1_dump_err_data[16][3];swap[2]=can1_dump_err_data[16][2];swap[3]=can1_dump_err_data[16][1];memcpy(&can_T1XX_BattVltg_fp, swap,4);
            itemN_17:   swap[0]=can1_dump_err_data[17][4];swap[1]=can1_dump_err_data[17][3];swap[2]=can1_dump_err_data[17][2];swap[3]=can1_dump_err_data[17][1];memcpy(&can_T1XX_BattVltgSwd1_fp, swap,4);
            itemN_18:   swap[0]=can1_dump_err_data[18][4];swap[1]=can1_dump_err_data[18][3];swap[2]=can1_dump_err_data[18][2];swap[3]=can1_dump_err_data[18][1];memcpy(&can_T1XX_BattVltgSwd2_fp, swap,4);
            itemN_19:   swap[0]=can1_dump_err_data[19][4];swap[1]=can1_dump_err_data[19][3];swap[2]=can1_dump_err_data[19][2];swap[3]=can1_dump_err_data[19][1];memcpy(&can_T1XX_BrdgVltg_fp, swap,4);
            itemN_20:   swap[0]=can1_dump_err_data[20][4];swap[1]=can1_dump_err_data[20][3];swap[2]=can1_dump_err_data[20][2];swap[3]=can1_dump_err_data[20][1];memcpy(&can_T1XX_AssiCmdBas_fp, swap,4);
            itemN_21:   swap[0]=can1_dump_err_data[21][4];swap[1]=can1_dump_err_data[21][3];swap[2]=can1_dump_err_data[21][2];swap[3]=can1_dump_err_data[21][1];memcpy(&can_T1XX_MotTqCmd_fp, swap,4);
            itemN_22:   swap[0]=can1_dump_err_data[22][4];swap[1]=can1_dump_err_data[22][3];swap[2]=can1_dump_err_data[22][2];swap[3]=can1_dump_err_data[22][1];memcpy(&can_T1XX_AssiMechT_fp, swap,4);
            itemN_23:   swap[0]=can1_dump_err_data[23][4];swap[1]=can1_dump_err_data[23][3];swap[2]=can1_dump_err_data[23][2];swap[3]=can1_dump_err_data[23][1];memcpy(&can_T1XX_MotFetT_fp, swap,4);
            itemN_24:   swap[0]=can1_dump_err_data[24][4];swap[1]=can1_dump_err_data[24][3];swap[2]=can1_dump_err_data[24][2];swap[3]=can1_dump_err_data[24][1];memcpy(&can_T1XX_MotMagT_fp, swap,4);
            itemN_25:   swap[0]=can1_dump_err_data[25][4];swap[1]=can1_dump_err_data[25][3];swap[2]=can1_dump_err_data[25][2];swap[3]=can1_dump_err_data[25][1];memcpy(&can_T1XX_MotWidgT_fp, swap,4);
            itemN_26:   swap[0]=can1_dump_err_data[26][4];swap[1]=can1_dump_err_data[26][3];swap[2]=can1_dump_err_data[26][2];swap[3]=can1_dump_err_data[26][1];memcpy(&can_T1XX_MotREstim_fp, swap,4);
            itemN_27:   swap[0]=can1_dump_err_data[27][4];swap[1]=can1_dump_err_data[27][3];swap[2]=can1_dump_err_data[27][2];swap[3]=can1_dump_err_data[27][1];memcpy(&can_T1XX_MotTq_fp, swap,4);

            itemN_2000: swap[0]=can1_dump_err_data[28][4];swap[1]=can1_dump_err_data[28][3];swap[2]=can1_dump_err_data[28][2];swap[3]=can1_dump_err_data[28][1];memcpy(&can_T1XX_MotCurrQax1_fp, swap,4);
            itemN_2001: swap[0]=can1_dump_err_data[29][4];swap[1]=can1_dump_err_data[29][3];swap[2]=can1_dump_err_data[29][2];swap[3]=can1_dump_err_data[29][1];memcpy(&can_T1XX_HwTqArbn_HwTq1_fp, swap,4);
            itemN_2010: swap[0]=can1_dump_err_data[30][4];swap[1]=can1_dump_err_data[30][3];swap[2]=can1_dump_err_data[30][2];swap[3]=can1_dump_err_data[30][1];memcpy(&can_T1XX_MotCurrQax2_fp, swap,4);
            itemN_2011: swap[0]=can1_dump_err_data[31][4];swap[1]=can1_dump_err_data[31][3];swap[2]=can1_dump_err_data[31][2];swap[3]=can1_dump_err_data[31][1];memcpy(&can_T1XX_HwTqArbn_HwTq2_fp, swap,4);
            itemN_2020: swap[0]=can1_dump_err_data[32][4];swap[1]=can1_dump_err_data[32][3];swap[2]=can1_dump_err_data[32][2];swap[3]=can1_dump_err_data[32][1];memcpy(&can_T1XX_MotCurrQax3_fp, swap,4);
            itemN_2021: swap[0]=can1_dump_err_data[33][4];swap[1]=can1_dump_err_data[33][3];swap[2]=can1_dump_err_data[33][2];swap[3]=can1_dump_err_data[33][1];memcpy(&can_T1XX_HwTqArbn_HwTq3_fp, swap,4);

        break;  // end case TARGET_T1XX:

        case TARGET_GWM_A0607:
        //      changed order for little Eindian RenSys processor, resulting in memcpy directly into floating point variable, which allows dumperr string to output true floats  ex: "12.47" (new style)
            itemR_1:    can_GWM_A0607_SystemState_byt = can1_dump_err_data[1][1];
            itemR_2:    swap[0]= can1_dump_err_data[2][4];swap[1]= can1_dump_err_data[2][3];swap[2]= can1_dump_err_data[2][2];swap[3]= can1_dump_err_data[2][1];memcpy(&can_GWM_A0607_MotCurrQax_fp, swap,4);
            itemR_3:    swap[0]= can1_dump_err_data[3][4];swap[1]= can1_dump_err_data[3][3];swap[2]= can1_dump_err_data[3][2];swap[3]= can1_dump_err_data[3][1];memcpy(&can_GWM_A0607_HwTq0Meas_HwTq4_fp, swap,4);
            itemR_4:    swap[0]= can1_dump_err_data[4][4];swap[1]= can1_dump_err_data[4][3];swap[2]= can1_dump_err_data[4][2];swap[3]= can1_dump_err_data[4][1];memcpy(&can_GWM_A0607_HwTq1Meas_HwTq5_fp, swap,4);
            itemR_5:    swap[0]= can1_dump_err_data[5][4];swap[1]= can1_dump_err_data[5][3];swap[2]= can1_dump_err_data[5][2];swap[3]= can1_dump_err_data[5][1];memcpy(&can_GWM_A0607_MotHwPosn_fp, swap,4);
            itemR_6:    swap[0]= can1_dump_err_data[6][4];swap[1]= can1_dump_err_data[6][3];swap[2]= can1_dump_err_data[6][2];swap[3]= can1_dump_err_data[6][1];memcpy(&can_GWM_A0607_BattVltg_fp, swap,4);
            itemR_7:    swap[0]= can1_dump_err_data[7][4];swap[1]= can1_dump_err_data[7][3];swap[2]= can1_dump_err_data[7][2];swap[3]= can1_dump_err_data[7][1];memcpy(&can_GWM_A0607_MotTq_fp, swap,4);
            itemR_8:    swap[0]= can1_dump_err_data[8][4];swap[1]= can1_dump_err_data[8][3];swap[2]= can1_dump_err_data[8][2];swap[3]= can1_dump_err_data[8][1];memcpy(&can_GWM_A0607_HwTrq_fp, swap,4);
            itemR_9:    swap[0]= can1_dump_err_data[9][4];swap[1]= can1_dump_err_data[9][3];swap[2]= can1_dump_err_data[9][2];swap[3]= can1_dump_err_data[9][1];memcpy(&can_GWM_A0607_MotMagTestim_fp, swap,4);
            itemR_10:   swap[0]= can1_dump_err_data[10][4];swap[1]= can1_dump_err_data[10][3];swap[2]= can1_dump_err_data[10][2];swap[3]= can1_dump_err_data[10][1];memcpy(&can_GWM_A0607_ECUTFilt_fp, swap,4);

/*          itemR_2000: swap[0]=can1_dump_err_data[11][4];swap[1]=can1_dump_err_data[28][3];swap[2]=can1_dump_err_data[11][2];swap[3]=can1_dump_err_data[11][1];memcpy(&can_BYD_SA2FL_MotCurrQax1_fp, swap,4);
            itemR_2001: swap[0]=can1_dump_err_data[12][4];swap[1]=can1_dump_err_data[29][3];swap[2]=can1_dump_err_data[12][2];swap[3]=can1_dump_err_data[12][1];memcpy(&can_BYD_SA2FL_HwTqArbn_HwTq1_fp, swap,4);
            itemR_2010: swap[0]=can1_dump_err_data[13][4];swap[1]=can1_dump_err_data[30][3];swap[2]=can1_dump_err_data[13][2];swap[3]=can1_dump_err_data[13][1];memcpy(&can_BYD_SA2FL_MotCurrQax2_fp, swap,4);
            itemR_2011: swap[0]=can1_dump_err_data[14][4];swap[1]=can1_dump_err_data[31][3];swap[2]=can1_dump_err_data[14][2];swap[3]=can1_dump_err_data[14][1];memcpy(&can_BYD_SA2FL_HwTqArbn_HwTq2_fp, swap,4);
            itemR_2020: swap[0]=can1_dump_err_data[15][4];swap[1]=can1_dump_err_data[32][3];swap[2]=can1_dump_err_data[15][2];swap[3]=can1_dump_err_data[15][1];memcpy(&can_BYD_SA2FL_MotCurrQax3_fp, swap,4);
            itemR_2021: swap[0]=can1_dump_err_data[16][4];swap[1]=can1_dump_err_data[33][3];swap[2]=can1_dump_err_data[16][2];swap[3]=can1_dump_err_data[16][1];memcpy(&can_BYD_SA2FL_HwTqArbn_HwTq3_fp, swap,4);
*/
            itemR_2000: swap[0]=can1_dump_err_data[11][4];swap[1]=can1_dump_err_data[11][3];swap[2]=can1_dump_err_data[11][2];swap[3]=can1_dump_err_data[11][1];memcpy(&can_GWM_A0607_MotCurrQax1_fp, swap,4);
            itemR_2001: swap[0]=can1_dump_err_data[12][4];swap[1]=can1_dump_err_data[12][3];swap[2]=can1_dump_err_data[12][2];swap[3]=can1_dump_err_data[12][1];memcpy(&can_GWM_A0607_HwTqArbn_HwTq1_fp, swap,4);
            itemR_2010: swap[0]=can1_dump_err_data[13][4];swap[1]=can1_dump_err_data[13][3];swap[2]=can1_dump_err_data[13][2];swap[3]=can1_dump_err_data[13][1];memcpy(&can_GWM_A0607_MotCurrQax2_fp, swap,4);
            itemR_2011: swap[0]=can1_dump_err_data[14][4];swap[1]=can1_dump_err_data[14][3];swap[2]=can1_dump_err_data[14][2];swap[3]=can1_dump_err_data[14][1];memcpy(&can_GWM_A0607_HwTqArbn_HwTq2_fp, swap,4);
            itemR_2020: swap[0]=can1_dump_err_data[15][4];swap[1]=can1_dump_err_data[15][3];swap[2]=can1_dump_err_data[15][2];swap[3]=can1_dump_err_data[15][1];memcpy(&can_GWM_A0607_MotCurrQax3_fp, swap,4);
            itemR_2021: swap[0]=can1_dump_err_data[16][4];swap[1]=can1_dump_err_data[16][3];swap[2]=can1_dump_err_data[16][2];swap[3]=can1_dump_err_data[16][1];memcpy(&can_GWM_A0607_HwTqArbn_HwTq3_fp, swap,4);


        break;  // end case TARGET_GWM_A0607:

        case TARGET_FORD_T3_T6:
            itemO_1:   swap[0]=can1_dump_err_data[1][4];swap[1]=can1_dump_err_data[1][3];swap[2]=can1_dump_err_data[1][2];swap[3]=can1_dump_err_data[1][1];memcpy(&can1_FORD_T3_ECU1_BattVltg_fp, swap,4);
            itemO_2:   swap[0]=can1_dump_err_data[2][4];swap[1]=can1_dump_err_data[2][3];swap[2]=can1_dump_err_data[2][2];swap[3]=can1_dump_err_data[2][1];memcpy(&can1_FORD_T3_ECU1_Temperature_fp, swap,4);
            itemO_3:   swap[0]=can1_dump_err_data[3][4];swap[1]=can1_dump_err_data[3][3];swap[2]=can1_dump_err_data[3][2];swap[3]=can1_dump_err_data[3][1];memcpy(&can1_FORD_T3_ECU1_DigT1_fp, swap,4);
            itemO_4:   swap[0]=can1_dump_err_data[4][4];swap[1]=can1_dump_err_data[4][3];swap[2]=can1_dump_err_data[4][2];swap[3]=can1_dump_err_data[4][1];memcpy(&can1_FORD_T3_ECU1_DigT2_fp, swap,4);
            itemO_5:   swap[0]=can1_dump_err_data[5][4];swap[1]=can1_dump_err_data[5][3];swap[2]=can1_dump_err_data[5][2];swap[3]=can1_dump_err_data[5][1];memcpy(&can1_FORD_T3_ECU1_MtrCurrQax_fp, swap,4);
            itemO_6:   can1_FORD_T3_ECU1_SystemState_byt = can1_dump_err_data[6][1];
            itemO_7:   swap[0]=can1_dump_err_data[7][4];swap[1]=can1_dump_err_data[7][3];swap[2]=can1_dump_err_data[7][2];swap[3]=can1_dump_err_data[7][1];memcpy(&can1_FORD_T3_ECU1_HwTrq_HwNm_fp, swap,4);
            itemO_8:   swap[0]=can1_dump_err_data[8][4];swap[1]=can1_dump_err_data[8][3];swap[2]=can1_dump_err_data[8][2];swap[3]=can1_dump_err_data[8][1];memcpy(&can1_FORD_T3_ECU1_Abs_Hw_Pos_fp, swap,4);

            if(FORD_hcurr_low_value_is_set  == TRUE)
            {
                itemO_2000: swap[0]=can1_dump_err_data[9][4];swap[1]=can1_dump_err_data[9][3];swap[2]=can1_dump_err_data[9][2];swap[3]=can1_dump_err_data[9][1];memcpy(&can1_FORD_T3_ECU1_MtrCurrQax1_fp, swap,4);
                itemO_2001: swap[0]=can1_dump_err_data[10][4];swap[1]=can1_dump_err_data[10][3];swap[2]=can1_dump_err_data[10][2];swap[3]=can1_dump_err_data[10][1];memcpy(&can1_FORD_T3_ECU1_HwTrq_HwNm1_fp, swap,4);
            }
            if(FORD_hcurr_med_value_is_set  == TRUE)
            {
                itemO_2010: swap[0]=can1_dump_err_data[11][4];swap[1]=can1_dump_err_data[11][3];swap[2]=can1_dump_err_data[11][2];swap[3]=can1_dump_err_data[11][1];memcpy(&can1_FORD_T3_ECU1_MtrCurrQax2_fp, swap,4);
                itemO_2011: swap[0]=can1_dump_err_data[12][4];swap[1]=can1_dump_err_data[12][3];swap[2]=can1_dump_err_data[12][2];swap[3]=can1_dump_err_data[12][1];memcpy(&can1_FORD_T3_ECU1_HwTrq_HwNm2_fp, swap,4);
            }
            if(FORD_hcurr_high_value_is_set  == TRUE)
            {
                itemO_2020: swap[0]=can1_dump_err_data[13][4];swap[1]=can1_dump_err_data[13][3];swap[2]=can1_dump_err_data[13][2];swap[3]=can1_dump_err_data[13][1];memcpy(&can1_FORD_T3_ECU1_MtrCurrQax3_fp, swap,4);
                itemO_2021: swap[0]=can1_dump_err_data[14][4];swap[1]=can1_dump_err_data[14][3];swap[2]=can1_dump_err_data[14][2];swap[3]=can1_dump_err_data[14][1];memcpy(&can1_FORD_T3_ECU1_HwTrq_HwNm3_fp, swap,4);
            }

        break;  //  end case TARGET_FORD_T3_T6:

        case TARGET_RENAULT_NISSAN:
            itemP_1:   swap[0]=can1_dump_err_data[1][4];swap[1]=can1_dump_err_data[1][3];swap[2]=can1_dump_err_data[1][2];swap[3]=can1_dump_err_data[1][1];memcpy(&can1_RENAULT_NISSAN_BattVltg_fp, swap,4);
            itemP_2:   swap[0]=can1_dump_err_data[2][4];swap[1]=can1_dump_err_data[2][3];swap[2]=can1_dump_err_data[2][2];swap[3]=can1_dump_err_data[2][1];memcpy(&can1_RENAULT_NISSAN_Temperature_fp, swap,4);
            itemP_3:   swap[0]=can1_dump_err_data[3][4];swap[1]=can1_dump_err_data[3][3];swap[2]=can1_dump_err_data[3][2];swap[3]=can1_dump_err_data[3][1];memcpy(&can1_RENAULT_NISSAN_DigT1_HwNm_fp, swap,4);
            itemP_4:   swap[0]=can1_dump_err_data[4][4];swap[1]=can1_dump_err_data[4][3];swap[2]=can1_dump_err_data[4][2];swap[3]=can1_dump_err_data[4][1];memcpy(&can1_RENAULT_NISSAN_DigT2_HwNm_fp, swap,4);
            itemP_5:   swap[0]=can1_dump_err_data[5][4];swap[1]=can1_dump_err_data[5][3];swap[2]=can1_dump_err_data[5][2];swap[3]=can1_dump_err_data[5][1];memcpy(&can1_RENAULT_NISSAN_MtrCurrQax_fp, swap,4);
            itemP_6:   can1_RENAULT_NISSAN_SystemState_byt = can1_dump_err_data[6][1];
            itemP_7:   swap[0]=can1_dump_err_data[7][4];swap[1]=can1_dump_err_data[7][3];swap[2]=can1_dump_err_data[7][2];swap[3]=can1_dump_err_data[7][1];memcpy(&can1_RENAULT_NISSAN_HwTrq_HwNm_fp, swap,4);
            itemP_8:   swap[0]=can1_dump_err_data[8][4];swap[1]=can1_dump_err_data[8][3];swap[2]=can1_dump_err_data[8][2];swap[3]=can1_dump_err_data[8][1];memcpy(&can1_RENAULT_NISSAN_Abs_Hw_Pos_fp, swap,4);
            itemP_9:   swap[0]=can1_dump_err_data[9][4];swap[1]=can1_dump_err_data[9][3];swap[2]=can1_dump_err_data[9][2];swap[3]=can1_dump_err_data[9][1];memcpy(&can1_RENAULT_NISSAN_MotTrq_Crf_fp, swap,4);
            itemP_10:  swap[0]=can1_dump_err_data[10][4];swap[1]=can1_dump_err_data[10][3];swap[2]=can1_dump_err_data[10][2];swap[3]=can1_dump_err_data[10][1];memcpy(&can1_RENAULT_NISSAN_MotTrq_Mrf_fp, swap,4);
            itemP_11:  swap[0]=can1_dump_err_data[11][4];swap[1]=can1_dump_err_data[11][3];swap[2]=can1_dump_err_data[11][2];swap[3]=can1_dump_err_data[11][1];memcpy(&can1_RENAULT_NISSAN_VehSpd_fp, swap,4);
            itemP_12:  swap[0]=can1_dump_err_data[12][4];swap[1]=can1_dump_err_data[12][3];swap[2]=can1_dump_err_data[12][2];swap[3]=can1_dump_err_data[12][1];memcpy(&can1_RENAULT_NISSAN_Spare2_fp, swap,4);


            itemP_2000:  swap[0]=can1_dump_err_data[13][4];swap[1]=can1_dump_err_data[13][3];swap[2]=can1_dump_err_data[13][2];swap[3]=can1_dump_err_data[13][1];memcpy(&can1_RENAULT_NISSAN_MtrCurrQax1_fp, swap,4);
            itemP_2001:  swap[0]=can1_dump_err_data[14][4];swap[1]=can1_dump_err_data[14][3];swap[2]=can1_dump_err_data[14][2];swap[3]=can1_dump_err_data[14][1];memcpy(&can1_RENAULT_NISSAN_HwTrq_HwNm1_fp, swap,4);
            itemP_2010:  swap[0]=can1_dump_err_data[15][4];swap[1]=can1_dump_err_data[15][3];swap[2]=can1_dump_err_data[15][2];swap[3]=can1_dump_err_data[15][1];memcpy(&can1_RENAULT_NISSAN_MtrCurrQax2_fp, swap,4);
            itemP_2011:  swap[0]=can1_dump_err_data[16][4];swap[1]=can1_dump_err_data[16][3];swap[2]=can1_dump_err_data[16][2];swap[3]=can1_dump_err_data[16][1];memcpy(&can1_RENAULT_NISSAN_HwTrq_HwNm2_fp, swap,4);
            itemP_2020:  swap[0]=can1_dump_err_data[17][4];swap[1]=can1_dump_err_data[17][3];swap[2]=can1_dump_err_data[17][2];swap[3]=can1_dump_err_data[17][1];memcpy(&can1_RENAULT_NISSAN_MtrCurrQax3_fp, swap,4);
            itemP_2021:  swap[0]=can1_dump_err_data[18][4];swap[1]=can1_dump_err_data[18][3];swap[2]=can1_dump_err_data[18][2];swap[3]=can1_dump_err_data[18][1];memcpy(&can1_RENAULT_NISSAN_HwTrq_HwNm3_fp, swap,4);

        break;  //  end case TARGET_SGMW_RENAULT_NISSAN:

        case TARGET_BMW_FAAR_WE:

            itemQ_1:  fray1_FAAR_WE_SysStMod_byt = fray_dump_err_data[1][3];
            itemQ_2:  memcpy(&fray1_FAAR_WE_BattVltg_BrdgVltg_fp, &fray_dump_err_data[2][0],4);
            ItemQ_3:  memcpy(&fray1_FAAR_WE_BattRtnCurrAmpr_fp, &fray_dump_err_data[3][0],4);
            ItemQ_4:  memcpy(&fray1_FAAR_WE_HwAgArbn_fp, &fray_dump_err_data[4][0],4);
            ItemQ_5:  memcpy(&fray1_FAAR_WE_HwTq4Meas_fp, &fray_dump_err_data[5][0],4);
            ItemQ_6:  memcpy(&fray1_FAAR_WE_HwTq5Meas_fp, &fray_dump_err_data[6][0],4);
            ItemQ_7:  memcpy(&fray1_FAAR_WE_HwTqArbn_fp, &fray_dump_err_data[7][0],4);
            ItemQ_8:  memcpy(&fray1_FAAR_WE_MotCurrSumA_fp, &fray_dump_err_data[8][0],4);
            ItemQ_9:  memcpy(&fray1_FAAR_WE_MotCurrSumB_fp, &fray_dump_err_data[9][0],4);
            ItemQ_10: memcpy(&fray1_FAAR_WE_MotCurrSumC_fp, &fray_dump_err_data[10][0],4);
            ItemQ_11: memcpy(&fray1_FAAR_WE_MotVelCrf_fp, &fray_dump_err_data[11][0],4);
            ItemQ_12: memcpy(&fray1_FAAR_WE_MotTqCmd_fp, &fray_dump_err_data[12][0],4);
            ItemQ_13: memcpy(&fray1_FAAR_WE_MotTqEstimd_fp, &fray_dump_err_data[13][0],4);
            ItemQ_14: memcpy(&fray1_FAAR_WE_LoaSca_fp, &fray_dump_err_data[14][0],4);
            ItemQ_15: memcpy(&fray1_FAAR_WE_EcuTMeas_fp, &fray_dump_err_data[15][0],4);
            ItemQ_16: memcpy(&fray1_FAAR_WE_MotWidgT_fp, &fray_dump_err_data[16][0],4);
            ItemQ_17: memcpy(&fray1_FAAR_WE_MotMagT_fp, &fray_dump_err_data[17][0],4);
            ItemQ_18: memcpy(&fray1_FAAR_WE_MotFetT_fp, &fray_dump_err_data[18][0],4);


//            itemQ_1:  fray1_FAAR_WE_SysStMod_byt = fray_dump_err_data[1][3];
//            itemQ_2:  swap[0]= fray_dump_err_data[2][3];swap[1]= fray_dump_err_data[2][2];swap[2]= fray_dump_err_data[2][1];swap[3]= fray_dump_err_data[2][0];memcpy(&fray1_FAAR_WE_BattVltg_BrdgVltg_fp, &swap,4);
//            ItemQ_3:  swap[0]= fray_dump_err_data[3][3];swap[1]= fray_dump_err_data[3][2];swap[2]= fray_dump_err_data[3][1];swap[3]= fray_dump_err_data[3][0];memcpy(&fray1_FAAR_WE_BattRtnCurrAmpr_fp, &swap,4);
//            ItemQ_4:  swap[0]= fray_dump_err_data[4][3];swap[1]= fray_dump_err_data[4][2];swap[2]= fray_dump_err_data[4][1];swap[3]= fray_dump_err_data[4][0];memcpy(&fray1_FAAR_WE_HwAgArbn_fp, &swap,4);
//            ItemQ_5:  swap[0]= fray_dump_err_data[5][3];swap[1]= fray_dump_err_data[5][2];swap[2]= fray_dump_err_data[5][1];swap[3]= fray_dump_err_data[5][0]; memcpy(&fray1_FAAR_WE_HwTq4Meas_fp, &swap,4);
//            ItemQ_6:  swap[0]= fray_dump_err_data[6][3];swap[1]= fray_dump_err_data[6][2];swap[2]= fray_dump_err_data[6][1];swap[3]= fray_dump_err_data[6][0];memcpy(&fray1_FAAR_WE_HwTq5Meas_fp, &swap,4);
//            ItemQ_7:  swap[0]= fray_dump_err_data[7][3];swap[1]= fray_dump_err_data[7][2];swap[2]= fray_dump_err_data[7][1];swap[3]= fray_dump_err_data[7][0];memcpy(&fray1_FAAR_WE_HwTqArbn_fp, &swap,4);
//            ItemQ_8:  swap[0]= fray_dump_err_data[8][3];swap[1]= fray_dump_err_data[8][2];swap[2]= fray_dump_err_data[8][1];swap[3]= fray_dump_err_data[8][0];memcpy(&fray1_FAAR_WE_MotCurrSumA_fp, &swap,4);
//            ItemQ_9:  swap[0]= fray_dump_err_data[9][3];swap[1]= fray_dump_err_data[9][2];swap[2]= fray_dump_err_data[9][1];swap[3]= fray_dump_err_data[9][0];memcpy(&fray1_FAAR_WE_MotCurrSumB_fp, &swap,4);
//            ItemQ_10: swap[0]= fray_dump_err_data[10][3];swap[1]= fray_dump_err_data[10][2];swap[2]= fray_dump_err_data[10][1];swap[3]= fray_dump_err_data[10][0];memcpy(&fray1_FAAR_WE_MotCurrSumC_fp, &swap,4);
//            ItemQ_11: swap[0]= fray_dump_err_data[11][3];swap[1]= fray_dump_err_data[11][2];swap[2]= fray_dump_err_data[11][1];swap[3]= fray_dump_err_data[11][0];memcpy(&fray1_FAAR_WE_MotVelCrf_fp, &swap,4);
//            ItemQ_12: swap[0]= fray_dump_err_data[12][3];swap[1]= fray_dump_err_data[12][2];swap[2]= fray_dump_err_data[12][1];swap[3]= fray_dump_err_data[12][0];memcpy(&fray1_FAAR_WE_MotTqCmd_fp, &swap,4);
//            ItemQ_13: swap[0]= fray_dump_err_data[13][3];swap[1]= fray_dump_err_data[13][2];swap[2]= fray_dump_err_data[13][1];swap[3]= fray_dump_err_data[13][0];memcpy(&fray1_FAAR_WE_MotTqEstimd_fp, &swap,4);
//            ItemQ_14: swap[0]= fray_dump_err_data[14][3];swap[1]= fray_dump_err_data[14][2];swap[2]= fray_dump_err_data[14][1];swap[3]= fray_dump_err_data[14][0];memcpy(&fray1_FAAR_WE_LoaSca_fp, &swap,4);
//            ItemQ_15: swap[0]= fray_dump_err_data[15][3];swap[1]= fray_dump_err_data[15][2];swap[2]= fray_dump_err_data[15][1];swap[3]= fray_dump_err_data[15][0];memcpy(&fray1_FAAR_WE_EcuTMeas_fp, &swap,4);
//            ItemQ_16: swap[0]= fray_dump_err_data[16][3];swap[1]= fray_dump_err_data[16][2];swap[2]= fray_dump_err_data[16][1];swap[3]= fray_dump_err_data[16][0];memcpy(&fray1_FAAR_WE_MotWidgT_fp, &swap,4);
//            ItemQ_17: swap[0]= fray_dump_err_data[17][3];swap[1]= fray_dump_err_data[17][2];swap[2]= fray_dump_err_data[17][1];swap[3]= fray_dump_err_data[17][0];memcpy(&fray1_FAAR_WE_MotMagT_fp, &swap,4);
//            ItemQ_18: swap[0]= fray_dump_err_data[18][3];swap[1]= fray_dump_err_data[18][2];swap[2]= fray_dump_err_data[18][1];swap[3]= fray_dump_err_data[18][0];memcpy(&fray1_FAAR_WE_MotFetT_fp, &swap,4);

              //          ItemK_19: swap[0]= fray_dump_err_data[19][3];swap[1]= fray_dump_err_data[19][2];swap[2]= fray_dump_err_data[19][1];swap[3]= fray_dump_err_data[19][0];memcpy(&fray_FAAR_WE_MotTq_fp, &swap,4);

            break;      //  end case TARGET_BMW_FAAR_WE:

        }

        break;  // end case RENSIS:
    }

}


void parse_can2_data(void)
{
    // OR  ECU2
    // itemxx: is a lable.  Not used by program. Just a easy way for you to associate where data came from.
    //      Number is canMessageNotification (case CCP_RESPONSE_ID:) switch(can1_request_index), index value at the point of message reception.
    //      So, I sent a CAN CCP request, got a CAN Response, stored it, memcpy(&can1_dump_err_data[1],&can1_rx_data,8); and here, process it.

    switch (processor_type)
    {
    case TMS570:
        switch (target_product)
        {

        case TARGET_CD391_ADAS:
            itemAA_1:   memcpy(&can2_FORD_BattVltg_fp,&can2_dump_err_data[1][1],4);
            itemAA_2:   memcpy(&can2_FORD_Temperature_fp,&can2_dump_err_data[2][1],4);
            itemAA_3:   memcpy(&can2_FORD_DigT1_fp,&can2_dump_err_data[3][1],4);
            itemAA_4:   memcpy(&can2_FORD_DigT2_fp,&can2_dump_err_data[4][1],4);
            itemAA_5:   memcpy(&can2_FORD_MtrCurrQax_fp,&can2_dump_err_data[5][1],4);
            itemAA_6:   can2_FORD_SystemState_byt = can2_dump_err_data[6][1];
            itemAA_7:   memcpy(&can2_FORD_HwTrq_HwNm_fp,&can2_dump_err_data[7][1],4);
            itemAA_8:   memcpy(&can2_FORD_Abs_Hw_Pos_fp,&can2_dump_err_data[8][1],4);
            itemAA_9:   memcpy(&can2_FORD_Batt_Current_fp,&can2_dump_err_data[9][1],4);
            itemAA_10:   can2_FORD_LatchFail_ISR_u16 = can2_dump_err_data[10][2];
            itemAA_11:   can2_FORD_MtrCntl_ISR_u16  = can2_dump_err_data[11][2];
            itemAA_12:   can2_FORD_MinCount_u32 = can2_dump_err_data[12][4];
            itemAA_13:   can2_FORD_MaxCount_u32 = can2_dump_err_data[13][4];
            itemAA_14:   can2_FORD_CatGate_cnt = can2_dump_err_data[14][4];

            itemAA_2000:    memcpy(&can2_FORD_MtrCurrQax1_fp,&can2_dump_err_data[15][1],4);
            itemAA_2001:    memcpy(&can2_FORD_HwTrq_HwNm1_fp,&can2_dump_err_data[16][1],4);
            itemAA_2010:    memcpy(&can2_FORD_MtrCurrQax2_fp,&can2_dump_err_data[17][1],4);
            itemAA_2011:    memcpy(&can2_FORD_HwTrq_HwNm2_fp,&can2_dump_err_data[18][1],4);
            itemAA_2020:    memcpy(&can2_FORD_MtrCurrQax3_fp,&can2_dump_err_data[19][1],4);
            itemAA_2021:    memcpy(&can2_FORD_HwTrq_HwNm3_fp,&can2_dump_err_data[20][1],4);

        break;  //  end case TARGET_CD391_ADAS:

        case TARGET_FCA_ADAS:
            itemBB_1:   memcpy(&can2_FCA_BattVltg_fp,&can2_dump_err_data[1][1],4);
            itemBB_2:   memcpy(&can2_FCA_Temperature_fp,&can2_dump_err_data[2][1],4);
            itemBB_3:   memcpy(&can2_FCA_DigT1_fp,&can2_dump_err_data[3][1],4);
            itemBB_4:   memcpy(&can2_FCA_DigT2_fp,&can2_dump_err_data[4][1],4);
            itemBB_5:   memcpy(&can2_FCA_MtrCurrQax_fp,&can2_dump_err_data[5][1],4);
            itemBB_6:   can2_FCA_SystemState_byt = can2_dump_err_data[6][1];
            itemBB_7:   memcpy(&can2_FCA_HwTrq_HwNm_fp,&can2_dump_err_data[7][1],4);
            itemBB_8:   memcpy(&can2_FCA_Abs_Hw_Pos_fp,&can2_dump_err_data[8][1],4);

            itemBB_2000:    memcpy(&can2_FCA_MtrCurrQax1_fp,&can2_dump_err_data[9][1],4);
            itemBB_2001:    memcpy(&can2_FCA_HwTrq_HwNm1_fp,&can2_dump_err_data[10][1],4);
            itemBB_2010:    memcpy(&can2_FCA_MtrCurrQax2_fp,&can2_dump_err_data[11][1],4);
            itemBB_2011:    memcpy(&can2_FCA_HwTrq_HwNm2_fp,&can2_dump_err_data[12][1],4);
            itemBB_2020:    memcpy(&can2_FCA_MtrCurrQax3_fp,&can2_dump_err_data[13][1],4);
            itemBB_2021: memcpy(&can2_FCA_HwTrq_HwNm3_fp,&can2_dump_err_data[14][1],4);


        break;  //  end case TARGET_FCA_ADAS:

        case TARGET_9BXX:       // hex string for floating point representation "0x00 0x00 0x00 0x00"  (old style)

            break;  //  end case TARGET_9BXX:

        case TARGET_S550ANALOG:
            break;

        case TARGET_S550DIGITAL:
            break;

        case TARGET_C1XX:       // move Hex coded float, 4 bytes starting at [1], allows dumperr string to output true floats  ex: "12.47" (new style)

            break;  //  end case TARGET_C1XX:

        case TARGET_PSA_CMP:       // move Hex coded float, 4 bytes starting at [1], allows dumperr string to output true floats  ex: "12.47" (new style)

            break;  //  end case TARGET_PSA_CMP:

        }

        break;  // end case TMS570:

    case RENSIS:
        // eindian_swap[0] = can_test_string[4];eindian_swap[1] = can_test_string[3];eindian_swap[2] = can_test_string[2];eindian_swap[3] = can_test_string[1];
        // memcpy(&can_MotCurrQax_fp, eindian_swap,4);  // method1
        switch (target_product)
        {

        case TARGET_FORD_T3_T6:
            itemCC_1:   swap[0]=can2_dump_err_data[1][4];swap[1]=can2_dump_err_data[1][3];swap[2]=can2_dump_err_data[1][2];swap[3]=can2_dump_err_data[1][1];memcpy(&can1_FORD_T3_ECU2_BattVltg_fp, swap,4);
            itemCC_2:   swap[0]=can2_dump_err_data[2][4];swap[1]=can2_dump_err_data[2][3];swap[2]=can2_dump_err_data[2][2];swap[3]=can2_dump_err_data[2][1];memcpy(&can1_FORD_T3_ECU2_Temperature_fp, swap,4);
            itemCC_3:   swap[0]=can2_dump_err_data[3][4];swap[1]=can2_dump_err_data[3][3];swap[2]=can2_dump_err_data[3][2];swap[3]=can2_dump_err_data[3][1];memcpy(&can1_FORD_T3_ECU2_DigT1_fp, swap,4);
            itemCC_4:   swap[0]=can2_dump_err_data[4][4];swap[1]=can2_dump_err_data[4][3];swap[2]=can2_dump_err_data[4][2];swap[3]=can2_dump_err_data[4][1];memcpy(&can1_FORD_T3_ECU2_DigT2_fp, swap,4);
            itemCC_5:   swap[0]=can2_dump_err_data[5][4];swap[1]=can2_dump_err_data[5][3];swap[2]=can2_dump_err_data[5][2];swap[3]=can2_dump_err_data[5][1];memcpy(&can1_FORD_T3_ECU2_MtrCurrQax_fp, swap,4);
            itemCC_6:   can1_FORD_T3_ECU2_SystemState_byt = can2_dump_err_data[6][1];
            itemCC_7:   swap[0]=can2_dump_err_data[7][4];swap[1]=can2_dump_err_data[7][3];swap[2]=can2_dump_err_data[7][2];swap[3]=can2_dump_err_data[7][1];memcpy(&can1_FORD_T3_ECU2_HwTrq_HwNm_fp, swap,4);
            itemCC_8:   swap[0]=can2_dump_err_data[8][4];swap[1]=can2_dump_err_data[8][3];swap[2]=can2_dump_err_data[8][2];swap[3]=can2_dump_err_data[8][1];memcpy(&can1_FORD_T3_ECU2_Abs_Hw_Pos_fp, swap,4);

            if(FORD_hcurr_low_value_is_set  == TRUE)
            {
                itemCC_2000: swap[0]=can2_dump_err_data[9][4];swap[1]=can2_dump_err_data[9][3];swap[2]=can2_dump_err_data[9][2];swap[3]=can2_dump_err_data[9][1];memcpy(&can1_FORD_T3_ECU2_MtrCurrQax1_fp, swap,4);
                itemCC_2001: swap[0]=can2_dump_err_data[10][4];swap[1]=can2_dump_err_data[10][3];swap[2]=can2_dump_err_data[10][2];swap[3]=can2_dump_err_data[10][1];memcpy(&can1_FORD_T3_ECU2_HwTrq_HwNm1_fp, swap,4);
            }

            if(FORD_hcurr_med_value_is_set  == TRUE)
            {
                itemCC_2010: swap[0]=can2_dump_err_data[11][4];swap[1]=can2_dump_err_data[11][3];swap[2]=can2_dump_err_data[11][2];swap[3]=can2_dump_err_data[11][1];memcpy(&can1_FORD_T3_ECU2_MtrCurrQax2_fp, swap,4);
                itemCC_2011: swap[0]=can2_dump_err_data[12][4];swap[1]=can2_dump_err_data[12][3];swap[2]=can2_dump_err_data[12][2];swap[3]=can2_dump_err_data[12][1];memcpy(&can1_FORD_T3_ECU2_HwTrq_HwNm2_fp, swap,4);
            }

            if(FORD_hcurr_high_value_is_set  == TRUE)
            {
                itemCC_2020: swap[0]=can2_dump_err_data[13][4];swap[1]=can2_dump_err_data[13][3];swap[2]=can2_dump_err_data[13][2];swap[3]=can2_dump_err_data[13][1];memcpy(&can1_FORD_T3_ECU2_MtrCurrQax3_fp, swap,4);
                itemCC_2021: swap[0]=can2_dump_err_data[14][4];swap[1]=can2_dump_err_data[14][3];swap[2]=can2_dump_err_data[14][2];swap[3]=can2_dump_err_data[14][1];memcpy(&can1_FORD_T3_ECU2_HwTrq_HwNm3_fp, swap,4);
            }

        break;  //  end case TARGET_FORD_T3_T6:

        case TARGET_G2KCA_ADAS:
            itemDD_1:   swap[0]=can2_dump_err_data[1][4];swap[1]=can2_dump_err_data[1][3];swap[2]=can2_dump_err_data[1][2];swap[3]=can2_dump_err_data[1][1];memcpy(&can2_G2KCA_BattVltg_fp, swap,4);
            itemDD_2:   swap[0]=can2_dump_err_data[2][4];swap[1]=can2_dump_err_data[2][3];swap[2]=can2_dump_err_data[2][2];swap[3]=can2_dump_err_data[2][1];memcpy(&can2_G2KCA_Temperature_fp, swap,4);
            itemDD_3:   swap[0]=can2_dump_err_data[3][4];swap[1]=can2_dump_err_data[3][3];swap[2]=can2_dump_err_data[3][2];swap[3]=can2_dump_err_data[3][1];memcpy(&can2_G2KCA_DigT1_fp, swap,4);
            itemDD_4:   swap[0]=can2_dump_err_data[4][4];swap[1]=can2_dump_err_data[4][3];swap[2]=can2_dump_err_data[4][2];swap[3]=can2_dump_err_data[4][1];memcpy(&can2_G2KCA_DigT2_fp, swap,4);
            itemDD_5:   swap[0]=can2_dump_err_data[5][4];swap[1]=can2_dump_err_data[5][3];swap[2]=can2_dump_err_data[5][2];swap[3]=can2_dump_err_data[5][1];memcpy(&can2_G2KCA_MtrCurrQax_fp, swap,4);
            itemDD_6:   can2_G2KCA_SystemState_byt = can2_dump_err_data[6][1];
            itemDD_7:   swap[0]=can2_dump_err_data[7][4];swap[1]=can2_dump_err_data[7][3];swap[2]=can2_dump_err_data[7][2];swap[3]=can2_dump_err_data[7][1];memcpy(&can2_G2KCA_HwTrq_HwNm_fp, swap,4);
            itemDD_8:   swap[0]=can2_dump_err_data[8][4];swap[1]=can2_dump_err_data[8][3];swap[2]=can2_dump_err_data[8][2];swap[3]=can2_dump_err_data[8][1];memcpy(&can2_G2KCA_Abs_Hw_Pos_fp, swap,4);


            itemDD_2000:    swap[0]=can2_dump_err_data[9][4];swap[1]=can2_dump_err_data[9][3];swap[2]=can2_dump_err_data[9][2];swap[3]=can2_dump_err_data[9][1];memcpy(&can2_G2KCA_MtrCurrQax1_fp, swap,4);
            itemDD_2001:    swap[0]=can2_dump_err_data[10][4];swap[1]=can2_dump_err_data[10][3];swap[2]=can2_dump_err_data[10][2];swap[3]=can2_dump_err_data[10][1];memcpy(&can2_G2KCA_HwTrq_HwNm1_fp, swap,4);
            itemDD_2010:    swap[0]=can2_dump_err_data[11][4];swap[1]=can2_dump_err_data[11][3];swap[2]=can2_dump_err_data[11][2];swap[3]=can2_dump_err_data[11][1];memcpy(&can2_G2KCA_MtrCurrQax2_fp, swap,4);
            itemDD_2011:    swap[0]=can2_dump_err_data[12][4];swap[1]=can2_dump_err_data[12][3];swap[2]=can2_dump_err_data[12][2];swap[3]=can2_dump_err_data[12][1];memcpy(&can2_G2KCA_HwTrq_HwNm2_fp, swap,4);
            itemDD_2020:    swap[0]=can2_dump_err_data[13][4];swap[1]=can2_dump_err_data[13][3];swap[2]=can2_dump_err_data[13][2];swap[3]=can2_dump_err_data[13][1];memcpy(&can2_G2KCA_MtrCurrQax3_fp, swap,4);
            itemDD_2021: swap[0]=can2_dump_err_data[14][4];swap[1]=can2_dump_err_data[14][3];swap[2]=can2_dump_err_data[14][2];swap[3]=can2_dump_err_data[14][1];memcpy(&can2_G2KCA_HwTrq_HwNm3_fp, swap,4);

        break;  //  end case TARGET_G2KCA_ADAS:

        case TARGET_T1XX:
        //      changed order for little Eindian RenSys processor, resulting in memcpy directly into floating point variable, which allows dumperr string to output true floats  ex: "12.47" (new style)

        break;  // end case TARGET_T1XX:

        case TARGET_BYD_SA2FL:
        case TARGET_GWM_A0607:
        //      changed order for little Eindian RenSys processor, resulting in memcpy directly into floating point variable, which allows dumperr string to output true floats  ex: "12.47" (new style)

        break;  // end case TARGET_BYD_SA2FL:

        case TARGET_SGMW_CN200:       // move Hex coded float, 4 bytes starting at [1], allows dumperr string to output true floats  ex: "12.47" (new style)

        break;  //  end case TARGET_SGMW_CN200:

        case TARGET_RENAULT_NISSAN:       // move Hex coded float, 4 bytes starting at [1], allows dumperr string to output true floats  ex: "12.47" (new style)

        break;  //  end case TARGET_RENAULT_NISSAN:


        }

        break;  // end case RENSIS:
    }

}


void sent_data_calculation_from_table(short const t[8][5])

/*  Designed to take a CONST array pointer from main and translate to SENT signals  */

// declaration void sent_data_calculation_from_table(short *const table[][5]);
//void sent_data_calculation_from_table(const short t[][5])   //called by sent_data_calculation_from_table(xxx)
//void sent_data_calculation_from_table( t[][5])

{

    aa = t[1][0];   // debug to see if data is indexed into correctly as passed via function parameter
    bb = t[1][1];   // debug to see if data is indexed into correctly as passed via function parameter
    cc = t[1][2];   // debug to see if data is indexed into correctly as passed via function parameter
    dd = t[1][3];   // debug to see if data is indexed into correctly as passed via function parameter
    ee = t[1][4];   // debug to see if data is indexed into correctly as passed via function parameter

    // build dumperr vars,
    value_sent1_Adr0_ChA0_Pos_cnt   = (t[0][0] << 8) + (t[0][1] << 4) + t[0][2];    // sent1 value transmitted to product;
    value_sent2_Adr0_ChB0_Pos_cnt   = (t[1][0] << 8) + (t[1][1] << 4) + t[1][2];    // sent2 value transmitted to product;
    value_sent3_Adr1_ChA1_Pos_cnt   = (t[2][0] << 8) + (t[2][1] << 4) + t[2][2];    // sent1 value transmitted to product;
    value_sent4_Adr1_ChB1_Pos_cnt   = (t[3][0] << 8) + (t[3][1] << 4) + t[3][2];    // sent2 value transmitted to product;
    value_sent5_ChA_T1_cnt          = (t[4][0] << 8) + (t[4][1] << 4) + t[4][2];    // sent3 value transmitted to product;
    value_sent6_ChA_T2_cnt          = (t[5][0] << 8) + (t[5][1] << 4) + t[5][2];    // sent4 value transmitted to product;
    value_sent7_ChB_T1_cnt          = (t[6][0] << 8) + (t[6][1] << 4) + t[6][2];    // sent5 value transmitted to product;
    value_sent8_ChB_T2_cnt          = (t[7][0] << 8) + (t[7][1] << 4) + t[7][2];    // sent6 value transmitted to product;

/*  S E N T  - -  H A N D W H E E L */

    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  1  pre calc vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */

    sent_edge_event_time[0][6]  = sent_edge_event_time[0][5]  + t[0][0] + 8;    // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
    sent_edge_event_time[0][7]  = sent_edge_event_time[0][6]  + 4;                      // Rising  - Start of Data1
    sent_edge_event_time[0][8]  = sent_edge_event_time[0][7]  + t[0][1] + 8;    // Falling - Start of SENT_Fixed, Delay for Data1
    sent_edge_event_time[0][9]  = sent_edge_event_time[0][8]  + 4;                      // Rising  - Start of Data2
    sent_edge_event_time[0][10] = sent_edge_event_time[0][9]  + t[0][2] + 8;    // Falling - Start of SENT_Fixed, Delay for Data2
    sent_edge_event_time[0][11] = sent_edge_event_time[0][10] + 4;                      // Rising  - Start of CRC
    sent_edge_event_time[0][12] = sent_edge_event_time[0][11] + t[0][3] + 8;    // Falling - Start of SENT_Fixed, Delay for Addr
    sent_edge_event_time[0][13] = sent_edge_event_time[0][12] + 4;                      // Rising  - End of SENT_FIxed
    sent_edge_event_time[0][14] = sent_edge_event_time[0][13] + t[0][4] + 8;    // Falling - Start of SENT_Fixed, Delay for CRC
    sent_edge_event_time[0][15] = sent_edge_event_time[0][14] + 4;                      // Rising  - End of SENT_FIxed

    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  2   pre calc vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */

    sent_edge_event_time[1][6]  = sent_edge_event_time[1][5]  + t[1][0] + 8;    // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
    sent_edge_event_time[1][7]  = sent_edge_event_time[1][6]  + 4;                      // Rising  - Start of Data1
    sent_edge_event_time[1][8]  = sent_edge_event_time[1][7]  + t[1][1] + 8;    // Falling - Start of SENT_Fixed, delay for Data1
    sent_edge_event_time[1][9]  = sent_edge_event_time[1][8]  + 4;                      // Rising  - Start of Data2
    sent_edge_event_time[1][10] = sent_edge_event_time[1][9]  + t[1][2] + 8;    // Falling - Start of SENT_Fixed, delay for Data2
    sent_edge_event_time[1][11] = sent_edge_event_time[1][10] + 4;                      // Rising  - Start of CRC
    sent_edge_event_time[1][12] = sent_edge_event_time[1][11] + t[1][3] + 8;    // Falling - Start of SENT_Fixed, Delay for Addr
    sent_edge_event_time[1][13] = sent_edge_event_time[1][12] + 4;                      // Rising  - End of SENT_FIxed
    sent_edge_event_time[1][14] = sent_edge_event_time[1][13] + t[1][4] + 8;    // Falling - Start of SENT_Fixed, Delay for CRC
    sent_edge_event_time[1][15] = sent_edge_event_time[1][14] + 4;                      // Rising  - End of SENT_FIxed

    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  3   pre calc vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */

    sent_edge_event_time[2][6]  = sent_edge_event_time[2][5]  + t[2][0] + 8;    // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
    sent_edge_event_time[2][7]  = sent_edge_event_time[2][6]  + 4;                      // Rising  - Start of Data1
    sent_edge_event_time[2][8]  = sent_edge_event_time[2][7]  + t[2][1] + 8;    // Falling - Start of SENT_Fixed, Delay for Data1
    sent_edge_event_time[2][9]  = sent_edge_event_time[2][8]  + 4;                      // Rising  - Start of Data2
    sent_edge_event_time[2][10] = sent_edge_event_time[2][9]  + t[2][2] + 8;    // Falling - Start of SENT_Fixed, Delay for Data2
    sent_edge_event_time[2][11] = sent_edge_event_time[2][10] + 4;                      // Rising  - Start of CRC
    sent_edge_event_time[2][12] = sent_edge_event_time[2][11] + t[2][3] + 8;    // Falling - Start of SENT_Fixed, Delay for Addr
    sent_edge_event_time[2][13] = sent_edge_event_time[2][12] + 4;                      // Rising  - End of SENT_FIxed
    sent_edge_event_time[2][14] = sent_edge_event_time[2][13] + t[2][4] + 8;    // Falling - Start of SENT_Fixed, Delay for CRC
    sent_edge_event_time[2][15] = sent_edge_event_time[2][14] + 4;                      // Rising  - End of SENT_FIxed

    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  4  pre calc  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */

    sent_edge_event_time[3][6]  = sent_edge_event_time[3][5]  + t[3][0] + 8;    // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
    sent_edge_event_time[3][7]  = sent_edge_event_time[3][6]  + 4;                      // Rising  - Start of Data1
    sent_edge_event_time[3][8]  = sent_edge_event_time[3][7]  + t[3][1] + 8;    // Falling - Start of SENT_Fixed, delay for Data1
    sent_edge_event_time[3][9]  = sent_edge_event_time[3][8]  + 4;                      // Rising  - Start of Data2
    sent_edge_event_time[3][10] = sent_edge_event_time[3][9]  + t[3][2] + 8;    // Falling - Start of SENT_Fixed, delay for Data2
    sent_edge_event_time[3][11] = sent_edge_event_time[3][10] + 4;                      // Rising  - Start of CRC
    sent_edge_event_time[3][12] = sent_edge_event_time[3][11] + t[3][3] + 8;    // Falling - Start of SENT_Fixed, Delay for Addr
    sent_edge_event_time[3][13] = sent_edge_event_time[3][12] + 4;                      // Rising  - End of SENT_FIxed
    sent_edge_event_time[3][14] = sent_edge_event_time[3][13] + t[3][4] + 8;    // Falling - Start of SENT_Fixed, Delay for CRC
    sent_edge_event_time[3][15] = sent_edge_event_time[3][14] + 4;                      // Rising  - End of SENT_FIxed

    /*  OLD - Non ADAS --- Must get in and out of HET memory fast, synced with end of transmitting HW B address #1 and before start of next HW pair  */

    /*  ADAS - Must get in and out of HET memory fast, synced with end of transmitting each HW B address #1 and before start of next set of HW pair  */


    sent_ChA_handwheel_update_flag = ACTIVE;    // ready to update HET Handwheel Ram, wait for signal from HET IRQ
    sent_ChB_handwheel_update_flag = ACTIVE;    // ready to update HET Handwheel Ram, wait for signal from HET IRQ


    system_msec_clock_temp = system_msec_clock + 10;    // set time out to 10mS  waiting for SENT 2 to trigger and service IRQ where sent_handwheel_update_flag is set to IDLE
    while((sent_ChA_handwheel_update_flag == ACTIVE) && (system_msec_clock < system_msec_clock_temp));  // wait for IDLE (update after HW angle data sent), if no trigger, 10mS timeout so not to cause infinate loop
//  timout can be cause during init, ignition is not on yet, or product stopped sending trigger
    {
    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  1  final calc vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
    het_instruction_data[0][6]   = sent_edge_event_time[0][6]   * 128;      // shifted into correct position for direct write into DATA register while in ISR
    het_instruction_data[0][7]   = sent_edge_event_time[0][7]   * 128;      //      Do the calc here instead of during ISR
    het_instruction_data[0][8]   = sent_edge_event_time[0][8]   * 128;
    het_instruction_data[0][9]   = sent_edge_event_time[0][9]   * 128;
    het_instruction_data[0][10]  = sent_edge_event_time[0][10]  * 128;
    het_instruction_data[0][11]  = sent_edge_event_time[0][11]  * 128;
    het_instruction_data[0][12]  = sent_edge_event_time[0][12]  * 128;
    het_instruction_data[0][13]  = sent_edge_event_time[0][13]  * 128;
    het_instruction_data[0][14]  = sent_edge_event_time[0][14]  * 128;
    het_instruction_data[0][15]  = sent_edge_event_time[0][15]  * 128;
    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  2   final calc vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
    het_instruction_data[1][6]   = sent_edge_event_time[1][6]   * 128;      // shifted into correct position for direct write into DATA register while in ISR
    het_instruction_data[1][7]   = sent_edge_event_time[1][7]   * 128;      //      Do the calc here instead of during ISR
    het_instruction_data[1][8]   = sent_edge_event_time[1][8]   * 128;
    het_instruction_data[1][9]   = sent_edge_event_time[1][9]   * 128;
    het_instruction_data[1][10]  = sent_edge_event_time[1][10]  * 128;
    het_instruction_data[1][11]  = sent_edge_event_time[1][11]  * 128;
    het_instruction_data[1][12]  = sent_edge_event_time[1][12]  * 128;
    het_instruction_data[1][13]  = sent_edge_event_time[1][13]  * 128;
    het_instruction_data[1][14]  = sent_edge_event_time[1][14]  * 128;
    het_instruction_data[1][15]  = sent_edge_event_time[1][15]  * 128;
    }


    system_msec_clock_temp = system_msec_clock + 10;    // set time out to 10mS  waiting for SENT 2 to trigger and service IRQ where sent_handwheel_update_flag is set to IDLE
    while((sent_ChB_handwheel_update_flag == ACTIVE) && (system_msec_clock < system_msec_clock_temp));  // wait for IDLE (update after HW angle data sent), if no trigger, 10mS timeout so not to cause infinate loop
//  timout can be cause during init, ignition is not on yet, or product stopped sending trigger
    {
    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  3   final calc vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
    het_instruction_data[2][6]   = sent_edge_event_time[2][6]   * 128;      // shifted into correct position for direct write into DATA register while in ISR
    het_instruction_data[2][7]   = sent_edge_event_time[2][7]   * 128;      //      Do the calc here instead of during ISR
    het_instruction_data[2][8]   = sent_edge_event_time[2][8]   * 128;
    het_instruction_data[2][9]   = sent_edge_event_time[2][9]   * 128;
    het_instruction_data[2][10]  = sent_edge_event_time[2][10]  * 128;
    het_instruction_data[2][11]  = sent_edge_event_time[2][11]  * 128;
    het_instruction_data[2][12]  = sent_edge_event_time[2][12]  * 128;
    het_instruction_data[2][13]  = sent_edge_event_time[2][13]  * 128;
    het_instruction_data[2][14]  = sent_edge_event_time[2][14]  * 128;
    het_instruction_data[2][15]  = sent_edge_event_time[2][15]  * 128;
    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  4   final calc vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
    het_instruction_data[3][6]   = sent_edge_event_time[3][6]   * 128;      // shifted into correct position for direct write into DATA register while in ISR
    het_instruction_data[3][7]   = sent_edge_event_time[3][7]   * 128;      //      Do the calc here instead of during ISR
    het_instruction_data[3][8]   = sent_edge_event_time[3][8]   * 128;
    het_instruction_data[3][9]   = sent_edge_event_time[3][9]   * 128;
    het_instruction_data[3][10]  = sent_edge_event_time[3][10]  * 128;
    het_instruction_data[3][11]  = sent_edge_event_time[3][11]  * 128;
    het_instruction_data[3][12]  = sent_edge_event_time[3][12]  * 128;
    het_instruction_data[3][13]  = sent_edge_event_time[3][13]  * 128;
    het_instruction_data[3][14]  = sent_edge_event_time[3][14]  * 128;
    het_instruction_data[3][15]  = sent_edge_event_time[3][15]  * 128;
    }


/*  S E N T  - -  T O R Q U E  */


    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  5   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */

    sent_torque_ChA_update_flag = ACTIVE;   // flag, calculations are ACTIVE=2, IRQ do not update Torque HET ram

    sent_edge_event_time[4][6]  = sent_edge_event_time[4][5]  + t[4][0] + 8;    // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
    sent_edge_event_time[4][7]  = sent_edge_event_time[4][6]  + 4;                      // Rising  - Start of Data1
    sent_edge_event_time[4][8]  = sent_edge_event_time[4][7]  + t[4][1] + 8;    // Falling - Start of SENT_Fixed, Delay for Data1
    sent_edge_event_time[4][9]  = sent_edge_event_time[4][8]  + 4;                      // Rising  - Start of Data2
    sent_edge_event_time[4][10] = sent_edge_event_time[4][9]  + t[4][2] + 8;    // Falling - Start of SENT_Fixed, Delay for Data2
    sent_edge_event_time[4][11] = sent_edge_event_time[4][10] + 4;                      // Rising  - Start of CRC
    sent_edge_event_time[4][12] = sent_edge_event_time[4][11] + t[4][3] + 8;    // Falling - Start of SENT_Fixed, Delay for CRC
    sent_edge_event_time[4][13] = sent_edge_event_time[4][12] + 4;                      // Rising  - End of SENT_FIxed

    het_instruction_data[4][6]   = sent_edge_event_time[4][6]   * 128;      // shifted into correct position for direct write into DATA register while in ISR
    het_instruction_data[4][7]   = sent_edge_event_time[4][7]   * 128;      //      Do the calc here instead of during ISR
    het_instruction_data[4][8]   = sent_edge_event_time[4][8]   * 128;
    het_instruction_data[4][9]   = sent_edge_event_time[4][9]   * 128;
    het_instruction_data[4][10]  = sent_edge_event_time[4][10]  * 128;
    het_instruction_data[4][11]  = sent_edge_event_time[4][11]  * 128;
    het_instruction_data[4][12]  = sent_edge_event_time[4][12]  * 128;
    het_instruction_data[4][13]  = sent_edge_event_time[4][13]  * 128;

    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  6   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */

    sent_edge_event_time[5][6]  = sent_edge_event_time[5][5]  + t[5][0] + 8;    // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
    sent_edge_event_time[5][7]  = sent_edge_event_time[5][6]  + 4;                      // Rising  - Start of Data1
    sent_edge_event_time[5][8]  = sent_edge_event_time[5][7]  + t[5][1] + 8;    // Falling - Start of SENT_Fixed, Delay for Data1
    sent_edge_event_time[5][9]  = sent_edge_event_time[5][8]  + 4;                      // Rising  - Start of Data2
    sent_edge_event_time[5][10] = sent_edge_event_time[5][9]  + t[5][2] + 8;    // Falling - Start of SENT_Fixed, Delay for Data2
    sent_edge_event_time[5][11] = sent_edge_event_time[5][10] + 4;                      // Rising  - Start of CRC
    sent_edge_event_time[5][12] = sent_edge_event_time[5][11] + t[5][3] + 8;    // Falling - Start of SENT_Fixed, Delay for CRC
    sent_edge_event_time[5][13] = sent_edge_event_time[5][12] + 4;                      // Rising  - End of SENT_FIxed

    het_instruction_data[5][6]   = sent_edge_event_time[5][6]   * 128;      // shifted into correct position for direct write into DATA register while in ISR
    het_instruction_data[5][7]   = sent_edge_event_time[5][7]   * 128;      //      Do the calc here instead of during ISR
    het_instruction_data[5][8]   = sent_edge_event_time[5][8]   * 128;
    het_instruction_data[5][9]   = sent_edge_event_time[5][9]   * 128;
    het_instruction_data[5][10]  = sent_edge_event_time[5][10]  * 128;
    het_instruction_data[5][11]  = sent_edge_event_time[5][11]  * 128;
    het_instruction_data[5][12]  = sent_edge_event_time[5][12]  * 128;
    het_instruction_data[5][13]  = sent_edge_event_time[5][13]  * 128;

    sent_torque_ChA_update_flag = REQUEST;  // flag, calculations are complete, OK to update HET Torque ram

    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  7   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */

    sent_torque_ChB_update_flag = ACTIVE;   // flag, calculations are ACTIVE=2, IRQ do not update Torque HET ram

    sent_edge_event_time[6][6]  = sent_edge_event_time[6][5]  + t[6][0] + 8;    // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
    sent_edge_event_time[6][7]  = sent_edge_event_time[6][6]  + 4;                      // Rising  - Start of Data1
    sent_edge_event_time[6][8]  = sent_edge_event_time[6][7]  + t[6][1] + 8;    // Falling - Start of SENT_Fixed, Delay for Data1
    sent_edge_event_time[6][9]  = sent_edge_event_time[6][8]  + 4;                      // Rising  - Start of Data2
    sent_edge_event_time[6][10] = sent_edge_event_time[6][9]  + t[6][2] + 8;    // Falling - Start of SENT_Fixed, Delay for Data2
    sent_edge_event_time[6][11] = sent_edge_event_time[6][10] + 4;                      // Rising  - Start of CRC
    sent_edge_event_time[6][12] = sent_edge_event_time[6][11] + t[6][3] + 8;    // Falling - Start of SENT_Fixed, Delay for CRC
    sent_edge_event_time[6][13] = sent_edge_event_time[6][12] + 4;                      // Rising  - End of SENT_FIxed

    het_instruction_data[6][6]   = sent_edge_event_time[6][6]   * 128;      // shifted into correct position for direct write into DATA register while in ISR
    het_instruction_data[6][7]   = sent_edge_event_time[6][7]   * 128;      //      Do the calc here instead of during ISR
    het_instruction_data[6][8]   = sent_edge_event_time[6][8]   * 128;
    het_instruction_data[6][9]   = sent_edge_event_time[6][9]   * 128;
    het_instruction_data[6][10]  = sent_edge_event_time[6][10]  * 128;
    het_instruction_data[6][11]  = sent_edge_event_time[6][11]  * 128;
    het_instruction_data[6][12]  = sent_edge_event_time[6][12]  * 128;
    het_instruction_data[6][13]  = sent_edge_event_time[6][13]  * 128;

    /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  8   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */

    sent_edge_event_time[7][6]  = sent_edge_event_time[7][5]  + t[7][0] + 8;    // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
    sent_edge_event_time[7][7]  = sent_edge_event_time[7][6]  + 4;                      // Rising  - Start of Data1
    sent_edge_event_time[7][8]  = sent_edge_event_time[7][7]  + t[7][1] + 8;    // Falling - Start of SENT_Fixed, Delay for Data1
    sent_edge_event_time[7][9]  = sent_edge_event_time[7][8]  + 4;                      // Rising  - Start of Data2
    sent_edge_event_time[7][10] = sent_edge_event_time[7][9]  + t[7][2] + 8;    // Falling - Start of SENT_Fixed, Delay for Data2
    sent_edge_event_time[7][11] = sent_edge_event_time[7][10] + 4;                      // Rising  - Start of CRC
    sent_edge_event_time[7][12] = sent_edge_event_time[7][11] + t[7][3] + 8;    // Falling - Start of SENT_Fixed, Delay for CRC
    sent_edge_event_time[7][13] = sent_edge_event_time[7][12] + 4;                      // Rising  - End of SENT_FIxed

    het_instruction_data[7][6]   = sent_edge_event_time[7][6]   * 128;      // shifted into correct position for direct write into DATA register while in ISR
    het_instruction_data[7][7]   = sent_edge_event_time[7][7]   * 128;      //      Do the calc here instead of during ISR
    het_instruction_data[7][8]   = sent_edge_event_time[7][8]   * 128;
    het_instruction_data[7][9]   = sent_edge_event_time[7][9]   * 128;
    het_instruction_data[7][10]  = sent_edge_event_time[7][10]  * 128;
    het_instruction_data[7][11]  = sent_edge_event_time[7][11]  * 128;
    het_instruction_data[7][12]  = sent_edge_event_time[7][12]  * 128;
    het_instruction_data[7][13]  = sent_edge_event_time[7][13]  * 128;

    sent_torque_ChB_update_flag = REQUEST;  // flag, calculations are complete, OK to update HET Torque ram

}

void sent_data_calculation_from_torque(int *torque_value_case_index)
{
    /*  Designed to take a variable value and translate to SENT signals  --- (not implimented yet)   */

//  // declaration void sent_data_calculation_from_table(short *const table[][5]);
//  //void sent_data_calculation_from_table(const short t[][5])   //called by sent_data_calculation_from_table(xxx)
//  //void sent_data_calculation_from_table( t[][5])
//
//  {
//
//      value_sent1_Adr0_ChA0_Pos_cnt   = sent_data_array[0][0] << 8 + sent_data_array[0][1] << 4 + sent_data_array[0][2];  // sent1 value transmitted to product;
//      value_sent1_Adr1_ChA1_Pos_cnt   = sent_data_array[1][0] << 8 + sent_data_array[1][1] << 4 + sent_data_array[1][2];  // sent2 value transmitted to product;
//      value_sent2_Adr0_ChB0_Pos_cnt   = sent_data_array[2][0] << 8 + sent_data_array[2][1] << 4 + sent_data_array[2][2];  // sent3 value transmitted to product;
//      value_sent2_Adr1_ChB1_Pos_cnt   = sent_data_array[3][0] << 8 + sent_data_array[3][1] << 4 + sent_data_array[3][2];  // sent4 value transmitted to product;
//      value_sent3_ChA_T1_cnt          = sent_data_array[4][0] << 8 + sent_data_array[4][1] << 4 + sent_data_array[4][2];  // sent5 value transmitted to product;
//      value_sent4_ChA_T2_cnt          = sent_data_array[5][0] << 8 + sent_data_array[5][1] << 4 + sent_data_array[5][2];  // sent6 value transmitted to product;
//      value_sent5_ChB_T1_cnt          = sent_data_array[6][0] << 8 + sent_data_array[6][1] << 4 + sent_data_array[6][2];  // sent7 value transmitted to product;
//      value_sent6_ChB_T2_cnt          = sent_data_array[7][0] << 8 + sent_data_array[7][1] << 4 + sent_data_array[7][2];  // sent8 value transmitted to product;
//
//      sent_update_flag = ACTIVE;  // flag, calculations are ACTIVE=2, not IDLE=0, do not update HET ram
//
//      /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  1   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
//
//      sent_edge_event_time[0][6]  = sent_edge_event_time[0][5]  + sent_data_array[0][0] + 8;  // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
//      sent_edge_event_time[0][7]  = sent_edge_event_time[0][6]  + 4;                      // Rising  - Start of Data1
//      sent_edge_event_time[0][8]  = sent_edge_event_time[0][7]  + sent_data_array[0][1] + 8;  // Falling - Start of SENT_Fixed, Delay for Data1
//      sent_edge_event_time[0][9]  = sent_edge_event_time[0][8]  + 4;                      // Rising  - Start of Data2
//      sent_edge_event_time[0][10] = sent_edge_event_time[0][9]  + sent_data_array[0][2] + 8;  // Falling - Start of SENT_Fixed, Delay for Data2
//      sent_edge_event_time[0][11] = sent_edge_event_time[0][10] + 4;                      // Rising  - Start of CRC
//      sent_edge_event_time[0][12] = sent_edge_event_time[0][11] + sent_data_array[0][3] + 8;  // Falling - Start of SENT_Fixed, Delay for Addr
//      sent_edge_event_time[0][13] = sent_edge_event_time[0][12] + 4;                      // Rising  - End of SENT_FIxed
//      sent_edge_event_time[0][14] = sent_edge_event_time[0][13] + sent_data_array[0][4] + 8;  // Falling - Start of SENT_Fixed, Delay for CRC
//      sent_edge_event_time[0][15] = sent_edge_event_time[0][14] + 4;                      // Rising  - End of SENT_FIxed
//
//      /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  2   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
//
//      sent_edge_event_time[1][6]  = sent_edge_event_time[1][5]  + sent_data_array[1][0] + 8;  // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
//      sent_edge_event_time[1][7]  = sent_edge_event_time[1][6]  + 4;                      // Rising  - Start of Data1
//      sent_edge_event_time[1][8]  = sent_edge_event_time[1][7]  + sent_data_array[1][1] + 8;  // Falling - Start of SENT_Fixed, delay for Data1
//      sent_edge_event_time[1][9]  = sent_edge_event_time[1][8]  + 4;                      // Rising  - Start of Data2
//      sent_edge_event_time[1][10] = sent_edge_event_time[1][9]  + sent_data_array[1][2] + 8;  // Falling - Start of SENT_Fixed, delay for Data2
//      sent_edge_event_time[1][11] = sent_edge_event_time[1][10] + 4;                      // Rising  - Start of CRC
//      sent_edge_event_time[1][12] = sent_edge_event_time[1][11] + sent_data_array[1][3] + 8;  // Falling - Start of SENT_Fixed, Delay for Addr
//      sent_edge_event_time[1][13] = sent_edge_event_time[1][12] + 4;                      // Rising  - End of SENT_FIxed
//      sent_edge_event_time[1][14] = sent_edge_event_time[1][13] + sent_data_array[1][4] + 8;  // Falling - Start of SENT_Fixed, Delay for CRC
//      sent_edge_event_time[1][15] = sent_edge_event_time[1][14] + 4;                      // Rising  - End of SENT_FIxed
//
//      /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  3   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
//
//      sent_edge_event_time[2][6]  = sent_edge_event_time[2][5]  + sent_data_array[2][0] + 8;  // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
//      sent_edge_event_time[2][7]  = sent_edge_event_time[2][6]  + 4;                      // Rising  - Start of Data1
//      sent_edge_event_time[2][8]  = sent_edge_event_time[2][7]  + sent_data_array[2][1] + 8;  // Falling - Start of SENT_Fixed, Delay for Data1
//      sent_edge_event_time[2][9]  = sent_edge_event_time[2][8]  + 4;                      // Rising  - Start of Data2
//      sent_edge_event_time[2][10] = sent_edge_event_time[2][9]  + sent_data_array[2][2] + 8;  // Falling - Start of SENT_Fixed, Delay for Data2
//      sent_edge_event_time[2][11] = sent_edge_event_time[2][10] + 4;                      // Rising  - Start of CRC
//      sent_edge_event_time[2][12] = sent_edge_event_time[2][11] + sent_data_array[2][3] + 8;  // Falling - Start of SENT_Fixed, Delay for Addr
//      sent_edge_event_time[2][13] = sent_edge_event_time[2][12] + 4;                      // Rising  - End of SENT_FIxed
//      sent_edge_event_time[2][14] = sent_edge_event_time[2][13] + sent_data_array[2][4] + 8;  // Falling - Start of SENT_Fixed, Delay for CRC
//      sent_edge_event_time[2][15] = sent_edge_event_time[2][14] + 4;                      // Rising  - End of SENT_FIxed
//
//      /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  4   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
//
//      sent_edge_event_time[3][6]  = sent_edge_event_time[3][5]  + sent_data_array[3][0] + 8;  // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
//      sent_edge_event_time[3][7]  = sent_edge_event_time[3][6]  + 4;                      // Rising  - Start of Data1
//      sent_edge_event_time[3][8]  = sent_edge_event_time[3][7]  + sent_data_array[3][1] + 8;  // Falling - Start of SENT_Fixed, delay for Data1
//      sent_edge_event_time[3][9]  = sent_edge_event_time[3][8]  + 4;                      // Rising  - Start of Data2
//      sent_edge_event_time[3][10] = sent_edge_event_time[3][9]  + sent_data_array[3][2] + 8;  // Falling - Start of SENT_Fixed, delay for Data2
//      sent_edge_event_time[3][11] = sent_edge_event_time[3][10] + 4;                      // Rising  - Start of CRC
//      sent_edge_event_time[3][12] = sent_edge_event_time[3][11] + sent_data_array[3][3] + 8;  // Falling - Start of SENT_Fixed, Delay for Addr
//      sent_edge_event_time[3][13] = sent_edge_event_time[3][12] + 4;                      // Rising  - End of SENT_FIxed
//      sent_edge_event_time[3][14] = sent_edge_event_time[3][13] + sent_data_array[3][4] + 8;  // Falling - Start of SENT_Fixed, Delay for CRC
//      sent_edge_event_time[3][15] = sent_edge_event_time[3][14] + 4;                      // Rising  - End of SENT_FIxed
//
//      /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  5   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
//
//      sent_edge_event_time[4][6]  = sent_edge_event_time[4][5]  + sent_data_array[4][0] + 8;  // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
//      sent_edge_event_time[4][7]  = sent_edge_event_time[4][6]  + 4;                      // Rising  - Start of Data1
//      sent_edge_event_time[4][8]  = sent_edge_event_time[4][7]  + sent_data_array[4][1] + 8;  // Falling - Start of SENT_Fixed, Delay for Data1
//      sent_edge_event_time[4][9]  = sent_edge_event_time[4][8]  + 4;                      // Rising  - Start of Data2
//      sent_edge_event_time[4][10] = sent_edge_event_time[4][9]  + sent_data_array[4][2] + 8;  // Falling - Start of SENT_Fixed, Delay for Data2
//      sent_edge_event_time[4][11] = sent_edge_event_time[4][10] + 4;                      // Rising  - Start of CRC
//      sent_edge_event_time[4][12] = sent_edge_event_time[4][11] + sent_data_array[4][3] + 8;  // Falling - Start of SENT_Fixed, Delay for CRC
//      sent_edge_event_time[4][13] = sent_edge_event_time[4][12] + 4;                      // Rising  - End of SENT_FIxed
//
//      /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  6   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
//
//      sent_edge_event_time[5][6]  = sent_edge_event_time[5][5]  + sent_data_array[5][0] + 8;  // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
//      sent_edge_event_time[5][7]  = sent_edge_event_time[5][6]  + 4;                      // Rising  - Start of Data1
//      sent_edge_event_time[5][8]  = sent_edge_event_time[5][7]  + sent_data_array[5][1] + 8;  // Falling - Start of SENT_Fixed, Delay for Data1
//      sent_edge_event_time[5][9]  = sent_edge_event_time[5][8]  + 4;                      // Rising  - Start of Data2
//      sent_edge_event_time[5][10] = sent_edge_event_time[5][9]  + sent_data_array[5][2] + 8;  // Falling - Start of SENT_Fixed, Delay for Data2
//      sent_edge_event_time[5][11] = sent_edge_event_time[5][10] + 4;                      // Rising  - Start of CRC
//      sent_edge_event_time[5][12] = sent_edge_event_time[5][11] + sent_data_array[5][3] + 8;  // Falling - Start of SENT_Fixed, Delay for CRC
//      sent_edge_event_time[5][13] = sent_edge_event_time[5][12] + 4;                      // Rising  - End of SENT_FIxed
//
//      /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  7   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
//
//      sent_edge_event_time[6][6]  = sent_edge_event_time[6][5]  + sent_data_array[6][0] + 8;  // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
//      sent_edge_event_time[6][7]  = sent_edge_event_time[6][6]  + 4;                      // Rising  - Start of Data1
//      sent_edge_event_time[6][8]  = sent_edge_event_time[6][7]  + sent_data_array[6][1] + 8;  // Falling - Start of SENT_Fixed, Delay for Data1
//      sent_edge_event_time[6][9]  = sent_edge_event_time[6][8]  + 4;                      // Rising  - Start of Data2
//      sent_edge_event_time[6][10] = sent_edge_event_time[6][9]  + sent_data_array[6][2] + 8;  // Falling - Start of SENT_Fixed, Delay for Data2
//      sent_edge_event_time[6][11] = sent_edge_event_time[6][10] + 4;                      // Rising  - Start of CRC
//      sent_edge_event_time[6][12] = sent_edge_event_time[6][11] + sent_data_array[6][3] + 8;  // Falling - Start of SENT_Fixed, Delay for CRC
//      sent_edge_event_time[6][13] = sent_edge_event_time[6][12] + 4;                      // Rising  - End of SENT_FIxed
//
//      /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  8   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
//
//      sent_edge_event_time[7][6]  = sent_edge_event_time[7][5]  + sent_data_array[7][0] + 8;  // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
//      sent_edge_event_time[7][7]  = sent_edge_event_time[7][6]  + 4;                      // Rising  - Start of Data1
//      sent_edge_event_time[7][8]  = sent_edge_event_time[7][7]  + sent_data_array[7][1] + 8;  // Falling - Start of SENT_Fixed, Delay for Data1
//      sent_edge_event_time[7][9]  = sent_edge_event_time[7][8]  + 4;                      // Rising  - Start of Data2
//      sent_edge_event_time[7][10] = sent_edge_event_time[7][9]  + sent_data_array[7][2] + 8;  // Falling - Start of SENT_Fixed, Delay for Data2
//      sent_edge_event_time[7][11] = sent_edge_event_time[7][10] + 4;                      // Rising  - Start of CRC
//      sent_edge_event_time[7][12] = sent_edge_event_time[7][11] + sent_data_array[7][3] + 8;  // Falling - Start of SENT_Fixed, Delay for CRC
//      sent_edge_event_time[7][13] = sent_edge_event_time[7][12] + 4;                      // Rising  - End of SENT_FIxed
//
//
//      sent_update_flag = IDLE;    // flag, calculations are complete, OK to update HET ram
//
}


void sent_data_calculation_from_analog(void)
{
    /*  Designed to take use Analog torque values and translate to SENT signals  --- (used in Ford FOAA 2Ch SENT)   */


//  /*  call sent_data_calculation() after spiTransfer(spiREG1, 0); */
//  /*  function will build sensor's SENT data and CRC, data is used by HET ISR to load HET ram for signal creation  */
//
//  // SENT is based on 16bit analog data transmit array: DtoA_array[8][3]
//  // DtoA_array[6] = T1   DtoA_array[7] = T2
//  // DtoA_array[x][high_byte][low_byte] = 16bit value, Sent needs 12 significant bit value, drop last 4 bits and shift downward
//  // SENT1 data0,data1,data2,CRC
//  //
//  //  CRC Examples:  0x7,0xF,0xF = 0x7 ,, 0x3,0x4,0x5 = 0xB
//
//  uint8 crc4_table[] = {0,13,7,10,14,3,9,4,1,12,6,11,15,2,8,5};
//  uint8 check_sum16;
//
//  sent_update_flag = ACTIVE;  // flag, calculations are ACTIVE=2, not IDLE=0, do not update HET ram
//
//  /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  1   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
//  sent_data_array[0] = DtoA_array[6][1] >> 4;     // Data0  High Nibble
//    sent_data_array[1] = DtoA_array[6][1] & 0xF;  // Data1  Middle Nibble
//      sent_data_array[2] = DtoA_array[6][2] >> 4;     // Data2  Low Nibble
//
//      value_sent1_cnt = sent_data_array[0] << 8 + sent_data_array[1] << 4 + sent_data_array[2];   // sent1 value transmitted to product
//
//      check_sum16 = 5;
//      check_sum16 = (unsigned char)sent_data_array[0] ^ (unsigned char)crc4_table[check_sum16];
//      check_sum16 = (unsigned char)sent_data_array[1] ^ (unsigned char)crc4_table[check_sum16];
//      check_sum16 = (unsigned char)sent_data_array[2] ^ (unsigned char)crc4_table[check_sum16];
//      check_sum16 = (unsigned char)0 ^ (unsigned char)crc4_table[check_sum16];
//
//      sent_data_array[3] = check_sum16;               // CRC
//
//      sent_edge_event_time[0][6]  = sent_edge_event_time[0][5] + sent_data_array[0] + 8;  // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
//      sent_edge_event_time[0][7]  = sent_edge_event_time[0][6] + 4;                       // Rising  - Start of Data1
//      sent_edge_event_time[0][8]  = sent_edge_event_time[0][7] + sent_data_array[1] + 8;  // Falling - Start of SENT_Fixed, Delay for Data1
//      sent_edge_event_time[0][9]  = sent_edge_event_time[0][8] + 4;                       // Rising  - Start of Data2
//      sent_edge_event_time[0][10] = sent_edge_event_time[0][9] + sent_data_array[2] + 8;  // Falling - Start of SENT_Fixed, Delay for Data2
//      sent_edge_event_time[0][11] = sent_edge_event_time[0][10] + 4;                      // Rising  - Start of CRC
//      sent_edge_event_time[0][12] = sent_edge_event_time[0][11] + sent_data_array[3] + 8; // Falling - Start of SENT_Fixed, Delay for CRC
//      sent_edge_event_time[0][13] = sent_edge_event_time[0][12] + 4;                      // Rising  - End of SENT_FIxed
//
//  /* vvvvvvvvvvvvvvvvvvvvvv    S E N T  2   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv  */
//    sent_data_array[4] = DtoA_array[7][1] >> 4;       // Data0  High Nibble
//    sent_data_array[5] = DtoA_array[7][1] & 0xF;    // Data1  Middle Nibble
//    sent_data_array[6] = DtoA_array[7][2] >> 4;     // Data2  Low Nibble
//
//    value_sent2_cnt = sent_data_array[4] << 8 + sent_data_array[5] << 4 + sent_data_array[6]; // sent2 value transmitted to product
//
//      check_sum16 = 5;
//      check_sum16 = (unsigned char)sent_data_array[4] ^ (unsigned char)crc4_table[check_sum16];
//      check_sum16 = (unsigned char)sent_data_array[5] ^ (unsigned char)crc4_table[check_sum16];
//      check_sum16 = (unsigned char)sent_data_array[6] ^ (unsigned char)crc4_table[check_sum16];
//      check_sum16 = (unsigned char)0 ^ (unsigned char)crc4_table[check_sum16];
//
//    sent_data_array[7] = check_sum16;             //CRC
//
//    sent_edge_event_time[1][6]  = sent_edge_event_time[1][5] + sent_data_array[4] + 8;    // Falling - Start of SENT_Fixed, +8 = zero, SENT Rule for data, Delay for Data0
//    sent_edge_event_time[1][7]  = sent_edge_event_time[1][6] + 4;                     // Rising  - Start of Data1
//    sent_edge_event_time[1][8]  = sent_edge_event_time[1][7] + sent_data_array[5] + 8;    // Falling - Start of SENT_Fixed, delay for Data1
//    sent_edge_event_time[1][9]  = sent_edge_event_time[1][8] + 4;                     // Rising  - Start of Data2
//    sent_edge_event_time[1][10] = sent_edge_event_time[1][9] + sent_data_array[6] + 8;    // Falling - Start of SENT_Fixed, delay for Data2
//    sent_edge_event_time[1][11] = sent_edge_event_time[1][10] + 4;                        // Rising  - Start of CRC
//    sent_edge_event_time[1][12] = sent_edge_event_time[1][11] + sent_data_array[7] + 8;   // Falling - Start of SENT_Fixed, Delay for CRC
//    sent_edge_event_time[1][13] = sent_edge_event_time[1][12] + 4;                    // Rising  - End of SENT_FIxed
//
//    sent_update_flag = IDLE;  // flag, calculations are complete, OK to update HET ram

}



void hcurr_change_direction_at_nm(float target)
{   // function to swap T1/T2 direction at assigned torque (0.0, 0.1, 0.5, 1.0, 2.0, 3.0, 4.0, 6.0) are valid values
    // the swap will assign a new value to torque_value_case_index

    int target_nm_as_decimal;

    target_nm_as_decimal = target*10;       // force conversion to decimal (*10) for switch statement

    switch (hcurr_direction_POS_NEG)
    {
    case POSITIVE:
    {   // if direction is positive, make torque negative and change direction flag to negative
        hcurr_direction_POS_NEG = NEGATIVE;
        switch (target_nm_as_decimal)
        {   // case = 0.0 or 0.1 or 0.5 or 1.0 or 1.5 or 2.0 or 2.5 or 3.0 or 3.5 or 4.0 or 6.0 then push to negative torque index, afterwords set flag for main to process
        case 0:  torque_value_case_index = pos_0nm;     break;
        case 1:  torque_value_case_index = neg_p1nm;    break;
        case 5:  torque_value_case_index = neg_p5nm;    break;
        case 10: torque_value_case_index = neg_1p00nm;  break;
        case 15: torque_value_case_index = neg_1p50nm;  break;
        case 20: torque_value_case_index = neg_2p00nm;  break;
        case 25: torque_value_case_index = neg_2p50nm;  break;
        case 30: torque_value_case_index = neg_3p00nm;  break;
        case 35: torque_value_case_index = neg_3p50nm;  break;
        case 40: torque_value_case_index = neg_4p00nm;  break;
        case 60: torque_value_case_index = neg_6p00nm;  break;
        }
    }
    break;  // POSITIVE

    case NEGATIVE:
    {   // if direction is negative, make torque positive and change direction flag to positive
        hcurr_direction_POS_NEG = POSITIVE;
        switch (target_nm_as_decimal)
        {   // case = 0.0 or 0.1 or 0.5 or 1.0 or1.5 or 2.0 or 2.5 or 3.0 or3.5 or 4.0 or 6.0 then push to positive torque index, afterwords set flag for main to process
        case 0:  torque_value_case_index = pos_0nm;     break;
        case 1:  torque_value_case_index = pos_p1nm;    break;
        case 5:  torque_value_case_index = pos_p5nm;    break;
        case 10: torque_value_case_index = pos_1p00nm;  break;
        case 15: torque_value_case_index = pos_1p50nm;  break;
        case 20: torque_value_case_index = pos_2p00nm;  break;
        case 25: torque_value_case_index = pos_2p50nm;  break;
        case 30: torque_value_case_index = pos_3p00nm;  break;
        case 35: torque_value_case_index = pos_3p50nm;  break;
        case 40: torque_value_case_index = pos_4p00nm;  break;
        case 60: torque_value_case_index = pos_6p00nm;  break;
        }
    }
    break;  // NEGATIVE
    }


}

void set_torque_TOC_or_SENT_or_Analog()
{   // Function consolidates various code segments for the setting of torque (T1 and T2 channels) by various methods
    //  Torque Over Can (TOC) using various CAN services
    //  SENT digital signals
    //  Analog
    //
    //  Couple of prerequisites and assumptions
    //      manufacturing_TOC variable should be initialized to "YES" or "NO" at beginning of code.
    //      torque_value_case_index should be set prior to calling this function, valid range is 0 to 20, use "define"s.
    //      DtoA_array[] should be initialized to either program specific values or test_DtoA_load17 which load 2.5v on all 8 DtoA channels


    if(manufacturing_TOC == YES)    // use CAN else use SENT
    {
        tester_present_timer = 3000;  // reset timer for 3 seconds to ensure TOC messages not stepped on
        tester_present_enable_flag = 1;  // enable tester present message, executed in RTI ISR

        ECU1_XCP_reply_index = 20; // Do nothing index- just receive reply, don't send another message, in ISR hit Default case, set to 0.
        ECU2_XCP_reply_index = 20;

//                  clear_dtcs_flag = 0; // make sure it is get DTC's  NOT clear
        ECU1_clear_DTCs_flag = 0;
        ECU2_clear_DTCs_flag = 0;

/*  Nexteer Session command and prep for TOC sequence  */
        switch(target_product)
        {
            case TARGET_T1XX:
            case TARGET_C1XX:
            case TARGET_PSA_CMP:
            {
                canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                ECU1_XCP_reply_index = 20;  // do nothing case for product reply

                break;
            }
            case TARGET_G2KCA_ADAS:
            {
                canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                ECU1_XCP_reply_index = 100;  // make it happen index
                ECU2_XCP_reply_index = 100;

                break;
            }
            case TARGET_BYD_SA2FL:
            {
                canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                ECU1_XCP_reply_index = 100;  // make it happen index

                break;
            }

            case TARGET_GWM_A0607:
            {
                canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                ECU1_XCP_reply_index = 100;  // make it happen index

                break;
            }
            case TARGET_SGMW_CN200:
            {
                canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                ECU1_XCP_reply_index = 100;  // make it happen index

                break;
            }

            case TARGET_RENAULT_NISSAN:
            {
                canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                ECU1_XCP_reply_index = 100;  // make it happen index

                break;
            }

            case TARGET_FORD_T3_T6:
            {
                canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);
                canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) xcp_write_session_Nexteer_mode);

                system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS

                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                ECU1_XCP_reply_index = 100;  // make it happen index
                ECU2_XCP_reply_index = 100;

                break;
            }

            case TARGET_BMW_FAAR_WE:
            {
                transmitFlexray(MFG_TX_nexteer_session_MSG, MFG_TX,3);

                system_msec_clock_temp = system_msec_clock + 250;   // set time out to 250mS
                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));

                break;
            }

            case TARGET_BMW_UKL:
            {
                transmitFlexray(Nexteer_session, MFG_TX,2);

                system_msec_clock_temp = system_msec_clock + 500;   // set time out to 500mS for rev2 5/09/13 WAS 150ms normally
                while((ECU1_XCP_reply_index != 0) && (system_msec_clock < system_msec_clock_temp));    // changed to <14 from 12 for NEW 5 byte DTCs number

             break;
            }

        break;
        }

/*  T O R Q U E command, various manufacturing services used  */
        switch(target_product)
        {
            case TARGET_T1XX:
            case TARGET_C1XX:
            {
                switch(torque_value_case_index)
                {
                case pos_0nm:  // zero nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                break;

                case pos_p1nm: // +.1 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm);
                break;

                case neg_p1nm:  //  -.1 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm);
                break;

                case pos_p5nm:  // +.5 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm);
                break;

                case neg_p5nm:  //  -.5 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm);
                break;

                case pos_1p00nm:  //  +1 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm);
                break;

                case neg_1p00nm:  //  -1 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm);
                break;

                case pos_1p50nm:  //  +1.5 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm);
                break;

                case neg_1p50nm:  //  -1.5 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm);
                break;

                case pos_2p00nm:  //  +2.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);
                break;

                case neg_2p00nm:  //  -2.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);
                break;

                case pos_2p50nm:  //  +2.50 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm);
                break;

                case neg_2p50nm:  //  -2.50 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm);
                break;

                case pos_3p00nm:  //  +3.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm);
                break;

                case neg_3p00nm:  //  -3.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm);
                break;

                case pos_3p50nm:  //  +3.50 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm);
                break;

                case neg_3p50nm:  //  -3.50 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm);
                break;

                case pos_4p00nm:  //  +4.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);
                break;

                case neg_4p00nm: //  -4.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);
                break;

                case pos_6p00nm:  //  +6.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm);
                break;

                case neg_6p00nm:  //  -6.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm);
                break;

                default:
                    break;
                }  // end switch(torque_value_case_index)

            break;
            }   // end case TARGET_T1XX: case TARGET_BYD_SA2FL: case TARGET_C1XX:

            case TARGET_9BXX:
            {
                switch(torque_value_case_index)
                {
                case pos_0nm:  // Set torque pos 0% command (pos or neg)
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_motor_torq_serv_pos_0prcnt);
                break;

                case pos_p1nm:  // Set torque pos 2% command
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_motor_torq_serv_pos_2prcnt);
                break;

                case neg_p1nm:  // Set torque neg 2% command
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_motor_torq_serv_neg_2prcnt);
                break;

                case pos_p5nm:  // Set torque pos 8% command
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_motor_torq_serv_pos_8prcnt);
                break;

                case neg_p5nm:  // Set torque neg 8% command
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_motor_torq_serv_neg_8prcnt);
                break;

                case pos_1p00nm:  // Set torque pos 16% command
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_motor_torq_serv_pos_16prcnt);
                break;

                case neg_1p00nm:  // Set torque neg 16% command
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_motor_torq_serv_neg_16prcnt);
                break;

                case pos_2p00nm:  // Set torque pos 30% command
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_motor_torq_serv_pos_30prcnt);
                break;

                case neg_2p00nm:  // Set torque neg 30% command
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_motor_torq_serv_neg_30prcnt);
                break;

                case pos_6p00nm:  // Set torque pos 2NM command medium power func
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_motor_torq_serv_pos_95prcnt);
                break;

                case neg_6p00nm:  // Set torque neg 2NM command medium power func
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_motor_torq_serv_neg_95prcnt);
                break;

                default:
                    break;
                }  // end switch(torque_value_case_index)

            break;
            }  // end case TARGET_9BXX:

            case TARGET_G2KCA_ADAS:
            {
                switch(torque_value_case_index)
                {
                case pos_0nm:  // zero nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_p1nm:  // +.1 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_p1nm:  // -.1 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_p5nm:  // +.5 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_p5nm:  //  -.5 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_1p00nm:  //  +1 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_1p00nm:  //  -1 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_1p50nm:  //  +1.5 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_1p50nm:  //  -1.5 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_2p00nm:  //  +2.00 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_2p00nm:  //  -2.00 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_2p50nm:  //  +2.50 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_2p50nm:  //  -2.50 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_3p00nm:  //  +3.00 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_3p00nm:  //  -3.00 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_3p50nm:  //  +3.50 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_3p50nm:  //  -3.50 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_4p00nm:  //  +4.00 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_4p00nm:  //  -4.00 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_6p00nm:  //  +6.00 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_6p00nm:  //  -6.00 nm torque
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm2);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, G2KCA_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, G2KCA_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                default:
                    break;
                }  // end switch(torque_value_case_index)

            break;
            }  // end case TARGET_G2KCA_ADAS

            case TARGET_PSA_CMP:
            {
                switch(torque_value_case_index)
                {
                case pos_0nm:  // zero nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_0nm2);
                break;

                case pos_p1nm:  // +.1 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_p1nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_p1nm2);
                break;

                case neg_p1nm:  // -.1 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_p1nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_p1nm2);
                break;

                case pos_p5nm:  // +.5 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_p5nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_p5nm2);
                break;

                case neg_p5nm:  //  -.5 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_p5nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_p5nm2);
                break;

                case pos_1p00nm:  //  +1 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_1p00nm2);
                break;

                case neg_1p00nm:  //  -1 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_1p00nm2);
                break;

                case pos_1p50nm:  //  +1.5 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_1p50nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_1p50nm2);
                break;

                case neg_1p50nm:  //  -1.5 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_1p50nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_1p50nm2);
                break;

                case pos_2p00nm:  //  +2.00 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_2p00nm2);
                break;

                case neg_2p00nm:  //  -2.00 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_2p00nm2);
                break;

                case pos_2p50nm:  //  +2.50 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_2p50nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_2p50nm2);
                break;

                case neg_2p50nm:  //  -2.50 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_2p50nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_2p50nm2);
                break;

                case pos_3p00nm:  //  +3.00 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_3p00nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_3p00nm2);
                break;

                case neg_3p00nm:  //  -3.00 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_3p00nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_3p00nm2);
                break;

                case pos_3p50nm:  //  +3.50 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_3p50nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_3p50nm2);
                break;

                case neg_3p50nm:  //  -3.50 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_3p50nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_3p50nm2);
                break;

                case pos_4p00nm:  //  +4.00 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_4p00nm2);
                break;

                case neg_4p00nm:  //  -4.00 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_4p00nm2);
                break;

                case pos_6p00nm:  //  +6.00 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_pos_6p00nm2);
                break;

                case neg_6p00nm:  //  -6.00 nm torque
                    canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 50;   // set time out to 50mS
                    while((ECU1_XCP_reply_index == 20) && (system_msec_clock < system_msec_clock_temp));

                     canTransmit(canREG1, PSA_XCP_EA3_REQUEST_ID, ( uint8 *) ms_PSA_write_torque_value_neg_6p00nm2);
                break;

                default:
                    break;
                }  // end switch(torque_value_case_index)

            break;
            }   // end case TARGET_PSA_CMP

            case TARGET_BYD_SA2FL:
            case TARGET_GWM_A0607:
            {
                switch(torque_value_case_index)
                {
                case pos_0nm:  // zero nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_p1nm:  // +.1 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_p1nm:  // -.1 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_p5nm:  // +.5 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_p5nm:  //  -.5 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_1p00nm:  //  +1 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_1p00nm:  //  -1 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_1p50nm:  //  +1.5 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_1p50nm:  //  -1.5 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_2p00nm:  //  +2.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_2p00nm:  //  -2.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_2p50nm:  //  +2.50 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_2p50nm:  //  -2.50 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_3p00nm:  //  +3.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_3p00nm:  //  -3.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_3p50nm:  //  +3.50 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_3p50nm:  //  -3.50 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_4p00nm:  //  +4.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_4p00nm:  //  -4.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_6p00nm:  //  +6.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_6p00nm:  //  -6.00 nm torque
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, XCP_EA3_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                default:
                    break;
                }  // end switch(torque_value_case_index)

            break;
            }  // end case TARGET_SA2FL

            case TARGET_SGMW_CN200:
            {
                switch(torque_value_case_index)
                {
                case pos_0nm:  // zero nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_p1nm:  // +.1 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_p1nm:  // -.1 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_p5nm:  // +.5 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_p5nm:  //  -.5 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_1p00nm:  //  +1 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_1p00nm:  //  -1 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_1p50nm:  //  +1.5 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_1p50nm:  //  -1.5 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_2p00nm:  //  +2.00 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_2p00nm:  //  -2.00 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_2p50nm:  //  +2.50 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_2p50nm:  //  -2.50 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_3p00nm:  //  +3.00 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_3p00nm:  //  -3.00 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_3p50nm:  //  +3.50 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_3p50nm:  //  -3.50 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_4p00nm:  //  +4.00 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_4p00nm:  //  -4.00 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_6p00nm:  //  +6.00 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_6p00nm:  //  -6.00 nm torque
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, CN200_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                default:
                    break;
                }  // end switch(torque_value_case_index)

            break;
            }  // end case TARGET_SGMW_CN200

            case TARGET_FORD_T3_T6:
            {
                switch(torque_value_case_index)
                {
                case pos_0nm:  // zero nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_p1nm:  // +.1 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_p1nm:  // -.1 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_p5nm:  // +.5 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_p5nm:  //  -.5 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_1p00nm:  //  +1 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_1p00nm:  //  -1 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_1p50nm:  //  +1.5 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_1p50nm:  //  -1.5 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_2p00nm:  //  +2.00 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_2p00nm:  //  -2.00 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_2p50nm:  //  +2.50 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_2p50nm:  //  -2.50 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_3p00nm:  //  +3.00 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_3p00nm:  //  -3.00 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_3p50nm:  //  +3.50 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_3p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_3p50nm:  //  -3.50 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_3p50nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_4p00nm:  //  +4.00 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_4p00nm:  //  -4.00 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case pos_6p00nm:  //  +6.00 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case neg_6p00nm:  //  -6.00 nm torque
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 101)||(ECU2_XCP_reply_index != 101)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm2);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while(((ECU1_XCP_reply_index != 102)||(ECU2_XCP_reply_index != 102)) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, FORD_T3_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                    canTransmit(canREG1, FORD_T3_ECU2_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                default:
                    break;
                }  // end switch(torque_value_case_index)

            break;
            }  // end case TARGET_FORD_T3_T6

            case TARGET_RENAULT_NISSAN:
            {
                switch(torque_value_case_index)
                {
                case 0:  // zero nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_0nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 1:  // +.1 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p1nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 2:  // -.1 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p1nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 3:  // +.5 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_p5nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 4:  //  -.5 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_p5nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 5:  //  +1 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_1p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 6:  //  -1 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_1p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 7:  //  +2.00 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_2p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 8:  //  -2.00 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_2p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 9:  //  +4.00 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_4p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 10:  //  -4.00 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_4p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 11:  //  +6.00 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_pos_6p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                     while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                case 12:  //  -6.00 nm torque
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 101) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_neg_6p00nm2);

                    system_msec_clock_temp = system_msec_clock + 150;   // set time out to 150mS
                    while((ECU1_XCP_reply_index != 102) && (system_msec_clock < system_msec_clock_temp));
                    canTransmit(canREG1, RENAULT_NISSAN_ECU1_CAN1_XCP_EA4_REQUEST_ID, ( uint8 *) ms_write_torque_value_x30);
                break;

                default:
                    break;
                }  // end switch(torque_value_case_index)

            break;
            }  // end case TARGET_RENAULT_NISSAN

            case TARGET_BMW_UKL:
            case TARGET_BMW_FAAR_WE:
            {
                switch(torque_value_case_index)
                {
                case pos_0nm:  // zero nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;
                case pos_p1nm: // +.1 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0x3D;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0xCC;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0xCC;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0xCD;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case neg_p1nm:  //  -.1 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0xBD;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0xCC;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0xCC;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0xCD;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case pos_p5nm:  // +.5 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0x3F;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case neg_p5nm:  //  -.5 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0xBF;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case pos_1p00nm:  //  +1 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0x3F;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x80;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case neg_1p00nm:  //  -1 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0xBF;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x80;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case pos_1p50nm:  //  +1.5 nm torque3FC00000
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0x3F;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x80;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case neg_1p50nm:  //  -1.5 nm torqueBFC00000
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0xBF;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x80;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case pos_2p00nm:  //  +2.00 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0x40;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case neg_2p00nm:  //  -2.00 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0xC0;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case pos_2p50nm:  //  +2.50 nm torque40200000
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0x40;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x20;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case neg_2p50nm:  //  -2.50 nm torqueC0200000
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0xC0;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x20;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case pos_3p00nm:  //  +3.00 nm torque40400000
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0x40;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x40;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case neg_3p00nm:  //  -3.00 nm torqueC0400000
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0xC0;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x40;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case pos_3p50nm:  //  +3.50 nm torque40600000
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0x3F;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x80;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case neg_3p50nm:  //  -3.50 nm torqueC0600000
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0xC0;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x60;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case pos_4p00nm:  //  +4.00 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0x40;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x80;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case neg_4p00nm: //  -4.00 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0xC0;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0x80;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case pos_6p00nm:  //  +6.00 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0x40;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0xC0;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;

                case neg_6p00nm:  //  -6.00 nm torque
                    MFG_TX_mtr_trq_cmd_MSG[3][3] = 0xC0;
                    MFG_TX_mtr_trq_cmd_MSG[3][2] = 0xC0;
                    MFG_TX_mtr_trq_cmd_MSG[3][1] = 0x00;
                    MFG_TX_mtr_trq_cmd_MSG[3][0] = 0x00;
                    transmitFlexray(MFG_TX_mtr_trq_cmd_MSG,MFG_TX, 4); //length of 3 is probabl fine
                break;
                }
            break;
            } //end case TARGET_BMW_UKL OR case TARGET_BMW_FAAR_WE:


        }  // end switch(target_product) for TORQUE Command

    }  // end if(manufacturing_TOC == YES)

    else    // using SENT signals and Analog signals
    {

//                  sent_data_calculation_from_torque(&torque_value_case_index);// Designed to take a variable value and translate to SENT signals  --- (not implemented yet)

        switch(torque_value_case_index) // for now use tables, (will update both sensors in ADAS products L.C. 27SEP16)
        {
            case pos_0nm:  // zero nm torque
                sent_data_calculation_from_table(sent_data_array_pos_0nm);  // calc and stuff edge times into sent_edge_event_time[][]

//  use "GM SGMW CN200 MCIP EA4M rev02 validation software design & ref tables 09OCT17", Torque Analog tab to calc Analog Hex values


                DtoA_array[6][0] = 0x06;    // channel#6 T1 2.5v
                DtoA_array[6][1] = 0x7F;
                DtoA_array[6][2] = 0xFF;
                DtoA_array[7][0] = 0x27;    // channel#7 T2 2.5v Remember the leading "2" is flag to ISR that DAC load is complete
                DtoA_array[7][1] = 0x7F;
                DtoA_array[7][2] = 0xFF;
// or same as:  NOTE using memcpy(copies bytes), will require a unsigned short character constant for each hex number to be copied and 6 bytes
                memcpy(&DtoA_array[6], "\x00\x06\x00\x7F\x00\xFF", 6);      // channel#6 T1 2.5v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x7F\x00\xFF", 6);      // channel#7 T2 2.5v

            break;

            case pos_p1nm:  // pos_p1nm
                sent_data_calculation_from_table(sent_data_array_pos_p1nm); // calc and stuff edge times into sent_edge_event_time[][]

                memcpy(&DtoA_array[6], "\x00\x06\x00\x81\x00\x05", 6);      // channel#6 T1 2.52v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x7E\x00\xF9", 6);      // channel#7 T2 2.48v
            break;

            case neg_p1nm:  // neg_p1nm
                sent_data_calculation_from_table(sent_data_array_neg_p1nm); // calc and stuff edge times into sent_edge_event_time[][]

                memcpy(&DtoA_array[6], "\x00\x06\x00\x7E\x00\xF9", 6);      // channel#6 T1 2.48v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x81\x00\x05", 6);      // channel#7 T2 2.52v
            break;

            case pos_p5nm:  // pos_p5nm
                sent_data_calculation_from_table(sent_data_array_pos_p5nm); // calc and stuff edge times into sent_edge_event_time[][]

                memcpy(&DtoA_array[6], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#6 T1 2.6v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#7 T2 2.4v
            break;

            case neg_p5nm:  // neg_p5nm
                sent_data_calculation_from_table(sent_data_array_neg_p5nm); // calc and stuff edge times into sent_edge_event_time[][]

                memcpy(&DtoA_array[6], "\x00\x06\x00\x7A\x00\xE0", 6);      // channel#6 T1 2.4v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x85\x00\x1E", 6);      // channel#7 T2 2.6v
            break;

            case pos_1p00nm:  // pos_1p00nm
                sent_data_calculation_from_table(sent_data_array_pos_1p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#6 T1 2.6v
                    memcpy(&DtoA_array[7], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#7 T2 2.4v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x8A\x00\x3C", 6);      // channel#6 T1 2.7v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x75\x00\xC2", 6);      // channel#7 T2 2.3v
            break;

            case neg_1p00nm:  // neg_1p00nm
                sent_data_calculation_from_table(sent_data_array_neg_1p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#6 T1 2.4v
                    memcpy(&DtoA_array[7], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#7 T2 2.6v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x75\x00\xC2", 6);      // channel#6 T1 2.3v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x8A\x00\x3C", 6);      // channel#7 T2 2.7v
            break;

            case pos_1p50nm:  // pos_1p50nm
                sent_data_calculation_from_table(sent_data_array_pos_1p50nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#6 T1 2.6v
                    memcpy(&DtoA_array[7], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#7 T2 2.4v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x8F\x00\x5B", 6);      // channel#6 T1 2.8v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x70\x00\xA3", 6);      // channel#7 T2 2.2V

            break;

            case neg_1p50nm:  // neg_1p50nm
                sent_data_calculation_from_table(sent_data_array_neg_1p50nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#6 T1 2.4v
                    memcpy(&DtoA_array[7], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#7 T2 2.6v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x70\x00\xA3", 6);      // channel#6 T1 2.2v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x8F\x00\x5B", 6);      // channel#7 T2 2.8v
            break;

            case pos_2p00nm:  // pos_2p00nm
                sent_data_calculation_from_table(sent_data_array_pos_2p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#6 T1 2.6v
                    memcpy(&DtoA_array[7], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#7 T2 2.4v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x94\x00\x7A", 6);      // channel#6 T1 2.9v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x6B\x00\x84", 6);      // channel#7 T2 2.1v
            break;

            case neg_2p00nm:  // 0 seconds in 10 - 0 =10  beginning of sequence
                sent_data_calculation_from_table(sent_data_array_neg_2p00nm);    // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#6 T1 2.4v
                    memcpy(&DtoA_array[7], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#7 T2 2.6v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x6B\x00\x84", 6);      // channel#6 T1 2.1v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x94\x00\x7A", 6);      // channel#7 T2 2.9v
            break;

            case pos_2p50nm:  // pos_2p50nm
                sent_data_calculation_from_table(sent_data_array_pos_2p50nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#6 T1 2.6v
                    memcpy(&DtoA_array[7], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#7 T2 2.4v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x99\x00\x99", 6);      // channel#6 T1 3.0v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x66\x00\x66", 6);      // channel#7 T2 2.0v
            break;

            case neg_2p50nm:  // neg_2p50nm
                sent_data_calculation_from_table(sent_data_array_neg_2p50nm);    // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#6 T1 2.4v
                    memcpy(&DtoA_array[7], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#7 T2 2.6v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x66\x00\x66", 6);      // channel#6 T1 2.0v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x99\x00\x99", 6);      // channel#7 T2 3.0v
            break;

            case pos_3p00nm:  // pos_3p00nm
                sent_data_calculation_from_table(sent_data_array_pos_3p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#6 T1 2.6v
                    memcpy(&DtoA_array[7], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#7 T2 2.4v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x9E\x00\xB7", 6);      // channel#6 T1 3.1v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x61\x00\x47", 6);      // channel#7 T2 1.9v
            break;

            case neg_3p00nm:  // neg_3p00nm
                sent_data_calculation_from_table(sent_data_array_neg_3p00nm);    // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#6 T1 2.4v
                    memcpy(&DtoA_array[7], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#7 T2 2.6v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x61\x00\x47", 6);      // channel#6 T1 1.9v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x9E\x00\xB7", 6);      // channel#7 T2 3.1v
            break;

            case pos_3p50nm:  // pos_3p50nm
                sent_data_calculation_from_table(sent_data_array_pos_3p50nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#6 T1 2.6v
                    memcpy(&DtoA_array[7], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#7 T2 2.4v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\xA3\x00\xD6", 6);      // channel#6 T1 3.2v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x5C\x00\x28", 6);      // channel#7 T2 1.8v
            break;

            case neg_3p50nm:  // neg_3p50nm
                sent_data_calculation_from_table(sent_data_array_neg_3p50nm);    // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#6 T1 2.4v
                    memcpy(&DtoA_array[7], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#7 T2 2.6v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x5C\x00\x28", 6);      // channel#6 T1 1.8v
                memcpy(&DtoA_array[7], "\x00\x27\x00\xA3\x00\xD6", 6);      // channel#7 T2 3.2v
            break;

            case pos_4p00nm:  // pos_4p00nm
                sent_data_calculation_from_table(sent_data_array_pos_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#6 T1 2.6v
                    memcpy(&DtoA_array[7], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#7 T2 2.4v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\xA8\x00\xF5", 6);      // channel#6 T1 3.3v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x57\x00\x09", 6);      // channel#7 T2 1.7v
            break;

            case neg_4p00nm:  // neg_4p00nm
                sent_data_calculation_from_table(sent_data_array_neg_4p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#6 T1 2.4v
                    memcpy(&DtoA_array[7], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#7 T2 2.6v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x57\x00\x09", 6);      // channel#6 T1 1.7v
                memcpy(&DtoA_array[7], "\x00\x27\x00\xA8\x00\xF5", 6);      // channel#7 T2 3.3v
            break;

            case pos_6p00nm:  // pos_6p00nm
                sent_data_calculation_from_table(sent_data_array_pos_6p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#6 T1 2.6v
                    memcpy(&DtoA_array[7], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#7 T2 2.4v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\xBD\x00\x6F", 6);      // channel#6 T1 3.7v
                memcpy(&DtoA_array[7], "\x00\x27\x00\x42\x00\x8F", 6);      // channel#7 T2 1.3v
            break;

            case neg_6p00nm:  // neg_6p00nm
                sent_data_calculation_from_table(sent_data_array_neg_6p00nm);   // calc and stuff edge times into sent_edge_event_time[][]

                switch (target_product)
                {
                case TARGET_BMW_FAAR_WE:
                case TARGET_BMW_UKL:
                {

                //  Soft Start for BMW
                    memcpy(&DtoA_array[6], "\x00\x27\x00\x7A\x00\xE0", 6);      // channel#6 T1 2.4v
                    memcpy(&DtoA_array[7], "\x00\x06\x00\x85\x00\x1E", 6);      // channel#7 T2 2.6v

                    // normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
                            mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
                            mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).

                            system_msec_clock_temp = system_msec_clock + 500;  // wait .5 Sec, wait for rotor to move to stop
                            while(system_msec_clock < system_msec_clock_temp);
                    break;
                }
                }

                // Now, load as normal for all product types
                memcpy(&DtoA_array[6], "\x00\x06\x00\x42\x00\x8F", 6);      // channel#6 T1 1.3v
                memcpy(&DtoA_array[7], "\x00\x27\x00\xBD\x00\x6F", 6);      // channel#7 T2 3.7v
            break;

        }  // end switch on torque_value

// normally load constant, but we will use last DtoA_array and just update T1/T2    memcpy(&DtoA_array,&test_DtoA_load17,48);   // 2.5v on all 8 channels
        mibspiSetData(mibspiREG1, 0, (uint16 *)DtoA_array[0]);
        mibspiTransfer(mibspiREG1, 0);  //Initiates a transfer for the specified transfer group, interrupts will send other TGs (see notification.c).


    }   // if(manufacturing_TOC == YES) else so NO (use SENT )


}

/* USER CODE END */
